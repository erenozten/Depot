2021 - REPETITION!
-
-
-
-
-
-
To make sure that database connections are properly closed and the resources they hold freed up, you have to dispose the context instance when you are done with it. That is why the scaffolded code provides a Dispose method at the end of the StudentController class in StudentController.cs, as shown in the following example: 
protected override void Dispose(bool disposing)
{
    db.Dispose();
    base.Dispose(disposing);
}

If you don't specify a connection string or the name of one explicitly, Entity Framework assumes that the connection string name is the same as the class name. The default connection string name in this example would then be SchoolContext, the same as what you're specifying explicitly.
The name of the connection string (which you'll add to the Web.config file later) is passed in to the constructor.
public SchoolContext() : base("SchoolContext")
{
}
-
-
-
-
-
-
BOŞ		(bosch)	 (bosch)
ne nedir
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Delete(int id)
{
    try
    {
        Student student = db.Students.Find(id);
        db.Students.Remove(student);
        db.SaveChanges();
    }
    catch (DataException/* dex */)
    {
        //Log the error (uncomment dex variable name and add a line here to write a log.
        return RedirectToAction("Delete", new { id = id, saveChangesError = true });
    }
    return RedirectToAction("Index");
}
This code retrieves the selected entity, then calls the Remove method to set the entity's status to Deleted. When SaveChanges is called, a SQL DELETE command is generated. You have also changed the action method name from DeleteConfirmed to Delete. The scaffolded code named the HttpPost Delete method DeleteConfirmed to give the HttpPost method a unique signature. (The CLR requires overloaded methods to have different method parameters.) Now that the signatures are unique, you can stick with the MVC convention and use the same name for the HttpPost and HttpGet delete methods.
If improving performance in a high-volume application is a priority, you could avoid an unnecessary SQL query to retrieve the row by replacing the lines of code that call the Find and Remove methods with the following code:
C#Copy
Student studentToDelete = new Student() { ID = id };
db.Entry(studentToDelete).State = EntityState.Deleted;
This code instantiates a Student entity using only the primary key value and then sets the entity state to Deleted. That's all that the Entity Framework needs in order to delete the entity.
-
-
-
A query string is the portion of a URL where data is passed to a web application and/or back-end database. The reason we need query strings is that the HTTP protocol is stateless by design. For a website to be anything more than a brochure, you need to maintain state (store data). 
There are a number of ways to do this: On most web servers, you can use something like session state server-side. On the client, you can store via cookies. Or in the URL, you can store data via a query string. 

On the world wide web, all URLs can be broken down into the protocol, the location of the file (or program) and the query string. The protocol you see in a browser is almost always HTTP; the location is the typical form of the hostname and filename (for example, www.techopedia.com/somefile.html), and the query string is whatever follows the question mark sign ("?").
For example, in the URL below, the bolded area is the query string that was generated when the term "database" was searched on the Techopedia website.
//www.techopedia.com
-
-
-
-
-
-
HTTPPost method hides information from URL and does not bind data to URL. It is more secure than HttpGet method but it is slower than HttpGet. It is only useful when you are passing sensitive information to the server.
-
-
-
-
-
-
A static class can contain only the static members while a non-static class can contain static members. Static classes are by-default sealed so they cannot be inherited.
-
-
-
-
-
-
MVC, server-side bir sistemdir. Server-side sistemlerde end-user sadece html-javascript i görebilir. Csharp koduna erişemez.
Mvc bir UI-centric bir sistem değil; Server side’dır. 
-
-
-
-
-
Önemli repository bilgi:
You could instantiate a new context in the repository, but then if you used multiple repositories in one controller, each would end up with a separate context. Later you'll use multiple repositories in the Course controller, and you'll see how a unit of work class can ensure that all repositories use the same context.
-
-
-
-
-
-
Kısayollar / Keyboard Shortcuts	(GITHUB) (asasas)
Kısayol nedir, shortcut nedir
-
f2 - değişkene yeni isim ver (sistemdeki hepsinin)
ctrl alt f9  - breakpoint’e götürüyo seni

Ctrl  backspace    kelimeyi siliyo tamamen sola doğru
Ctrl  delete kelimeyi olduğu gibi siliyor. Sağa doğru siliyor. // ctrl + backspace de sola  doğru siliyor

ctrl + shift + nokta -> aynı değişkenlerin tümünü aynı anda editleme imkanı sağlıyor. (bende çalışmıyo)

-
Chrome offers “F5” key and the “Ctrl+R” key combination are used to reload the currently open Web page. 
Chrome also offers the reload shortcut combinations of “Ctrl + F5” and “Ctrl + Shift + R” to reload the currently open page and override the locally cached version.
Having cursor in the address field and pressing ENTER will also do the same as CTRL + F5
-Home, end (numpad’dakiler) : satırın başına ve sonuna gider. (shift ile de kullanılır, yazıyı seçmek için...)

-Klavyenin üstündeki normal home end tuşları: sayfanın başına ve sonuna gider.

-Numpad’daki home end tuşları ctrl ile kullanıldığında, tıpkı klavyenin üstündeki home-end tuşları gibi çalışıyor. Yani klavyenin üstündeki home-end tuşlarını kullanmaya gerek yok gibi görünüyor.

-Ctrl – yön tuşları  kelimenin başına sonuna gidiyor atlayarak.

-Next Error (F2) (çalışmadı)

-Previous error (Shift + F2) ) (çalışmadı)

-Expand Selection (Ctrl + W)

-Ctrl + n  search everywhere (acayip bişey) / create new file

- alt + yukarı aşağı arrows  iki satırın yerini birbiri arasında değiştirme.

- shift + alt  veya sadece alt-> kare alan seçme (çoklu satır)

-
Don’t use anything in the cache when making the request. Forces the browser to re-download every JavaScript file, image, text file, etc.

Empty Cache and Hard Reload
Empty Cache and hard reload = Empty the cache and Force the browser do re-download every JavaScript file, image, text file, etc.
Chrome kısayol: 
Crtl+F5 or Shift+F5 -> re-download cached content (i.e. JavaScript files, images, etc…)
Normal Reload
F5 or Control + R = Reload the current page
“Ctrl+R” is the same thing as pressing f5. This will use the cache in every way possible. If the browser can avoid re-downloading JavaScript files, images, text files, etc. then it will.
Note: Having cursor in the address field and pressing ENTER will also do the same as CTRL + F5
Hard reload / Force Refresh
Control + Shift + R or Control + F5 or Shift + F5 = ignoring cached content
Obviously if the cache is empty then it will have to do a hard reload in order to load the required/support files again. This will again force the browser to re-download everything. However, if the page makes any after the fact downloads via JavaScript that weren’t part of page load, then these might still use the cache, which is where emptying the cache helps because it makes sure that even these won’t use cached files.

RESHARPER:

Ctrl + T

-

Step over code to skip functions
When you are on a line of code that is a function or method call, you can press F10(Debug > Step Over) instead of F11.


Advance the debugger out of the current function
Sometimes, you might want to continue your debugging session but advance the debugger all the way through the current function.
Press Shift + F11 (or Debug > Step Out).
This command resumes app execution (and advances the debugger) until the current function returns.
-
F10 vs F11
https://stackoverflow.com/questions/15584132/what-is-the-difference-between-f10-and-f11-keys-in-visual-studio/39843982
F10 ("step over") does not descend any further into the call stack. It moves to the next line of the current function.
F11 ("step into") drills down into the function being called.
void function1()
{
    function2();
    function3();
}
If you hit a breakpoint on function2(), F10 will advance to the line function3(). F11 will advance to the first line inside function2.
-

CHROME
CTRL + SHIFT + C --> konsolu açmadan (ters tıklayıp incele demeden) mause'un üstünde olduğu elementi seçiyor. Muhteşem.

RESHARPER
alt FL   SAVE

ALT WL    QUIT ALL

ctrl D	  copy paste

ctrl tab   açık dosyalar arası geçiş 
ismin adının üstüne gelip F2 -> ismi değiştirmek için (projenin tümünde her yerde değiştirmek için)

ctrl shift r  bir class'ı yeni bir folder'a taşı

ctrl W kopyalıyor bi üst element/metoda kadar. (geri almak için: ctrl shift W)

alt aşağı / yukarı   metodlar arası geçiş

ctrl B  class definition'una gitme (ctrl click ile aynı)


windows+ sağ yön tuşu (visual studio’yu ekranın sağına yapıştırıyor. Google chrome’u açıp sola bas, onu da sola yapıştır.

f3    search yapılan text'i ara (diğer satırlarda)

ctrl alt J     kelimeyi <tag> ile çevreleme

ctrl f12    sayfa içinde text ara

ctrl shift R   model'imizi farklı bir klasöre taşımak istiyorsak. (namespace'i de değiştiriyor, kolaylık sağlıyor)

windows + sağ sol yukarı yön tuşları: progrmı büyütme yana yatırma 

ctrl tab   sekmeler arası geçiş

ctrl r     kullanma. F5 ile aynı. Eğer tam refresh yapmak istiyorsan ctrl shift f5 yap.

alt enter (en alttaki seçenekten: sayfadaki aynı textlerin tümünü değiştirme)
-
ctrl f10 - cursor'ın olduğu yere kadar projeyi çalıştırır. Break point koymuşsun gibi.
-
-
HARD RELOAD – NORMAL RELOAD nedir
Normal reload
The same thing as pressing F5. This will use the cache but revalidate everything during page load, looking for "304 Not Modified" responses. If the browser can avoid re-downloading cached JavaScript files, images, text files, etc. then it will.
________________________________________
Hard reload
Don't use anything in the cache when making the request. (which is equal to SHIFT+F5 No need to open Developer console) Force the browser do re-download every JavaScript file, image, text file, etc.


Hard reload / Force Refresh
Control + Shift + R or Control + F5 or Shift + F5 = ignoring cached content
Obviously if the cache is empty then it will have to do a hard reload in order to load the required/support files again. This will again force the browser to re-download everything. However, if the page makes any after the fact downloads via JavaScript that weren’t part of page load, then these might still use the cache, which is where emptying the cache helps because it makes sure that even these won’t use cached files.
RESHARPER:

Ctrl + T

-

Step over code to skip functions
When you are on a line of code that is a function or method call, you can press F10(Debug > Step Over) instead of F11.


Advance the debugger out of the current function
Sometimes, you might want to continue your debugging session but advance the debugger all the way through the current function.
Press Shift + F11 (or Debug > Step Out).
This command resumes app execution (and advances the debugger) until the current function returns.
-
F10 vs F11
https://stackoverflow.com/questions/15584132/what-is-the-difference-between-f10-and-f11-keys-in-visual-studio/39843982
F10 ("step over") does not descend any further into the call stack. It moves to the next line of the current function.
F11 ("step into") drills down into the function being called.
void function1()
{
    function2();
    function3();
}
If you hit a breakpoint on function2(), F10 will advance to the line function3(). F11 will advance to the first line inside function2.
-

CHROME
CTRL + SHIFT + C --> konsolu açmadan (ters tıklayıp incele demeden) mause'un üstünde olduğu elementi seçiyor. Muhteşem.

RESHARPER
alt FL   SAVE

ALT WL    QUIT ALL

ctrl D	  copy paste

ctrl tab   açık dosyalar arası geçiş 
ismin adının üstüne gelip F2 -> ismi değiştirmek için (projenin tümünde her yerde değiştirmek için)

ctrl shift r  bir class'ı yeni bir folder'a taşı

ctrl W kopyalıyor bi üst element/metoda kadar. (geri almak için: ctrl shift W)

alt aşağı / yukarı   metodlar arası geçiş

ctrl B  class definition'una gitme (ctrl click ile aynı)


windows+ sağ yön tuşu (visual studio’yu ekranın sağına yapıştırıyor. Google chrome’u açıp sola bas, onu da sola yapıştır.

f3    search yapılan text'i ara (diğer satırlarda)

ctrl alt J     kelimeyi <tag> ile çevreleme

ctrl f12    sayfa içinde text ara

ctrl shift R   model'imizi farklı bir klasöre taşımak istiyorsak. (namespace'i de değiştiriyor, kolaylık sağlıyor)

windows + sağ sol yukarı yön tuşları: progrmı büyütme yana yatırma 

ctrl tab   sekmeler arası geçiş

ctrl r     kullanma. F5 ile aynı. Eğer tam refresh yapmak istiyorsan ctrl shift f5 yap.

alt enter (en alttaki seçenekten: sayfadaki aynı textlerin tümünü değiştirme)
-
ctrl f10 - cursor'ın olduğu yere kadar projeyi çalıştırır. Break point koymuşsun gibi.

-
-
-
-
-
Bildirim için aşağıdaki yapıyı kullandık.
 
Bildirim için inheritance da kullanılabilirdi. Ama mantıklı olmazdı. O yüzden yukarıdaki gibi yaptık. Aşağıdaki gibi YAPMADIK.
Mosh hamedani: Her halta inheritance uygulama. İnheritance şu durumlarda kullanılır: polimorfizm gerekiyorsa, ortada "behavior" varsa. Bunlar yoksa inheritance falan uygulama. Çünkü gereksiz olur. Boşuna complexity artırırsın. Kodun zorlaşır.
-
-
-
-
Integral to integral conversions
Integral conversions are implicit when the destination type can represent every possible
value of the source type. Otherwise, an explicit conversion is required. For
example:
int x = 12345; // int is a 32-bit integral
long y = x; // Implicit conversion to 64-bit integral
short z = (short)x; // Explicit conversion to 16-bit integral
A float can be implicitly converted to a double, since a double can represent every
possible value of a float. The reverse conversion must be explicit.
-
-
(okundu - github)
Remember, that an if can have zero or more else if's and they must come before the last else, which is optional.
Once an else if succeeds, none of the remaining else if's or else clause will be tested.
-
A do-while loop is similar to a while loop, except that a do-while loop is guaranteed to execute at least one time.
-
-
-
-
-

(okundu – github)
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Delete(int id)
{
    try
    {
        Student student = db.Students.Find(id);
        db.Students.Remove(student);
        db.SaveChanges();
    }
    catch (DataException/* dex */)
    {
        //Log the error (uncomment dex variable name and add a line here to write a log.
        return RedirectToAction("Delete", new { id = id, saveChangesError = true });
    }
    return RedirectToAction("Index");
}
This code retrieves the selected entity, then calls the Remove method to set the entity's status to Deleted. When SaveChanges is called, a SQL DELETE command is generated. You have also changed the action method name from DeleteConfirmed to Delete. The scaffolded code named the HttpPost Delete method DeleteConfirmed to give the HttpPost method a unique signature. (The CLR requires overloaded methods to have different method parameters.) Now that the signatures are unique, you can stick with the MVC convention and use the same name for the HttpPost and HttpGet delete methods.
If improving performance in a high-volume application is a priority, you could avoid an unnecessary SQL query to retrieve the row by replacing the lines of code that call the Find and Remove methods with the following code:
C#Copy
Student studentToDelete = new Student() { ID = id };
db.Entry(studentToDelete).State = EntityState.Deleted;
This code instantiates a Student entity using only the primary key value and then sets the entity state to Deleted. That's all that the Entity Framework needs in order to delete the entity.
-
-
-
Performance considerations
In general, a web page shouldn't be loading an arbitrary number of rows. A query should use paging or a limiting approach. For example, the preceding query could use Take to limit the rows returned:
C#Kopyala
public class IndexModel : PageModel
{
    private readonly SchoolContext _context;
    private readonly MvcOptions _mvcOptions;

    public IndexModel(SchoolContext context, IOptions<MvcOptions> mvcOptions)
    {
        _context = context;
        _mvcOptions = mvcOptions.Value;
    }

    public IList<Student> Student { get;set; }

    public async Task OnGetAsync()
    {
        Student = await _context.Students.Take(
            _mvcOptions.MaxModelBindingCollectionSize).ToListAsync();
    }
}
Enumerating a large table in a view could return a partially constructed HTTP 200 response if a database exception occurs part way through the enumeration.
MaxModelBindingCollectionSize defaults to 1024. The following code sets MaxModelBindingCollectionSize:
C#Kopyala
public void ConfigureServices(IServiceCollection services)
{
    int MyMaxModelBindingCollectionSize = 100;
    Int32.TryParse(Configuration["MyMaxModelBindingCollectionSize"],
                               out MyMaxModelBindingCollectionSize);
    
    services.Configure<MvcOptions>(options => 
           options.MaxModelBindingCollectionSize = MyMaxModelBindingCollectionSize);

    services.AddRazorPages();

    services.AddDbContext<SchoolContext>(options =>
          options.UseSqlServer(Configuration.GetConnectionString("SchoolContext")));

    services.AddDatabaseDeveloperPageExceptionFilter();
}

-
-
-
<span asp-validation-for="Venue" class="text-danger"></span>
property'ler için validation kullanmazsan, class tarafında; property'leri required olarak işaretlemen bir işe yaramaz. Örneğin class'ımız şuydu:
public class ConcertFormViewModel
   {
       // property'leri string olarak oluşturduğumuza dikkat:
 
       [Required]
       public string Venue { get; set; }
       
       [Required]
       public string Date { get; set; }
       
       [Required]
       public string Time { get; set; }
       
       [Required]
       public byte Genre { get; set; }
       
       public IEnumerable<Genre> Genres { get; set; } // db'deki tüm Genre'leri dropdownlist'e eklemek için kullanacağımız property
 
       public DateTime GetDateTime()
       {
           return DateTime.Parse(string.Format("{0} {1}", Date, Time));
       }
   }


Bu required attribute'lerini kullanmak client side validation'lar için yeterli değil. View'da; gereken işlem yapılmalı ki validasyon çalışsın.. Yani şunu yazmamız lazım her property için:
<span asp-validation-for="Venue" class="text-danger"></span>

Örnek olarak; venue'nin validasyon yapan html helper'ini silmiş olalım view'dan. Bu durumda client side validation, aşağıdaki resimdeki gibi olacaktır:
 
Görüldüğü üzere venue boş bırakıldığı halde "The venue field is required" gibi bir uyarı verilmedi.
Son
-
-
Abstract data type 	(GITHUB) (örnek)
Abstract data type nedir
Abstract Data type (ADT) is a type (or class) for objects whose behaviour is defined by a set of value and a set of operations.
The definition of ADT only mentions what operations are to be performed but not how these operations will be implemented. It does not specify how data will be organized in memory and what algorithms will be used for implementing the operations. It is called “abstract” because it gives an implementation-independent view. The process of providing only the essentials and hiding the details is known as abstraction.
 
The user of data type does not need to know how that data type is implemented, for example, we have been using Primitive values like int, float, char data types only with the knowledge that these data type can operate and be performed on without any idea of how they are implemented. So a user only needs to know what a data type can do, but not how it will be implemented. Think of ADT as a black box which hides the inner structure and design of the data type. Now we’ll define three ADTs namely List ADT, Stack ADT, Queue ADT.

1.	List ADT
•	The data is generally stored in key sequence in a list which has a head structure consisting of count, pointers and address of compare function needed to compare the data in the list.
 
The data node contains the pointer to a data structure and a self-referential pointer which points to the next node in the list.

//List ADT Type Definitions 
typedef struct node 
{ 
 void *DataPtr; 
 struct node *link; 
} Node; 
typedef struct
{ 
 int count; 
 Node *pos; 
 Node *head; 
 Node *rear; 
 int (*compare) (void *argument1, void *argument2) 
} LIST;  
•	The List ADT Functions is given below:
 
A list contains elements of the same type arranged in sequential order and following operations can be performed on the list.
•	get() – Return an element from the list at any given position.
•	insert() – Insert an element at any position of the list.
•	remove() – Remove the first occurrence of any element from a non-empty list.
•	removeAt() – Remove the element at a specified location from a non-empty list.
•	replace() – Replace an element at any position by another element.
•	size() – Return the number of elements in the list.
•	isEmpty() – Return true if the list is empty, otherwise return false.
•	isFull() – Return true if the list is full, otherwise return false.

2.	Stack ADT

•	In Stack ADT Implementation instead of data being stored in each node, the pointer to data is stored.
•	The program allocates memory for the data and address is passed to the stack ADT.
 
•	The head node and the data nodes are encapsulated in the ADT. The calling function can only see the pointer to the stack.
•	The stack head structure also contains a pointer to top and count of number of entries currently in stack.

A Stack contains elements of the same type arranged in sequential order. All operations take place at a single end that is top of the stack and following operations can be performed:
•	push() – Insert an element at one end of the stack called top.
•	pop() – Remove and return the element at the top of the stack, if it is not empty.
•	peek() – Return the element at the top of the stack without removing it, if the stack is not empty. (peak  yani tepe kelimesinden akla getirilebilir)
•	size() – Return the number of elements in the stack.
•	isEmpty() – Return true if the stack is empty, otherwise return false.
•	isFull() – Return true if the stack is full, otherwise return false.

// C# code to illustrate the 
// Stack.Peek Method 
using System; 
using System.Collections; 
  
class GFG { 
  
    // Driver code 
    public static void Main() 
    { 
  
        // Creating a Stack 
        Stack myStack = new Stack(); 
  
        // Inserting the elements into the Stack 
        myStack.Push("1st Element"); 
        myStack.Push("2nd Element"); 
        myStack.Push("3rd Element"); 
        myStack.Push("4th Element"); 
        myStack.Push("5th Element"); 
        myStack.Push("6th Element"); 
  
        // Displaying the count of elements 
        // contained in the Stack 
        Console.Write("Total number of elements"+ 
                         " in the Stack are : "); 
  
        Console.WriteLine(myStack.Count); 
  
        // Displaying the top element of Stack 
        // without removing it from the Stack 
        Console.WriteLine("Element at the top is : " 
                                  + myStack.Peek()); 
  
        // Displaying the top element of Stack 
        // without removing it from the Stack 
        Console.WriteLine("Element at the top is : " 
                                + myStack.Peek()); 
  
        // Displaying the count of elements 
        // contained in the Stack 
        Console.Write("Total number of elements "+ 
                           "in the Stack are : "); 
  
        Console.WriteLine(myStack.Count); 
    } 
-
-
-




3.	Queue ADT
•	The queue abstract data type (ADT) follows the basic design of the stack abstract data type.
 
•	Each node contains a void pointer to the data and the link pointer to the next element in the queue. The program’s responsibility is to allocate memory for storing the data.


//Queue ADT Type Definitions 
typedef struct node 
{ 
 void *DataPtr; 
 struct node *next; 
} QueueNode; 
typedef struct 
{ 
 QueueNode *front; 
 QueueNode *rear; 
 int count; 
} QUEUE; 

A Queue contains elements of the same type arranged in sequential order. Operations take place at both ends, insertion is done at the end and deletion is done at the front. Following operations can be performed:
•	enqueue() – Insert an element at the end of the queue.
•	dequeue() – Remove and return the first element of the queue, if the queue is not empty.
•	peek() – Return the element of the queue without removing it, if the queue is not empty.
•	size() – Return the number of elements in the queue.
•	isEmpty() – Return true if the queue is empty, otherwise return false.
•	isFull() – Return true if the queue is full, otherwise return false.
From these definitions, we can clearly see that the definitions do not specify how these ADTs will be represented and how the operations will be carried out. There can be different ways to implement an ADT, for example, the List ADT can be implemented using arrays, or singly linked list or doubly linked list. Similarly, stack ADT and Queue ADT can be implemented using arrays or linked lists.
Reference: https://en.wikipedia.org/wiki/Abstract_data_type
This article is contributed by Anuj Chauhan. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.
Don’t stop now and take your learning to the next level. Learn all the important concepts of Data Structures and Algorithms with the help of the most trusted course: DSA Self Paced. Become industry ready at a student-friendly price.
-
-
-
-
-
In Controllers\StudentController.cs, the action method for the Details view uses the Find method to retrieve a single Student entity. 
public ActionResult Details(int? id) 
{ 
if (id == null) 
{ 
return new HttpStatusCodeResult(HttpStatusCode.BadRequest); 
} 
Student student = db.Students.Find(id); 
if (student == null) 
{ 
return HttpNotFound(); 
} 
return View(student); 
}
-
-
-
-
Action Filter, Filter MSDN
Action filter nedir
Action filter dediğimiz aslında action metotların çalışma öncesi ve sonrasına hayat veren özel attribute sınıflarıdır.
Action filter executes before and after an action method executes. Action filter attributes can be applied to an individual action method or to a controller. When action filter applied to controller then it will be applied to all the action methods in that controller.
OutputCache is a built-in action filter attribute that can be apply to an action method for which we want to cache the output. For example, output of the following action method will be cached for 100 seconds.
Example: ActionFilter

[OutputCache(Duration=100)]
public ActionResult Index()
{
    return View();
}
-
-
Filters in ASP.NET Core allow code to be run before or after specific stages in the request processing pipeline.
Built-in filters handle tasks such as:
•	Authorization (preventing access to resources a user isn't authorized for).
•	Response caching (short-circuiting the request pipeline to return a cached response).
Custom filters can be created to handle cross-cutting concerns. Examples of cross-cutting concerns include error handling, caching, configuration, authorization, and logging. Filters avoid duplicating code. For example, an error handling exception filter could consolidate error handling.
This document applies to Razor Pages, API controllers, and controllers with views. Filters don't work directly with Razor components. A filter can only indirectly affect a component when:
•	The component is embedded in a page or view.
•	The page or controller/view uses the filter.
View or download sample (how to download).

How filters work
Filters run within the ASP.NET Core action invocation pipeline, sometimes referred to as the filter pipeline. The filter pipeline runs after ASP.NET Core selects the action to execute.
 
Filter types
Each filter type is executed at a different stage in the filter pipeline:
•	Authorization filters run first and are used to determine whether the user is authorized for the request. Authorization filters short-circuit the pipeline if the request is not authorized.
•	Resource filters:
o	Run after authorization.
o	OnResourceExecuting runs code before the rest of the filter pipeline. For example, OnResourceExecuting runs code before model binding.
o	OnResourceExecuted runs code after the rest of the pipeline has completed.
•	Action filters:
o	Run code immediately before and after an action method is called.
o	Can change the arguments passed into an action.
o	Can change the result returned from the action.
o	Are not supported in Razor Pages.
•	Exception filters apply global policies to unhandled exceptions that occur before the response body has been written to.
•	Result filters run code immediately before and after the execution of action results. They run only when the action method has executed successfully. They are useful for logic that must surround view or formatter execution.

The following diagram shows how filter types interact in the filter pipeline.
 
Implementation
Filters support both synchronous and asynchronous implementations through different interface definitions.
Synchronous filters run code before and after their pipeline stage. For example, OnActionExecuting is called before the action method is called. OnActionExecuted is called after the action method returns.
C#Copy
public class MySampleActionFilter : IActionFilter 
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        // Do something before the action executes.
        MyDebug.Write(MethodBase.GetCurrentMethod(), context.HttpContext.Request.Path);
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        // Do something after the action executes.
        MyDebug.Write(MethodBase.GetCurrentMethod(), context.HttpContext.Request.Path);
    }
}
In the preceding code, MyDebug is a utility function in the sample download.
Asynchronous filters define an On-Stage-ExecutionAsync method. For example, OnActionExecutionAsync:
C#Copy
public class SampleAsyncActionFilter : IAsyncActionFilter
{
    public async Task OnActionExecutionAsync(
        ActionExecutingContext context,
        ActionExecutionDelegate next)
    {
        // Do something before the action executes.

        // next() calls the action method.
        var resultContext = await next();
        // resultContext.Result is set.
        // Do something after the action executes.
    }
}
In the preceding code, the SampleAsyncActionFilter has an ActionExecutionDelegate (next) that executes the action method.

Multiple filter stages
Interfaces for multiple filter stages can be implemented in a single class. For example, the ActionFilterAttribute class implements:
•	Synchronous: IActionFilter and IResultFilter
•	Asynchronous: IAsyncActionFilter and IAsyncResultFilter
•	IOrderedFilter
Implement either the synchronous or the async version of a filter interface, not both. The runtime checks first to see if the filter implements the async interface, and if so, it calls that. If not, it calls the synchronous interface's method(s). If both asynchronous and synchronous interfaces are implemented in one class, only the async method is called. When using abstract classes like ActionFilterAttribute, override only the synchronous methods or the asynchronous methods for each filter type.
Built-in filter attributes
ASP.NET Core includes built-in attribute-based filters that can be subclassed and customized. For example, the following result filter adds a header to the response:
C#Copy
public class AddHeaderAttribute : ResultFilterAttribute
{
    private readonly string _name;
    private readonly string _value;

    public AddHeaderAttribute(string name, string value)
    {
        _name = name;
        _value = value;
    }

    public override void OnResultExecuting(ResultExecutingContext context)
    {
        context.HttpContext.Response.Headers.Add( _name, new string[] { _value });
        base.OnResultExecuting(context);
    }
}
Attributes allow filters to accept arguments, as shown in the preceding example. Apply the AddHeaderAttribute to a controller or action method and specify the name and value of the HTTP header:
C#Copy
[AddHeader("Author", "Rick Anderson")]
public class SampleController : Controller
{
    public IActionResult Index()
    {
        return Content("Examine the headers using the F12 developer tools.");
    }
Use a tool such as the browser developer tools to examine the headers. Under Response Headers, author: Rick Anderson is displayed.
The following code implements an ActionFilterAttribute that:
•	Reads the title and name from the configuration system. Unlike the previous sample, the following code doesn't require filter parameters to be added to the code.
•	Adds the title and name to the response header.
C#Copy
public class MyActionFilterAttribute : ActionFilterAttribute
{
    private readonly PositionOptions _settings;

    public MyActionFilterAttribute(IOptions<PositionOptions> options)
    {
        _settings = options.Value;
        Order = 1;
    }

    public override void OnResultExecuting(ResultExecutingContext context)
    {
        context.HttpContext.Response.Headers.Add(_settings.Title, 
                                                 new string[] { _settings.Name });
        base.OnResultExecuting(context);
    }
}
The configuration options are provided from the configuration system using the options pattern. For example, from the appsettings.json file:
JSONCopy
{
  "Position": {
    "Title": "Editor",
    "Name": "Joe Smith"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}
In the StartUp.ConfigureServices:
•	The PositionOptions class is added to the service container with the "Position" configuration area.
•	The MyActionFilterAttribute is added to the service container.
C#Copy
public void ConfigureServices(IServiceCollection services)
{
    services.Configure<PositionOptions>(
             Configuration.GetSection("Position"));
    services.AddScoped<MyActionFilterAttribute>();

    services.AddControllersWithViews();
}
The following code shows the PositionOptions class:
C#Copy
public class PositionOptions
{
    public string Title { get; set; }
    public string Name { get; set; }
}
The following code applies the MyActionFilterAttribute to the Index2 method:
C#Copy
[AddHeader("Author", "Rick Anderson")]
public class SampleController : Controller
{
    public IActionResult Index()
    {
        return Content("Examine the headers using the F12 developer tools.");
    }

    [ServiceFilter(typeof(MyActionFilterAttribute))]
    public IActionResult Index2()
    {
        return Content("Header values by configuration.");
    }

Under Response Headers, author: Rick Anderson, and Editor: Joe Smith is displayed when the Sample/Index2 endpoint is called.
The following code applies the MyActionFilterAttribute and the AddHeaderAttribute to the Razor Page:
C#Copy
[AddHeader("Author", "Rick Anderson")]
[ServiceFilter(typeof(MyActionFilterAttribute))]
public class IndexModel : PageModel
{
    public void OnGet()
    {
    }
}
Filters cannot be applied to Razor Page handler methods. They can be applied either to the Razor Page model or globally.
Several of the filter interfaces have corresponding attributes that can be used as base classes for custom implementations.
Filter attributes:
•	ActionFilterAttribute
•	ExceptionFilterAttribute
•	ResultFilterAttribute
•	FormatFilterAttribute
•	ServiceFilterAttribute
•	TypeFilterAttribute
Filter scopes and order 
Action filters
Action filters do not apply to Razor Pages. Razor Pages supports IPageFilter and IAsyncPageFilter . For more information, see Filter methods for Razor Pages.
Action filters:
•	Implement either the IActionFilter or IAsyncActionFilter interface.
•	Their execution surrounds the execution of action methods.
The following code shows a sample action filter:
C#Copy
public class MySampleActionFilter : IActionFilter 
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        // Do something before the action executes.
        MyDebug.Write(MethodBase.GetCurrentMethod(), context.HttpContext.Request.Path);
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        // Do something after the action executes.
        MyDebug.Write(MethodBase.GetCurrentMethod(), context.HttpContext.Request.Path);
    }
}
The ActionExecutingContext provides the following properties:
•	ActionArguments - enables reading the inputs to an action method.
•	Controller - enables manipulating the controller instance.
•	Result - setting Result short-circuits execution of the action method and subsequent action filters.
Throwing an exception in an action method:
•	Prevents running of subsequent filters.
•	Unlike setting Result, is treated as a failure instead of a successful result.
The ActionExecutedContext provides Controller and Result plus the following properties:
•	Canceled - True if the action execution was short-circuited by another filter.
•	Exception - Non-null if the action or a previously run action filter threw an exception. Setting this property to null:
o	Effectively handles the exception.
o	Result is executed as if it was returned from the action method.
For an IAsyncActionFilter, a call to the ActionExecutionDelegate:
•	Executes any subsequent action filters and the action method.
•	Returns ActionExecutedContext.
To short-circuit, assign Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext.Result to a result instance and don't call next (the ActionExecutionDelegate).

The framework provides an abstract ActionFilterAttribute that can be subclassed.
The OnActionExecuting action filter can be used to:
•	Validate model state.
•	Return an error if the state is invalid.
C#Copy
public class ValidateModelAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext 
                                           context)
    {
        if (!context.ModelState.IsValid)
        {
            context.Result = new BadRequestObjectResult(
                                                context.ModelState);
        }
    }
 Note
Controllers annotated with the [ApiController] attribute automatically validate model state and return a 400 response. For more information, see Automatic HTTP 400 responses.
The OnActionExecuted method runs after the action method:
•	And can see and manipulate the results of the action through the Result property.
•	Canceled is set to true if the action execution was short-circuited by another filter.
•	Exception is set to a non-null value if the action or a subsequent action filter threw an exception. Setting Exception to null:
o	Effectively handles an exception.
o	ActionExecutedContext.Result is executed as if it were returned normally from the action method.
C#Copy
public class ValidateModelAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext 
                                           context)
    {
        if (!context.ModelState.IsValid)
        {
            context.Result = new BadRequestObjectResult(
                                                context.ModelState);
        }
    }


    public override void OnActionExecuted(ActionExecutedContext 
                                          context)
    {
        var result = context.Result;
        // Do something with Result.
        if (context.Canceled == true)
        {
            // Action execution was short-circuited by another filter.
        }

        if(context.Exception != null)
        {
            // Exception thrown by action or action filter.
            // Set to null to handle the exception.
            context.Exception = null;
        }
        base.OnActionExecuted(context);
    }
}
-
-
-
-
-
Association, aggregation, and composition in OOP explained
How to use association, aggregation, and composition to define relationships between the objects in your application
•	 
 
•	 
 
•	 
 
•	 
 
•	 
 
•	 
 
The Unified Modeling Language (UML) is a de-facto standard for modeling object-oriented systems. In UML there are five different types of relationships: association, aggregation, composition, dependency, and inheritance. This article presents a discussion of the first three of these concepts, leaving the remaining ones to another blog post.
[ .Net roadmap: The new features you can expect in .Net Standard 2.1. | .Net Framework or .Net Core? Learn when to use which. | Keep up with hot topics in programming with InfoWorld’s App Dev Report newsletter. ]
Association in object oriented programming
Association is a semantically weak relationship (a semantic dependency) between otherwise unrelated objects. An association is a “using” relationship between two or more objects in which the objects have their own lifetime and there is no owner.
As an example, imagine the relationship between a doctor and a patient. A doctor can be associated with multiple patients. At the same time, one patient can visit multiple doctors for treatment or consultation. Each of these objects has its own life cycle and there is no “owner” or parent. The objects that are part of the association relationship can be created and destroyed independently.
In UML an association relationship is represented by a single arrow. An association relationship can be represented as one-to-one, one-to-many, or many-to-many (also known as cardinality). Essentially, an association relationship between two or more objects denotes a path of communication (also called a link) between them so that one object can send a message to another. The following code snippet illustrates how two classes, IDGBlogAccount and IDGBlogEntry, are associated with one another.
public class IDGBlogAccount
   {
       private IDGBlogEntry[] blogEntries;
       //Other members of the IDGBlogAccount class
   }
public class IDGBlogEntry
   {
       Int32 blogId;
       string caption;
       string text;
       //Other members of the IDGBlogEntry class
   }
-

Aggregation in object oriented programming
Aggregation is a specialized form of association between two or more objects in which each object has its own life cycle but there exists an ownership as well. Aggregation is a typical whole/part or parent/child relationship but it may or may not denote physical containment. An essential property of an aggregation relationship is that the whole or parent (i.e. the owner) can exist without the part or child and vice versa.  
As an example, an employee may belong to one or more departments in an organization. However, if an employee’s department is deleted, the employee object would not be destroyed but would live on. Note that the relationships between objects participating in an aggregation cannot be reciprocal—i.e., a department may “own” an employee, but the employee does not own the department. In the following code example, an aggregation relationship is evident between the IDGBlogAuthor and IDGBlogAccount classes.
public class IDGBlogAuthor
   {
       private Int32 authorId;
       private string firstName;
       private string lastName;
       //Other members of the IDGBlogAuthor class
   }
public class IDGBlogAccount
   {
       private IDGBlogEntry[] blogEntries;
       //Other members of the IDGBlogAccount class
   }
Aggregation is usually represented in UML using a line with a hollow diamond. Like association, aggregation can involve a one-to-one, one-to-many, or many-to-many relationship between the participating objects. In the case of a one-to-many or many-to-many relationship, we may say that it is a redundant relationship.
-
Composition in object oriented programming
Composition is a specialized form of aggregation. In composition, if the parent object is destroyed, then the child objects also cease to exist. Composition is actually a strong type of aggregation and is sometimes referred to as a “death” relationship. As an example, a house may be composed of one or more rooms. If the house is destroyed, then all of the rooms that are part of the house are also destroyed. The following code snippet illustrates a composition relationship between two classes, House and Room.
public class House
{
   private Room room;
   public House()
   {
       room = new Room();
   }
}
Like aggregation, composition is also a whole/part or parent/child relationship. However, in composition the life cycle of the part or child is controlled by the whole or parent that owns it. It should be noted that this control can either be direct or transitive. That is, the parent may be directly responsible for the creation or destruction of the child or the parent may use a child that has been already created. Similarly, a parent object might delegate the control to some other parent to destroy the child object. Composition is represented in UML using a line connecting the objects with a solid diamond at the end of the object that owns the other object.
I hope this discussion of association, aggregation, and composition relationships has helped you understand how these three concepts differ. Remember that aggregation and composition are both subsets of association. In both aggregation and composition, an object of one class can be the owner of an object of another class. And in both aggregation and composition, the child objects belong to a single parent object, i.e., they may have only one owner.
Finally, in an aggregation relationship, the life cycles of parent objects and child objects are independent. In a composition relationship, the death of a parent object also means the death of its children.
-
-
-
-
-
-
Assigning			      (GITHUB)  (test)
Assign nedir, assigning nedir
Assigning is simply the storing of one value to a variable.  x = 5 assigns the value 5 to the variable  x.
(assign kelime anlamı: allocate (a job or duty) / to give a particular job or piece of work to someone: “The case has been assigned to our most senior officer.”)
x = 5 assigns the value 5 to the variable  x. In some languages, assignment cannot be combined with declaration, but in C# it can be: int x = 5;
Note that the statement object myObject = new object(); combines all four of these.
new object() instantiates a new object object, returning a reference to it.
object myObject declares a new object reference.
= initializes the reference variable by assigning the value of the reference to it.
-
-
-
-
-
Authentication and authorization might sound similar, but they are distinct security processes in the world of identity and access management (IAM).
Authentication confirms that users are who they say they are. Authorization gives those users permission to access a resource.
What Is Authentication?
Authentication is the act of validating that users are whom they claim to be. This is the first step in any security process. 
Complete an authentication process through:
•	Passwords. Usernames and passwords are the most common authentication factors. If a user enters the correct data, the system assumes the identity is valid and grants access.
•	One-time pins. Grant access for only one session or transaction.
•	Authentication apps. Generate security codes via an outside party that grants access.
•	Biometrics. A user presents a fingerprint or eye scan to gain access to the system. 
In some instances, systems require the successful verification of more than one factor before granting access. This multi-factor authentication (MFA) requirement is often deployed to increase security beyond what passwords alone can provide.

What Is Authorization?
Authorization in a system security is the process of giving the user permission to access a specific resource or function. This term is often used interchangeably with access control or client privilege. 
Giving someone permission to download a particular file on a server or providing individual users with administrative access to an application are good examples of authentication. 
In secure environments, authorization must always follow authentication. Users should first prove that their identities are genuine before an organization’s administrators grant them access to the requested resources.
-
-
-
-
-


-
Instance ve obje arasındaki fark! Instance nedir, object nedir
-
-
The Instance and Object are from Object Oriented Programming.
For some programming languages like Java, C++, and Smalltalk, it is important to describe and understand code. In other languages that used in Structured Programming, this concept doesn't exist.
This is a view from Structural Programming. There's no real significant difference that should consume too much of your time. There might be some fancy language that some people might take up a lot of spaces to write about, but at the end of the day, as far as a coder, developer, programmer, architect, is concerned, an instance of a class and an object mean the same thing and can often be used interchangeably. I have never met anyone in my career that would be picky and spend a half-hour trying to point out the differences because there's really none. Time can be better spent on other development efforts.
UPDATE With regards to Swift, this is what Apple who invented Swift prefers :
An instance of a class is traditionally known as an object. However, Swift classes and structures are much closer in functionality than in other languages, and much of this chapter describes functionality that can apply to instances of either a class or a structure type. Because of this, the more general term instance is used.
-
SQL alıştırma siteleri:

https://sqlbolt.com/lesson/select_queries_with_constraints

https://www.hackerrank.com/challenges/revising-the-select-query/problem
-
-
-
Properties expose fields. Fields should (almost always) be kept private to a class and accessed via get and set properties. 
Properties provide a level of abstraction allowing you to change the fields while not affecting the external way they are accessed by the things that use your class.

public class MyClass
{

    // this is a field.  It is private to your class and stores the actual data.
    private string _myField;

    // this is a property. When accessed it uses the underlying field,
    // but only exposes the contract, which will not be affected by the underlying field
    public string MyProperty
    {
        get
        {
            return _myField;
        }
        set
        {
            _myField = value;
        }
    }

    // This is an AutoProperty (C# 3.0 and higher) - which is a shorthand syntax
    // used to generate a private field for you
    public int AnotherProperty{get;set;} 
}
-
Constant (GITHUB)
[constant nedir, constants nedir, const nedir]

MSDN:
You use the const keyword to declare a constant field or a constant local. Constant fields and locals aren't variables and may not be modified. Constants can be numbers, Boolean values, strings, or a null reference. Don’t create a constant to represent information that you expect to change at any time. For example, don’t use a constant field to store the price of a service, a product version number, or the brand name of a company. These values can change over time, and because compilers propagate constants, other code compiled with your libraries will have to be recompiled to see the changes. See also the readonly keyword. For example:
const int X = 0;
public const double GravitationalConstant = 6.673e-11;
private const string ProductName = "Visual C#";
-
-
-
-
-
-
Constant (GITHUB)
[constant nedir, constants nedir, const nedir]
MSDN:
You use the const keyword to declare a constant field or a constant local. Constant fields and locals aren't variables and may not be modified. Constants can be numbers, Boolean values, strings, or a null reference. Don’t create a constant to represent information that you expect to change at any time. For example, don’t use a constant field to store the price of a service, a product version number, or the brand name of a company. These values can change over time, and because compilers propagate constants, other code compiled with your libraries will have to be recompiled to see the changes. See also the readonly keyword. For example:
const int X = 0;
public const double GravitationalConstant = 6.673e-11;
private const string ProductName = "Visual C#";

Remarks
The type of a constant declaration specifies the type of the members that the declaration introduces. The initializer of a constant local or a constant field must be a constant expression that can be implicitly converted to the target type.
A constant expression is an expression that can be fully evaluated at compile time. Therefore, the only possible values for constants of reference types are string and a null reference.
The constant declaration can declare multiple constants, such as:
C#Copy
public const double X = 1.0, Y = 2.0, Z = 3.0;
The static modifier is not allowed in a constant declaration.
A constant can participate in a constant expression, as follows:
C#Copy
public const int C1 = 5;
public const int C2 = C1 + 100;
 Note
The readonly keyword differs from the const keyword. A const field can only be initialized at the declaration of the field. A readonly field can be initialized either at the declaration or in a constructor. Therefore, readonly fields can have different values depending on the constructor used. Also, although a const field is a compile-time constant, the readonly field can be used for run-time constants, as in this line: public static readonly uint l1 = (uint)DateTime.Now.Ticks;

Example
C#Copy
public class ConstTest
{
    class SampleClass
    {
        public int x;
        public int y;
        public const int C1 = 5;
        public const int C2 = C1 + 5;

        public SampleClass(int p1, int p2)
        {
            x = p1;
            y = p2;
        }
    }

    static void Main()
    {
        var mC = new SampleClass(11, 22);
        Console.WriteLine($"x = {mC.x}, y = {mC.y}");
        Console.WriteLine($"C1 = {SampleClass.C1}, C2 = {SampleClass.C2}");
    }
}

/* Output
    x = 11, y = 22
    C1 = 5, C2 = 10
*/
Example
This example demonstrates how to use constants as local variables.
C#Copy
public class SealedTest
{
    static void Main()
    {
        const int C = 707;
        Console.WriteLine($"My local constant = {C}");
    }
}
// Output: My local constant = 707
-
-
-
Constants store a value that cannot be changed from their initial assignment.
To declare a constant, use the const modifier.
For example:
const double PI = 3.14; 

The value of const PI cannot be changed during program execution.
- 
Constants store a value that cannot be changed from their initial assignment.
To declare a constant, use the const modifier. For example: 
const double PI = 3.14;
PI = 8; //error
(Constants must be initialized with a value when declared.)
-
Difference between readonly and const keyword in C#  	 (GITHUB)
const nedir, readonly nedir  
In C#, a const keyword is used to declare constant fields and constant local. The value of the constant field is the same throughout the program or in other words, once the constant field is assigned the value of this field is not be changed. In C#, constant fields and locals are not variables, a constant is a number, string, null reference, boolean values.

Example:
// C# program to illustrate the 
// use of const keyword 
using System; 
  
class GFG { 
  
    // Constant fields 
    public const int myvar = 10; 
    public const string str = "GeeksforGeeks"; 
  
    // Main method 
    static public void Main() 
    { 
  
        // Display the value of Constant fields 
        Console.WriteLine("The value of myvar: {0}", myvar); 
        Console.WriteLine("The value of str: {0}", str); 
    } <} 
Output:

The value of myvar: 10
The value of str: GeeksforGeeks
In C#, you can use a readonly keyword to declare a readonly variable. This readonly keyword shows that you can assign the variable only when you declare a variable or in a constructor of the same class in which it is declared.

// C# program to illustrate the use  
// of the readonly keyword 
using System; 
  
class GFG { 
  
    // readonly variables 
    public readonly int myvar1; 
    public readonly int myvar2; 
  
    // Values of the readonly  
    // variables are assigned 
    // Using constructor 
    public GFG(int b, int c) 
    { 
  
        myvar1 = b; 
        myvar2 = c; 
        Console.WriteLine("Display value of myvar1 {0}, "+ 
                        "and myvar2 {1}", myvar1, myvar2); 
    } 
  
    // Main method 
    static public void Main() 
    { 
        GFG obj1 = new GFG(100, 200); 
    } 
} 
Output:
Display value of myvar1 100, and myvar2 200 
ReadOnly Vs Const Keyword
-
-
-
-
-
-
Constructors
Class’larda constructor’u sen belirtmesen bile, constructor’lar IMPLICIT olarak zaten yaratılırlar. Sen explicit olarak yazmasan dahi vardır yani ve sen bir obje initialize edeceğin zaman bu constructor her halükarda çalışacaktır. Sen ister yazmış ol ister yazmamış ol.
A class constructor is a special member method of a class that is executed whenever a new object of that class is created.
-
-
-
-
Data Types in C# (Reference Type, Value Type) 	      (GITHUB)  (test)
Data type nedir, data types nedir, ref type nedir, reference type nedir, value types nedir, value type nedir
Önemli: https://www.tutorialsteacher.com/csharp/csharp-data-types

The following data types are all of value type:
•	bool
•	byte
•	char
•	decimal
•	double
•	enum
•	float
•	int
•	long
•	sbyte
•	short
•	struct
•	uint
•	ulong
•	ushort
-
-
-
-
-
C# mainly categorized data types in two types: Value types and Reference types. Value types include simple types (e.g. int, float, bool, and char), enum types, struct types, and Nullable value types. 
Reference types include class types, interface types, delegate types, and array types. 
Learn about value types and reference types in detail in the next chapter.
 
Reference Types:
Reference types have null value by default, when they are not initialized.
For example, a string variable (or any other variable of reference type datatype) without a value assigned to it. In this case, it has a null value, meaning it doesn't point to any other memory location, because it has no value yet.
A value type variable cannot be null because it holds a value not a memory address. However, value type variables must be assigned some value before use. 

The compiler will give an error if you try to use a local value type variable without assigning a value to it. However, value type field in a class can be declared without initialization (field is not a local variable in the function). It will have a default value if not assigned any value, e.g., int will have 0, boolean will have false and so on.
(Field variables: Variable that are declared as a member of a class. OR Variables declared outside any method/constructor but inside the class block.
Scope: they can live as long as the instance they belong to is active.

Local variables: Variables that are declared within a method or a specific block of statements.)
-

class myClass
{
    public int i;
}

myClass mcls = new myClass();

Console.WriteLine(mcls.i); 
 
Output: 0
-

Aşağıdaki örnekte yukardaki olay açığa çıkıyor:

using System;

class Program
{
         // Hata oluşmaması için int a; ve int b; deklarasyonu burada, yani class içind yapılmalıydı!
	  // Hata oluşmasının sebebi şu: Local variable’larda initialization yapılmaz! (yani int a; -> 0’a eşitlenmez.
         // Fakat field’lar initialize edilir… yani int a; dediğimizde a değişkeni 0’a eşitlenir…
         // Kısacası, bir değişkenin (field veya local variable) otomatik olarak initialize edilmesini istiyorsan, bu değişkeni metot içinde değil, class içinde deklare etmelisin!

    static void Main()
    {
        int a;
        string b;

        Console.WriteLine(a); // Hata! Use of unassigned loal variable 'a'
        Console.WriteLine(b); // Hata! Use of unassigned loal variable 'b'

        // instance method çağırılıyor
        SampleClass sampleClass = new SampleClass();
        sampleClass.SampleMethod();

        // static method çağırılıyor
        SampleClass.SampleMethod2();
    }

    class SampleClass
    {
        int a1;
        int b1;

        static int a2;
        static int b2;

        public void SampleMethod()
        {
            Console.WriteLine(a1); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
            Console.WriteLine(b1); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
        }

        public static void SampleMethod2()
        {
            Console.WriteLine(a2); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
            Console.WriteLine(b2); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
        }
    }
}
-
Hatasız çalışan:

using System;

class Program
{
    public static int a;
    public static string b;

    static void Main()
    {
        Console.WriteLine(a); // Result: 0
        Console.WriteLine(b); // Result: ""
        Console.WriteLine("-"); 

        // instance method çağırılıyor
        SampleClass sampleClass = new SampleClass();
        sampleClass.SampleMethod();

        // static method çağırılıyor
        SampleClass.SampleMethod2();
    }

    class SampleClass
    {
        int a1;
        int b1;

        static int a2;
        static int b2;

        public void SampleMethod()
        {
            Console.WriteLine(a1); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
            Console.WriteLine(b1); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
        }

        public static void SampleMethod2()
        {
            Console.WriteLine(a2); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
            Console.WriteLine(b2); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
        }
    }
}
-
ÖNEMLİ, static metotlar sadece static field’I, property’i çağırabiliyor:


using System;

class Program
{
    static void Main()
    {
    }

    class SampleClass
    {
        int instanceField;
        static int staticField;

        public void SampleMethod()
        {
            Console.WriteLine(instanceField);
            Console.WriteLine(staticField); 
        }

        public static void SampleMethod2()
        {
            Console.WriteLine(instanceField); // Hata! Static metot, instance field'ı çağıramıyor! 
            Console.WriteLine(staticField); // Hata yok. Static method static field'ı çağırdı.
        }
    }
}

-
-
What is the difference between a field variable and a local variable?
Local Variables:

- Local variable’s scope is within the block in which they were defined.
- They are alive as long as the block is executed.
- They can not have static access modifier

Field Variables:

- The life span is more than the local variables.
- The are alive as long as the instance of that class is active.
- They can have only ‘static’ access modifier.
What is the difference between a field variable and a local variable?
Field variables: Variable that are declared as a member of a class. OR Variables declared outside any method/constructor but inside the class block.
Scope: they can live as long as the instance they belong to is active.

Local variables: Variables that are declared within a method or a specific block of statements.
Scope: Live throughout the execution of the block
-
Points to Remember :
1.	Value type stores the value in its memory space, whereas reference type stores the address of the value where it is stored.
2.	Primitive data types and struct are of the 'Value' type. Class objects, string, array, delegates are reference types.
3.	Value type passes byval by default. Reference type passes byref by default.
4.	Value types and reference types stored in Stack and Heap in the memory depends on the scope of the variable.

Reference Data Types : The Reference Data Types will contain a memory address of variable value because the reference types won’t store the variable value directly in memory. The built-in reference types are string, object.
•	String : It represents a sequence of Unicode characters and its type name is System.String. So, string and String are equivalent.
Example:
•	string s1 = "hello"; // creating through string keyword  
•	String s2 = "welcome"; // creating through String class  
•	Object : In C#, all types, predefined and user-defined, reference types and value types, inherit directly or indirectly from Object. So basically it is the base class for all the data types in C#. Before assigning values, it needs type conversion. When a variable of a value type is converted to object, it’s called boxing. When a variable of type object is converted to a value type, it’s called unboxing. Its type name is System.Object.
-
Class’lar referans tiptedirler.
Değişkenler içinde pointer value tutar.
Objeler de içinde pointer tutar. Resimleri incele 
 

        public class Book
        {
           public List<int> theList = new List<int>();
        }

        static void Main(string[] args)
        {
            Book book1 = new Book();
            book1.theList.Add(20);
            book1.theList.Add(21);

            Book book2 = book1;
            book2.theList.Add(51);

            foreach(var item in book2.theList)
            {
                Console.WriteLine(item); //sonuç: 20,21,51
                //Çünkü book2 ile yeni bir obje oluşturmadık. Ram'de aynı noktaya işaret ediyorlar. Dikkat edilirse book2 oluştururken new keyword'ü de kullanılmadı.
            }
            Console.ReadKey();
        }
-
Resimlerde görüldüğü gibi, book1 i instantiate ettik. Sonra book2 yi book1’e eşitledik. Bu durumda iki tane obje oluşturulmuş olmadı. İki tane pointer (book1 ve book2) tek bir objeye işaret ediyor oldu. Yani iki isimden de (book1,book2) tek bir objeye ulaşıyoruz, yani iki değişken ile aslında tek bir RAM lokasyonuna ulaşıyoruz. (dikkat edilirse new keyword’ü falan kullanmadık)
Zaten dikkat edilirse, book2 yi oluştururken bir initialization yapmıyoruz. New keword’ünü kullanmıyoruz. Bu bize yeni bir obje oluşturmadığımız konusunda kolayca ipucu verir.
-
-
-


Variables in C# are broadly classified into two types: Value types and Reference types. In this tutorial we will be discussing about primitive (simple) data types which is a subclass of Value types.
-
-
-
-
-
One to Many ilişki  Entity Framework ile nasıl yapılıyor. Düzgün anlatım:

One-to-Many Relationships
model
relationship
In a one-to-many relationship, each row of data in one table is linked to one or more rows in the second table. It is the most common type of relationship.
•	A one-to-many relationship happens when the primary key of one table becomes foreign keys in another table.
•	The foreign key is defined in the table that represents the many end of the relationship.
Let's say we have Author and Book entities.
public class Author
{
    public int AuthorId { get; set; }
    public string Name { get; set; }
}

public class Book
{
    public int BookId { get; set; }
    public string Title { get; set; }
}
-
-
-
-
-
Configure One-to-Many Relationship
In EF6, most of the times you don't need to configure the one-to-many relationship because one-to-many relationship conventions cover all combinations. You can establish a one-to-many relationship by using any of the following code first conventions.
Code First Conventions
Add Reference Navigation Property
Include a reference navigation property of type Author in the Book entity class.
public class Author
{
    public int AuthorId { get; set; }
    public string Name { get; set; }
}

public class Book
{
    public int BookId { get; set; }
    public string Title { get; set; }
    public Author Author { get; set; }
}
Adding an Author navigation property will create a one-to-many relationship between the Authors and Books tables in the database by adding a foreign key Author_AuthorId to Books table.
Add Collection Navigation Property
You can achieve one-to-many relationship by adding the collection navigation property of Book entity in the Author entity class.
-
public class Author
{
    public int AuthorId { get; set; }
    public string Name { get; set; }
    public virtual ICollection<Book> Books { get; set; }
}

public class Book
{
    public int BookId { get; set; }
    public string Title { get; set; }
}
Try it
Add Navigation Properties in Both Entities
Adding navigation properties at both entities will also result in a one-to-many relationship. For example, Author class contains a collection of Books while Book class contains a navigation property of type Author.
public class Author
{
    public int AuthorId { get; set; }
    public string Name { get; set; }
    public virtual ICollection<Book> Books { get; set; }
}

public class Book
{
    public int BookId { get; set; }
    public string Title { get; set; }
    public Author Author { get; set; }
}
Try it
Fully Defined Relationship
A fully defined relationship at both ends will also create a one-to-many relationship. For example, the Book entity includes foreign key property AuthorId with its reference property Author and Author class contains a collection of Books.
public class Author
{
    public int AuthorId { get; set; }
    public string Name { get; set; }
    public virtual ICollection<Book> Books { get; set; }
}

public class Book
{
    public int BookId { get; set; }
    public string Title { get; set; }
    public int AuthorId { get; set; }
    public Author Author { get; set; }
}
Try it
All these conventions produces the same result in the database.

Using Fluent API
You can also configure relationships using Fluent API to override the default conventions and make it more maintainable.
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
    // configures one-to-many relationship
    modelBuilder.Entity<Book>()
        .HasRequired<Author>(b => b.Author)
        .WithMany(a => a.Books)
        .HasForeignKey<int>(b => b.AuthorId);
}

Bkz:

ICollection<Gig> Gigs 
Bunun adı Navigation Property'dir
-
Linki kesin oku bi: https://blog.staticvoid.co.nz/2012/entity_framework-navigation_property_basics_with_code_first/

Entity Framework - Navigation Property Basics with Code First
What is a navigation property?
Navigation properties are Entity Frameworks way of representing Foreign Key relationships inside the database. Navigation properties allow you to define relationships between entities (rows in your database) in a way that makes sense in an object oriented language. Consider the following database:
 
As you can see a post has an author and that is relationaly linked inside our database. So how would we represent this same structure inside of an application (if we ignore the way this is implemented in a relational database)? It seems sensible that we would model this same structure with something like the following:
public class User
{
	public string Name { get; set; }
}

public class Post
{
	public User Author { get; set; }
}
Which means we can use it in code like this:
String.Format("{0} wrote this post", post.Author.Name);
What Entity Framework navigation proprieties do is to allow us to do just this with our database models. For example the above database structure could be represented as:
public class User
{
	public int Id { get; set; }
	public string Name { get; set; }
}

public class Post
{
	public int Id { get; set; }
	public User Author { get; set; }
}
-
-
How do Navigation Properties work?
When you are using navigation properties in your code you are asking Entity Framework to automatically perform a SQL join between your two tables. For example:
context.Posts.Where(p => p.Author.Name == "Luke");
will be translated into the following SQL*:
SELECT
	 p.Id,
	 p.Author_Id
   FROM  Posts AS p
	 INNER JOIN Users AS u ON p.Author_Id = u.Id
   WHERE u.Name = N'Luke'
As you can see our relationship in c# has been converted into the equivalent SQL join.
How do I load my properties (Why is my navigation property null)?
Navigation properties are not loaded by default, so its important to know how and when you need to load navigation properties. So lets look at some scenarios and see what entity framework will give us. These scenarios are based off the following data:
User
Id	Name
1	Luke
2	Bob
Post
Id	Author_Id
1	1
2	2
Case 1 :
context.Posts.ToArray();
When we make this request we get the following:
{
	"posts": [
		{
			"id": 1,
			"author": null
		},
		{
			"id": 2,
			"author": null
		}
	]
}
As you can see we have retrieved all the posts but haven’t received any of the linked authors.

Case 2:
context.Posts.Where(p => p.Author.Name == "Luke").ToArray();
When we make this request we get the following:
{
	"posts": [
		{
			"id": 1,
			"author": null
		}
	]
}
In this case the where clause successfully interacts with the author to filter by name, however when the results are returned the author is still not linked.
Case 3:
using System.Data.Entity; //this is required for .Include
...
context.Posts.Include(p => p.Author).ToArray();
When we make this request we get the following:
{
	"posts": [
		{
			"id": 1,
			"author": {
				"id":1,
				"name": "Luke"
			}
		},
		{
			"id": 2,
			"author":  {
				"id":2,
				"name": "Bob"
			}
		}
	]
}
As you can see by adding a .Include statement we are able to fetch the linked authors.
-
-
A note on lazy loading
Lazy loading is also an alternative to using the .Include syntax, however I recommend against using it in almost all cases as it makes it very easy to introduce subtle performance issues into your application. in addition using the include syntax makes it much more obvious what queries your code performs so increases readability.

How does Entity Framework detect Navigation Properties
When entity framework examines a class which is attached to the context it finds other complex type properties on the class and assumes that they are a foreign key to that table. Entity framework then creates a foreign key with the name [PropertyName]_[PropertyIdName] for example in the case of the post class the Author is [PropertyName] and in the user table Id is the Id. This means Author_Id is generated as the foreign key name.
The rules around navigation properties what’s acceptable and how they are generated are defined by a set of conventions. I’m not going to go into any more detail on how these work but for more information you can take a look at the following pages:
•	EF Feature CTP5: Pluggable Conventions
•	MSDN - System.Data.Entity.ModelConfiguration.Conventions Namespace
•	Entity Framework Navigation Property generation rules

More than the defaults with the Model Builder
Entity framework provides a mechanism to configure additional information about navigation properties. This additional configuration can be done using the Model Builder. The model builder allows control over how Entity Framework represents the database, one of the features of the model builder allows for control over how foreign keys in the database are translated to Navigation Properties in the Entity Framework Model.
To get access to the model builder you will need to override the OnModelCreating method on your DbContext. You can then use the modelBuilder argument to structure your Entity Framework Model.
public class MyContext : DbContext
{
	protected override void OnModelCreating(DbModelBuilder modelBuilder)
	{
	}   
}
The Model Builder uses a two part fluent expression to define navigation properties within the model. The first part of the expression defines the navigation property on the current entity, the second part of the expression defines the reverse navigation property. Navigation properties properties can be either Optional (ie 0..1 to x), Required (ie 1 to x) or Many (ie ** to x*). So lets take a look at some examples:
Optional relationship
If you have the following classes:
public class Entity1
{
    public int Id { get; set; }
}

public class Entity2
{
    public int Id { get; set; }
    public Entity1 Entity1 { get; set; }
}
Using the following model builder statement
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
    modelBuilder.Entity<Entity2>().HasOptional(e => e.Entity1).WithMany();
}  
Yukarıdaki kodu okuyalım: Entity2 optional olarak Entity1 e sahip (sahip olabilir de olmayabilir de.) (yani aşağıdaki çizimde, okun ucu 0 veya 1 olabilir... sahip olabilir veya olmayabilir)
Sağ kısmı okuyalım (entity1).WithMany();           Entity1 birçok (withmany) entity1’e sahip.

Will create the following relationship
 
Note the two parts of the query the first to define Entity1 navigation property, the first part defines an optional relationship (ie a nullable foreign key) and the second part .WithMany() defines the remote entity’s (Entity1) multiplicity. Using .WithMany() with no argument tells Entity Framework that the relationship does not have a remote navigation property. (koda bak oradan da görürsün... Entity1 class’ında navigation property yok)
Required Relationship
If you have the following classes:
public class Entity1
{
   public int Id { get; set; }
   public List<Entity2> Entity2s { get; set; }
}

public class Entity2
{
   public int Id { get; set; }
   public Entity1 Entity1 { get; set; }
}
Using the following model builder statement
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
	modelBuilder.Entity<Entity2>()
		.HasRequired(e => e.Entity1)
		.WithMany(e => e.Entity2s);
}   
Will create the following relationship
 
Note that in this example we have specified a remote collection for the relationship. This means that you can use the Entity2s property to find all linked entities.
-
-
-
-
-
-
Default Parameters / Optional Parameters / Required Parameters

static void Main()
        {
            MyMethod(3,3);
            Console.ReadKey();
        }
        static void MyMethod(int x, int y = 2)
        {
            Console.WriteLine(x);
            Console.WriteLine(y);       
        }
Yukarıdaki MyMethod metodumuzda iki tane parametre var: x ve y.
Bunlardan:
 int x ==> required parameter
int y = 2  ==> optional parameter (default parameter)
ikinci parametreye opsiyonel deniyor; çünkü bu parametreye değer vermesek de olur.
Not: Metod tanımlanırken, optional parametreler, required parametrelerden sonra yazılmalıdır. 
Yani şu durumda:
static void MyMethod(int x = 2, int y)
gibi bir şey yazarsak hata verecektir.

Bi örnek daha:
using System;

class Program
{
    static void Main()
    {
        MyMethod(1, 2);
        MyMethod(5);
        Console.ReadKey();
    }
    static void MyMethod(int x, int y = 0)
    {
        Console.WriteLine(x + ", " + y);
        //1,2
        //5,0   (x'i 5 verip y yi boş bıraktık. y'nin default value'su da 0 idi. O yüzden 0 döndü)
    }

}


Uzun anlatım:
Merhaba Arkadaşlar,
2004 ve  2005 yıllarında uzun bir süre editörlüğünü yaptığım C#Nedir? topluluğunun düzenlediği C# Akademi eğitimlerinde, yarı zamanlı eğitmen olarak görev yapmıştım. Genellikle C# programlama dilinin basit ve temel konularını, ayrıca Object Oriented özelliklerini aktarmaya çalışırdım. Elbette sınıfımdaki öğrencilerim yanda görüldüğü gibi her zaman pür neşe olmazlardı.
Ancak insan zaman içerisinde profesyonelleşme yolunda ilerledikçe konuları çok daha farklı açılardan ele alması gerektiğini de öğreniyor. Profesyonel bir eğitmenin en iyi yaptığı işlerin başında, en zor konuları çöp adam kullanarak anlatmak gelmektedir. Tabi eğitmenin gerçek hayat tecrübelerini ve ip uçlarını da aktarıyor olması, profesyonelliğinin diğer bir göstergesidir. Böyle bir eğitmenin vereceği önerileri pür dikkat dinlemekte yarar vardır.
Ben eğitmenliği bırakalı uzun bir süre oldu ama makale yazarken veya görsel ders çekerken, konunun anlatımı sırasında yukarıdaki hususlara dikkat etmeye çalışıyorum. Bu anlamda bazen çok basit olarak görünen bir konunun, aslında derinlere inildiğinde dikkat edilmesi gereken noktalar içerdiğini sürekli vurgulamaya çalışan yazıları da hazırlama uğraşısı içerisindeyim. İşte bu yazımızın konusu da; C# 4.0 ile birlikte gelen yeni dil özelliklerden birisi olan Default Parameters ile ilişkili tuzaklar. Öncelikli olarak konuya aşağıdaki hazır kod parçası ile başlayalım.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52	using System;
 
namespace DefaultAndOptionalParametersCase 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            Connection myConn = new Connection(); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks"); 
            Console.WriteLine(myConn.ToString()); 
        } 
    }
 
    class Connection 
    { 
        public string Server { get; set; } 
        public string Database { get; set; } 
        public int Timeout { get; set; } 
        public int PacketSize { get; set; }
 
        #region Constructors
 
        public Connection(string server,string databaseName,int timeout,int packetSize) 
        { 
            Server = server; 
            Database = databaseName; 
            Timeout = timeout; 
            PacketSize = packetSize; 
        } 
        public Connection(string server, string databaseName, int timeout) 
            : this(server, databaseName, timeout, 4096) 
        { 
        } 
        public Connection(string server, string databaseName) 
            : this(server, databaseName, 45, 4096) 
        { 
        } 
        public Connection() 
            : this(".", "master", 45, 4096) 
        { 
        }
 
        #endregion
 
        public override string ToString() 
        { 
            return String.Format("server={0};database={1};timeout={2},packetSize={3}", Server, Database, Timeout, PacketSize); 
        } 
    } 
}
 
Bu kod parçasında dikkat etmemiz gereken nokta Constructor metodlarıdır. Görüldüğü üzere en fazla sayıda parametre alan yapıcı metod, diğer yapıcı metodlar tarafından kullanılmaktadır. Burada this anahtar kelimesini takip eden ifadeler içerisinde gerekli aktarma işlemlerinin yapıldığı görülebilir.

Eski bilgilerimizi bir hatırlayalım. Bilindiği üzere yapıcı metodlarda(Constructors) this yerine base anahtar kelimesini kullanarak, metod parametrelerinin bir üst sınıftaki versiyonuna gönderilmesi de sağlanabilir.
Tabi burada C# 4.0 ile gelen Default Parameters yeteneğinin devreye girmesi ile n sayıda metod yerine tek bir metodun kullanılması söz konusu olabilir. Nitekim ele aldığımız örnek senaryoda yapıcı metodların tek yaptığı, uygun olan versiyona parametre değerlerini taşımaktır. Dikkat edileceği üzere sadece tek bir yapıcı metod içerisinde özellik değer atama işlemleri yapılmaktadır. Diğer yapıcı metodlar sadece parametre değerlerini taşımak için kullanılmaktadır. Aşağıdaki şekilde bu durum ifade edilmeye çalışılmaktadır.

Aslında Constructor kullanımının buradaki amacı, Connection tipine ait nesne örneklerinin oluşturulması sırasında alternatif versiyonları varsayılan parametre değerlerine göre sunabilmektir. Bu amaç düşünüldüğünde Default Parameters yeteneği önemli bir avantaj sağlamaktadır. Gelin kodumuzu Default Parameters kabiliyetini kullanarak aşağıdaki hale getirelim.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38	using System;
 
namespace DefaultAndOptionalParametersCase 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            Connection myConn = new Connection(); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks"); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks",20,512); 
            Console.WriteLine(myConn.ToString()); 
        } 
    }
 
    class Connection 
    { 
        public string Server { get; set; } 
        public string Database { get; set; } 
        public int Timeout { get; set; } 
        public int PacketSize { get; set; }
 
        public Connection(string server=".", string databaseName="master", int timeout=45, int packetSize=4096) 
        { 
            Server = server; 
            Database = databaseName; 
            Timeout = timeout; 
            PacketSize = packetSize; 
        }
 
        public override string ToString() 
        { 
            return String.Format("server={0};database={1};timeout={2},packetSize={3}", Server, Database, Timeout, PacketSize); 
        } 
    }    
}
-
Bu kod parçasında dikkat etmemiz gereken nokta Constructor metodlarıdır. Görüldüğü üzere en fazla sayıda parametre alan yapıcı metod, diğer yapıcı metodlar tarafından kullanılmaktadır. Burada this anahtar kelimesini takip eden ifadeler içerisinde gerekli aktarma işlemlerinin yapıldığı görülebilir.

Eski bilgilerimizi bir hatırlayalım. Bilindiği üzere yapıcı metodlarda(Constructors) this yerine base anahtar kelimesini kullanarak, metod parametrelerinin bir üst sınıftaki versiyonuna gönderilmesi de sağlanabilir.
Tabi burada C# 4.0 ile gelen Default Parameters yeteneğinin devreye girmesi ile n sayıda metod yerine tek bir metodun kullanılması söz konusu olabilir. Nitekim ele aldığımız örnek senaryoda yapıcı metodların tek yaptığı, uygun olan versiyona parametre değerlerini taşımaktır. Dikkat edileceği üzere sadece tek bir yapıcı metod içerisinde özellik değer atama işlemleri yapılmaktadır. Diğer yapıcı metodlar sadece parametre değerlerini taşımak için kullanılmaktadır. Aşağıdaki şekilde bu durum ifade edilmeye çalışılmaktadır.

Aslında Constructor kullanımının buradaki amacı, Connection tipine ait nesne örneklerinin oluşturulması sırasında alternatif versiyonları varsayılan parametre değerlerine göre sunabilmektir. Bu amaç düşünüldüğünde Default Parameters yeteneği önemli bir avantaj sağlamaktadır. Gelin kodumuzu Default Parameters kabiliyetini kullanarak aşağıdaki hale getirelim.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38	using System;
 
namespace DefaultAndOptionalParametersCase 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            Connection myConn = new Connection(); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks"); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks",20,512); 
            Console.WriteLine(myConn.ToString()); 
        } 
    }
 
    class Connection 
    { 
        public string Server { get; set; } 
        public string Database { get; set; } 
        public int Timeout { get; set; } 
        public int PacketSize { get; set; }
 
        public Connection(string server=".", string databaseName="master", int timeout=45, int packetSize=4096) 
        { 
            Server = server; 
            Database = databaseName; 
            Timeout = timeout; 
            PacketSize = packetSize; 
        }
 
        public override string ToString() 
        { 
            return String.Format("server={0};database={1};timeout={2},packetSize={3}", Server, Database, Timeout, PacketSize); 
        } 
    }    
}

Dikkat edileceği üzere tek bir yapıcı metod kullanımı söz konusudur. Bir başka deyişle kod kısalmıştır. Yapıcı metodun parametrelerinde verilen varsayılan değerler sayesinde, Connection tipine ait nesne örneklerinin oluşturulması şekillendirilmiştir. Örneğin, çalışma zamanı çıktısı aşağıdaki gibi olacaktır.
 
Aslında işin içerisine Named Parameters kullanımını da katmamız yerinde olacaktır. Neden? Main metodu içerisindeki aşağıdaki kod satırını göz önüne alalım.
1	myConn = new Connection("localhost", "AdventureWorks",20,512);
Geliştirici kodu yazarken parametrelerin ne anlama geldiğini, isimlerinden veya varsa eğer XML Comment’ lerden çıkartabilir. Ancak tamamlanmış kodun okunması sırasında 20 ve 512 rakamlarının en anlama geldiği kolayca anlaşılamayabilir. İşte bu noktada parametreleri isimlendirerek kullanmak aşağıdaki okunurluğu sağlayacaktır.
1	myConn = new Connection(server:"localhost", databaseName:"AdventureWorks", timeout:20, packetSize:512);

Parametre Sayısının Arttırılması
Gelelim default parameters kullanımında dikkatli olmamız gereken hususlara. İlk olarak parametre sayısının arttırılması durumunu göz önüne alacağız. Ancak senaryonun oluşumunda Named Parameters kullanmadığımızı varsayıyoruz. Bu amaçla Connection tipine ait yapıcı metodu aşağıdaki gibi değiştirdiğimizi düşünelim.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40	using System;
 
namespace DefaultAndOptionalParametersCase 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            Connection myConn = new Connection(); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks"); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks",20,512);            
            Console.WriteLine(myConn.ToString()); 
        } 
    }
 
    class Connection 
    { 
        public string Server { get; set; } 
        public string Database { get; set; } 
        public int Timeout { get; set; } 
        public int PacketSize { get; set; } 
        public int ProcessId { get; set; }
 
        public Connection(string server=".", string databaseName="master", int timeout=45,int processId=10, int packetSize=4096) 
        { 
            Server = server; 
            Database = databaseName; 
            Timeout = timeout; 
            PacketSize = packetSize; 
            ProcessId = processId; 
        }
 
        public override string ToString() 
        { 
            return String.Format("server={0};database={1};timeout={2},packetSize={3},PId:{4}", Server, Database, Timeout, PacketSize,ProcessId); 
        } 
    }    
}

Kodda sadece processId isimli bir metod parametresi eklendiğini görmekteyiz. Bu aslında sonradan yapılan bir değişiklik olarak düşünülmelidir. Bir başka deyişle geliştirdiğimiz projelerde sonradan varsayılan parametre eklenmesi söz konusu olabilir. Buna göre çalışma zamanı çıktısı aşağıdaki gibi olacaktır.
 
Dikkatinizi çeken bir nokta var mı?
Son çıktıya göre ProcessId değerinin 512 olduğu görülmektedir. Oysaki 512 değeri daha önceki kodlamaya göre PacketSize özelliği için atanan bir değerdir. Bir başka deyişle yanlış bir değer ataması söz konusudur. İşin kötü yanı bu senaryoda derleme zamanında bir hata veya uyarı mesajı alınmamaktadır. Dolayısıyla kodun hatalı çalışması olasıdır.
Öyleyse varsayılan parametre kullanımı gibi senaryolarda, metodlara yeni parametrelerin eklenmesi söz konusu ise, bu parametrelerin en sona eklenmesi daha doğru olacaktır. Named Parameters aslında köklü çözüm olsa da, ilgili tip metodlarını kullanan diğer geliştiricilerin bu kullanımı göz ardı etmesi ihtimali vardır.
Yani metod yapısını aşağıdaki gibi değiştirmemiz doğru bir çalışma zamanı çıktısı elde etmemizi sağlayacaktır.
1	public Connection(string server = ".", string databaseName = "master", int timeout = 45, int packetSize = 4096,int processId = 10)
,sonucu çalışma zamanı çıktısı aşağıdaki gibidir.

Türetme(Inheritance) ve Varsayılan Parametreler
Gelelim diğer bir vakaya. Bu vaka çok daha kritik ve önemlidir. Nitekim işin içerisinde türetme(Inheritance) kavramı vardır. Konuyu netleştirmek için aşağıdaki sınıf şemasına sahip örnek kod parçasını göz önüne alarak ilerleyelim.
 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43	using System;
 
namespace DefaultAndOptionalParametersCase 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            MyCommand myCmd = new MyCommand(); 
            ICommand iCmd = myCmd; 
            Command cmd = myCmd;
 
            Console.WriteLine(myCmd.PrepareSelectTop("Product")); 
            Console.WriteLine(iCmd.PrepareSelectTop("Product")); 
            Console.WriteLine(cmd.PrepareSelectTop("Product")); 
        } 
    }
 
    interface ICommand 
    { 
        string PrepareSelectTop(string tableName, int topNumber = 3); 
    } 
    class Command 
       : ICommand 
    { 
        #region ICommand Members
 
        public virtual string PrepareSelectTop(string tableName, int topNumber = 10) 
        { 
            return String.Format("Select top {0} from {1}",topNumber,tableName);            
        }
 
        #endregion 
    } 
    class MyCommand 
       : Command 
    { 
        public override string PrepareSelectTop(string tableName, int topNumber = 50) 
        { 
            return String.Format("Select top {0} from {1}",topNumber,tableName); 
        } 
    }   
}

Aslında bu senaryo Temeller Kolay Unutulur (C# – Implicitly Name Hiding Sorunsalı) başlıklı yazımızdan size tanıdık gelecektir.
Sınıf şemasından da görüleceği üzere ICommand arayüzünü(Interface) uygulayan Command isimli bir tip ve bundan türeyen MyCommand sınıfı söz konusudur. MyCommand sınıfı, Command tipinde virtual olarak tanımlanmış ve aslında ICommand arayüzü tarafından zorunlu hale getirilmiş PrepareSelectTop metodunu ezmektedir(Overriding).
Kritik olan yer Main metodu içerisindeki değişken atamalardır. Dikkat edileceği üzere ICommand ve Command tipinden olan değişkenlere aynı MyCommand nesne örneği atanmıştır. Eğer çok biçimlilik ilkesini biliyorsak, iCmd ve cmd isimli nesne örnekleri üzerinden yapılan PrepareSelectTop çağrılarının aslında MyCommand tipindeki metod içeriğine doğru yapılması gerektiğini biliriz. Buna göre de tüm Select sorgularında Top 50 değerinin kullanılıyor olması gerekmektedir. Oysaki çalışma zamanı çıktısı aşağıdaki gibi olacaktır.
 
Görüldüğü gibi son iki çağrıda topNumber için Default Parameter değerleri tanımlandıkları yerdekiler olmuştur. ICommand için 3 iken Command için 10 olarak ele alınmıştır. Tam bu noktada “Amanın! Yoksa ICommand ve Command tipleri çok biçimlilik göstermiyorlarmış!” diye haykırabilirsiniz. Ama dereyi görmeden paçaları sıvamamak lazım. Nitekim uygulamayı debug modda değerlendirdiğimizde, aslında tüm PrepareSelectTop çağrılarının, MyCommand içinden yapıldığı görülecektir.
Sorun tamamen Default Parameter’ lar ile alakalıdır. Söz gelimi ICommand üzerinden yapılan çağrı sonucu topNumber değeri aşağıdaki gibi olacaktır.
 
veya Command tipi için şu şekilde olacaktır.
 
Böyle bir vakanın oluşmasının sebebi Defaul Parameter’ ların çalışma zamanı(Runtime) yerine derleme zamanında(Compile Time) çözümleniyor olmalarıdır. Bu durum IL(Intermediate Language) kodunda açık bir şekilde görülebilir ve ispatlanabilir.


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38	.method private hidebysig static void  Main(string[] args) cil managed 
{ 
  .entrypoint 
  // Code size       68 (0x44) 
  .maxstack  3 
  .locals init ([0] class DefaultAndOptionalParametersCase.MyCommand myCmd, 
           [1] class DefaultAndOptionalParametersCase.ICommand iCmd, 
           [2] class DefaultAndOptionalParametersCase.Command cmd) 
  IL_0000:  nop 
  IL_0001:  newobj     instance void DefaultAndOptionalParametersCase.MyCommand::.ctor() 
  IL_0006:  stloc.0 
  IL_0007:  ldloc.0 
  IL_0008:  stloc.1 
  IL_0009:  ldloc.0 
  IL_000a:  stloc.2 
  IL_000b:  ldloc.0 
  IL_000c:  ldstr      "Product" 
  IL_0011:  ldc.i4.s   50 
  IL_0013:  callvirt   instance string DefaultAndOptionalParametersCase.Command::PrepareSelectTop(string, 
                                                                                                  int32) 
  IL_0018:  call       void [mscorlib]System.Console::WriteLine(string) 
  IL_001d:  nop 
  IL_001e:  ldloc.1 
  IL_001f:  ldstr      "Product" 
  IL_0024:  ldc.i4.3 
  IL_0025:  callvirt   instance string DefaultAndOptionalParametersCase.ICommand::PrepareSelectTop(string, 
                                                                                                   int32) 
  IL_002a:  call       void [mscorlib]System.Console::WriteLine(string) 
  IL_002f:  nop 
  IL_0030:  ldloc.2 
  IL_0031:  ldstr      "Product" 
  IL_0036:  ldc.i4.s   10 
  IL_0038:  callvirt   instance string DefaultAndOptionalParametersCase.Command::PrepareSelectTop(string, 
                                                                                                  int32) 
  IL_003d:  call       void [mscorlib]System.Console::WriteLine(string) 
  IL_0042:  nop 
  IL_0043:  ret 
} // end of method Program::Main
IL kodunda yer alan ldc komutlaraına bakıldığında Defualt Parameter değerlerinin, tip tanımlamaları sırasında yazıldığı gibi set edildiği açık bir şekilde görülebilmektedir.
Kolayca gözden kaçabilecek bir durum olduğu için tehlikeli bir vaka olduğunu ifade edebiliriz. Dolayısıyla en azından bu senaryoya göre Default Parameter kullanımını aslında Interface seviyesinde bırakmak çözüm olarak düşünülebilir.
Böylece geldik bir yazımızın daha sonuna. Tekrardan görüşünceye dek hepinize mutlu günler dilerim.
-
-
-
-
One of the major annoyances when starting with C# was the lack of default arguments. Generating two or three overloads manually is ok, but looking at the 28 overloads for a MessageBox makes my head tingle (in an ugly way).
Now I can't hack the C# compiler to magically allow this. I can, however, provide a code generator that creates a set of overloads from a declaration containing default arguments.
Using the Tool
Enter your declaration in the first edit box. You can add default arguments like you would in C++, and the generated code appears immediately in the text field below. Click "Copy" to copy the generated code to the clipboard. Example:
Hide   Copy Code
void Add(string name = "(none)", int age = 22)
The above generates the following implementations:
Hide   Copy Code
// $overload: void Add(string name = "(none)", int age = 22){
 // do your worst! - implement the actual method here
}

#region overloads for: Add

public void Add(string name)
{
 Add(name, 22);
}

public void Add()
{
 Add("(none)", 22);
}

#endregion // overloads
public void Add(string name, int age)
The first overload is the method you actually implement. The other overloads have a reduced argument list and call the first.
The first line is for integration with Linkify (see below).
It Gets Better (Optionally)
C++ default arguments allow to omit parameters at the end of the argument list. However, in the above example where argument types are distinct, you may want to omit the name but still specify the age. I've added a custom "keyword", optional, that can drop arguments from the middle of the argument list:
Hide   Copy Code
void Add(optional string name = "(none)", int age = 22)
This generates the following signatures:
Hide   Copy Code
public void Add(string name, int age) { } // the one to implement
public void Add(string name)
public void Add()
public void Add(int age)
The last one omits the string name parameter.
It is your responsibility to make sure the resulting overloads aren't ambiguous. If you don't feel up to the job, the compiler will catch you!

Integration with Visual Studio - Linkify
I've updated my Linkify article that allows to visit URLs and run external tools from source code comments. Also, DefaultOverloader now generates a declaration line that Linkify can understand:
Hide   Copy Code
// $overload: void Add(string name = "(none)", int age = 22)
void Add(string name, int age)
Note: You need to set the path to the DefaultOverloader executable first in the Linkify configuration dialog. See that article for details.
Place the caret on the "$overload" and click "Linkify". Default Overloader opens with your declaration already in place.
You can also copy the two declaration lines separately by clicking "copy head", and the overloads region by clicking "copy body". This allows to preserve the body of the main functions implementation. Auto-Paste makes that even easier.
Auto-Paste
Auto-Paste makes that even easier. It works without Linkify installed (but then, the first step is more complicated). To modify an existing block with overloads:
1.	Place caret on "$overload", and start Linkify
» DefaultOverloader will open, with your declaration ready to be edited.
2.	After making your modifications, click "Auto-Paste"
» DefaultOverloader minimizes, and displays "Paste Head" as title
3.	Select the two head lines (comment and main function header), and paste
» The declarations are replaced with the new contents
» DefaultOverloader (still minimized) displays "Paste Body" as title
4.	Collapse the #region Overloads for..., select the entire line, and paste
» New overloads replace the previous ones
» DefaultOverloader closes
Restore the DefaultOverloader from minimized state to cancel the paste sequence. There is a small delay between the first paste and the second data arriving on clipboard, so don't paste too fast in succession!

Limitations
The parser is fairly simple. So you might be able to create declarations that aren't interpreted correctly. One thing is a function name with multiple template parameters: don't put spaces in the template list, otherwise, I get the function name wrong!
The parser doesn't validate your declaration - that's left to your compiler.
This is unfortunately no full replacement for default parameters. One thing where some language and IDE support would be helpful is Intellisense - you still get listed all overloads separately. Also, when you modify the declaration, you have to use the Overloader again.
The Debate
There is a reason there are no default parameters in MSIL or the C# language - to learn about the reasons, read Eric Gunnersons response [^] or start at Google [^].
In my opinion, Eric has a valid argument why default arguments aren't in MSIL - but it doesn't hold up for the C# language itself. After all, C# could do what I do.:)
Points of Interest
Permutation of Bools
For implementing the optional keyword, I needed to permute over all variations of having them in. With N parameters tagged optional, I need to generate all possible combinations of N bool values. While some approaches can be found on the 'net, none was plug-and-play-enough for me. Thinking how to implement it myself, a "background thread" associated the idea of a bool array with a bit array - bools are bits! This allows a very simple solution: just count from 0 to 2<sup>N</sup>-1, and treat each bit as a flag.

Parsing the Argument List
The sources contain a (still somewhat experimental) Tokenizer that respects single- and double-quoted strings as well as round, square and curly brackets. This is required to parse declarations like the following correctly:
Hide   Copy Code
SendMessage(string X = "Hello, World", int[,] targetCoords) 
It's barely tested and needs some extensions to be reusable, but it works well enough for the application given.
Thank You
A big thank you to everyone who helped me at the C# forums here - especially Judah Himango who often went an extra mile.
I am currently working on my first "real world" C# project (complete with time pressure, feature creep, big plans, and get-it-done-while-everybody-is-out-to-distract you), and you have been really helpful in getting my stubborn head through this wall - or at least into it.

Domain / Application Domain	 (GITHUB)  (test)
Domain nedir, application domain nedir
A domain is the targeted subject area of a computer program. It is a term used in software engineering. Formally it represents the target subject of a specific programming project, whether narrowly or broadly defined.[1] For example, a particular programming project might have had as a goal the creation of a program for a particular hospital, and that hospital would be the domain. Or the project could be expanded in scope to include all hospitals as their domain. In a computer programming design, you define a domain by delineating a set of common requirements, terminology, and functionality for any software program constructed to solve a problem in the area of computer programming, known as domain engineering. The word domain is also taken as a synonym of application domain.
Domain in the realm of software engineering commonly refers to the subject area on which the application is intended to apply. In other words, during application development, the domain is the "sphere of knowledge and activity around which the application logic revolves." —Andrew Powell-Morse
Domain: A sphere of knowledge, influence, or activity. The subject area to which the user applies a program is the domain of the software. —Eric Evans

Eager Loading

(bu cümle ne diyor) If you use lazy loading, EntityFramework will take care of loading the navigation property for you, so you won't get an exception.
Lazy loading will produce several SQL calls while Eager loading may load data with one "more heavy" call (with joins/subqueries).
Mantık şu şekilde kurumalı. Lazyloading = tembel, o yüzden en az ne kadar data getirebiliyorsa, o kadar getiriyor. Yani her ilişkili datayı yüklenmiyor sırtına. 
Eager ise adı üstünde, eager olduğu için tüm datayı getiriyor, eager bir kedi gibi düşünebiliriz, yerinde durmayan. Lazy kedi ise en ufak işgücünü ortaya koyar, kendini yormaz.
For example, If there is a high ping between your web and sql servers you would go with Eager loading instead of loading related items 1-by-1 with lazy Loading.

 Lazy loading will produce several SQL calls while Eager loading may load data with one "more heavy" call (with joins/subqueries).
For example, If there is a high ping between your web and sql servers you would go with Eager loading instead of loading related items 1-by-1 with lazy Loading.

You can't perform eager loading with the Find method, so the Where
and Single methods are used instead to select the instructor.

Eager Loading: Eager Loading helps you to load all your needed entities at once. i.e. related objects (child objects) are loaded automatically with its parent object.
Use Eager Loading when the relations are not too much. Thus, Eager Loading is a good practice to reduce further queries on the Server.
1.	Use Eager Loading when you are sure that you will be using related entities with the main entity everywhere.

Lazy Loading: In case of lazy loading, related objects (child objects) are not loaded automatically with its parent object until they are requested. By default LINQ supports lazy loading.
Use Lazy Loading when you are using one-to-many collections.
1.	Use Lazy Loading when you are sure that you are not using related entities instantly.
NOTE: Entity Framework supports three ways to load related data – eager loading, lazy loading and explicit loading.

Eager loading is the opposite of Lazy loading but Explicit loading is similar to lazy loading, except that: you explicitly retrieve the related data in code; it doesn't happen automatically when you access a navigation property. You load related data manually by getting the object state manager entry for an entity and calling the Collection.Load method for collections or the Reference.Load method for properties that hold a single entity.
From techblog:
Eager Loading :
Eager loading is the opposite of Lazy loading which is : The process of loading a specific set of related objects along with the objects that were explicitly requested in the query.
Explicit Loading :
Explicit loading is defined as : when objects are returned by a query, related objects are not loaded at the same time. By default, they are not loaded until explicitly requested using the Load method on a navigation property.
And:
If I Use lazy loading and I call for example dpc_gestion.dpc_participant, does the navigation properties loads?or I will get an exception?
You don't get any exception and the navigation properties should loads.
Is there a case when eager loading or explicit loading were better than lazy loading in performance and responsiveness?

Eager loading is typically more efficient when you need the related data for all retrieved rows of the primary table. And also when relations are not too much, eager loading will be good practice to reduce further queries on server. But when you know that you will not need a property instantly then lazy loading maybe a good choice. And also eager loading is a good choice in a situation where your db context would be disposed and lazy loading could not take place anymore. For example consider the following:
public List<Auction> GetAuctions()
{
    using (DataContext db = new DataContext())
    {
        return db.Auctions.ToList();
    }
}
After calling this method, You cannot load the related entity lazily because the db is disposed and so the Eager Loading would be a better choice here.
One more thing to note is: Lazy loading will produce several SQL request while Eager loading load data with one request. Eager loading is also a good choice to solve the n+1 selects issue in ORMs. Have a look at this post: What is the n+1 selects issue?
-



notes on eager loading - II




