




WWW     	(GITHUB)  (empty) 
[www nedir, world wide web nedir]
Renkler: yazı örnek yazı yazı örnek yazı yazı örnek yazı 
-
-
World Wide Web, Dünya Çapında Ağ (kısaca WWW veya Web), İnternet üzerinde yayınlanan birbirleriyle bağlantılı hiper-metin dokümanlarından oluşan bir bilgi sistemidir. Bu dokümanların her birine Web sayfası adı verilir ve Web sayfalarına İnternet kullanıcısının bilgisayarında çalışan Web tarayıcısı adı verilen bilgisayar programları aracılığıyla erişilir. Web sayfalarında metin, imaj, video ve diğer multimedya ögeleri bulunabilir ve diğer bağlantı ya da link adı verilen hiper-bağlantılar ile başka Web sayfalarına geçiş yapılabilir.

İnternet ve Web terimleri aynı olguyu tanımlamaz. Zira Web sadece İnternet üzerinde çalışan bir servistir. Web kavramı, CERN'de bir bilgisayar programcısı olan Tim Berners-Lee'nin HTML adlı metin işaretleme dilini geliştirmesiyle oluşmuştur. Bugün de kendisinin başkanı olduğu W3C (World Wide Web Consortium) tarafından standartları belirlenmektedir.

Yapısı
Web’in temeli İnternet'tir. Web İnternet üzerinde kurulmuştur ve İnternet'in sunduğu mekanizmalardan çoğunun kullanılmasını sağlar. İnternet'in fiziksel görünüşleri –bilgisayarlar, ağlar ve servisler– Dünya üzerindeki diğer binlerce bilgisayara bağlanmamıza izin verir. Web, İnternet'in en tepesindeki soyutlanmış genel servisler kümesidir. World Wide Web (W3), insanların fikir ve projelerinin paylaşılmasını sağlayan bir bilgi ve kültür havuzudur. İstemci-sunucu uygulamaları ile yapılan birçok organizasyon üzerinde Web tarayıcıları istemci olarak çalışabilirler. Web yürütümü standart İstemci-sunucu modelini izler. Aşağıdaki şekilde gösterildiği gibi "Web tarayıcısı" adı verilen programı çalıştıran bir istemci bilgisayar ile Web sunucu yazılımı çalıştıran bir sunucu bilgisayar arasındaki etkileşime "istemci-sunucu" etkileşimi adı verilir. İstemci bilgisayar sunucudan HTTP'yi (Hypertext Transfer Protocol) ve İnternet mesaj standardı TCP/IP'yi kullanarak bir doküman ister ve sunucu istemcinin göstereceği dokümanı geri döndürür.-
-
WebPack             (GITHUB)  (test) 
Webpack nedir
Webpack is an open-source JavaScript module bundler. It is made primarily for JavaScript, but it can transform front-end assets such as HTML, CSS, and images if the corresponding loaders are included. webpack takes modules with dependencies and generates static assets representing those modules.
Webpack takes the dependencies and generates a dependency graph allowing web developers to use a modular approach for their web application development purposes. It can be used from the command line, or can be configured using a config file which is named webpack.config.js. This file is used to define rules, plugins, etc., for a project. (webpack is highly extensible via rules which allow developers to write custom tasks that they want to perform when bundling files together.)
Node.js is required for using webpack.
webpack provides code on demand using the moniker code splitting. The Technical Committee 39 for ECMAScript is working on standardization of a function that loads additional code: "proposal-dynamic-import".
-
-
-
Webpack is a tool that has got a lot of attention in the last few years, and it is now seen used in almost every project. Learn about it.

Using webpack allows you to use import or require statements in your JavaScript code to not just include other JavaScript, but any kind of file, for example CSS.
Webpack aims to handle all our dependencies, not just JavaScript, and loaders are one way to do that.
For example, in your code you can use:
import 'style.css'
-
What is webpack?
Webpack is a tool that lets you compile JavaScript modules, also known as module bundler.
Given a large number of files, it generates a single file (or a few files) that run your app.
It can perform many operations:
•	helps you bundle your resources.
•	watches for changes and re-runs the tasks.
•	can run Babel transpilation to ES5, allowing you to use the latest JavaScript features without worrying about browser support.
•	can transpile CoffeeScript to JavaScript
•	can convert inline images to data URIs.
•	allows you to use require() for CSS files.
•	can run a development webserver.
•	can handle hot module replacement.
•	can split the output files into multiple files, to avoid having a huge js file to load in the first page hit.
•	can perform tree shaking.
Webpack is not limited to be use on the frontend, it’s also useful in backend Node.js development as well.
Predecessors of webpack, and still widely used tools, include:
•	Grunt
•	Broccoli
•	Gulp
There are lots of similarities in what those and Webpack can do, but the main difference is that those are known as task runners, while webpack was born as a module bundler.
It’s a more focused tool: you specify an entry point to your app (it could even be an HTML file with script tags) and webpack analyzes the files and bundles all you need to run the app in a single JavaScript output file (or in more files if you use code splitting).
Installing webpack
Webpack can be installed globally or locally for each project.
Global install
Here’s how to install it globally with Yarn:
yarn global add webpack webpack-cli
with npm:
npm i -g webpack webpack-cli
once this is done, you should be able to run
webpack-cli
 
Local install
Webpack can be installed locally as well. It’s the recommended setup, because webpack can be updated per-project, and you have less resistance to using the latest features just for a small project rather than updating all the projects you have that use webpack.
With Yarn:
yarn add webpack webpack-cli -D
with npm:
npm i webpack webpack-cli --save-dev
Once this is done, add this to your package.json file:
{
  //...
  "scripts": {
    "build": "webpack"
  }
}
once this is done, you can run webpack by typing
yarn build
in the project root.
Webpack configuration
By default, webpack (starting from version 4) does not require any config if you respect these conventions:
•	the entry point of your app is ./src/index.js
•	the output is put in ./dist/main.js.
•	Webpack works in production mode
You can customize every little bit of webpack of course, when you need. The webpack configuration is stored in the webpack.config.js file, in the project root folder.
The entry point
By default the entry point is ./src/index.js This simple example uses the ./index.js file as a starting point:
module.exports = {
  /*...*/
  entry: './index.js'
  /*...*/
}
The output
By default the output is generated in ./dist/main.js. This example puts the output bundle into app.js:
module.exports = {
  /*...*/
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'app.js'
  }
  /*...*/
}
Loaders
Using webpack allows you to use import or require statements in your JavaScript code to not just include other JavaScript, but any kind of file, for example CSS.
Webpack aims to handle all our dependencies, not just JavaScript, and loaders are one way to do that.
For example, in your code you can use:
import 'style.css'
by using this loader configuration:
module.exports = {
  /*...*/
  module: {
    rules: [
      { test: /\.css$/, use: 'css-loader' },
    ]
  }
  /*...*/
}
The regular expression targets any CSS file.
A loader can have options:
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: 'css-loader',
            options: {
              modules: true
            }
          }
        ]
      }
    ]
  }
  /*...*/
}
You can require multiple loaders for each rule:
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.css$/,
        use:
          [
            'style-loader',
            'css-loader',
          ]
      }
    ]
  }
  /*...*/
}
In this example, css-loader interprets the import 'style.css' directive in the CSS. style-loader is then responsible for injecting that CSS in the DOM, using a <style> tag.
The order matters, and it’s reversed (the last is executed first).
What kind of loaders are there? Many! You can find the full list here.
A commonly used loader is Babel, which is used to transpile modern JavaScript to ES5 code:
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /(node_modules|bower_components)/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      }
    ]
  }
  /*...*/
}
This example makes Babel preprocess all our React/JSX files:
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: 'babel-loader'
      }
    ]
  },
  resolve: {
    extensions: [
      '.js',
      '.jsx'
    ]
  }
  /*...*/
}
See the babel-loader options here.
Plugins
Plugins are like loaders, but on steroids. They can do things that loaders can’t do, and they are the main building block of webpack.
Take this example:
module.exports = {
  /*...*/
  plugins: [
    new HTMLWebpackPlugin()
  ]
  /*...*/
}
The HTMLWebpackPlugin plugin has the job of automatically creating an HTML file, adding the output JS bundle path, so the JavaScript is ready to be served.
There are lots of plugins available.
One useful plugin, CleanWebpackPlugin, can be used to clear the dist/ folder before creating any output, so you don’t leave files around when you change the name of the output file:
module.exports = {
  /*...*/
  plugins: [
    new CleanWebpackPlugin(['dist']),
  ]
  /*...*/
}
The webpack mode
This mode (introduced in webpack 4) sets the environment on which webpack works. It can be set to development or production (defaults to production, so you only set it when moving to development)
module.exports = {
  entry: './index.js',
  mode: 'development',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'app.js'
  }
}
Development mode:
•	builds very fast
•	is less optimized than production
•	does not remove comments
•	provides more detailed error messages and suggestions
•	provides a better debugging experience
Production mode is slower to build, since it needs to generate a more optimized bundle. The resulting JavaScript file is smaller in size, as it removes many things that are not needed in production.
I made a sample app that just prints a console.log statement.
Here’s the production bundle:
 
Here’s the development bundle:
 
Running webpack
Webpack can be run from the command line manually if installed globally, but generally you write a script inside the package.json file, which is then run using npm or yarn.
For example this package.json scripts definition we used before:
"scripts": {
  "build": "webpack"
}
allows us to run webpack by running
npm run build
or
yarn run build
or
yarn build
Watching changes
Webpack can automatically rebuild the bundle when a change in your app happens, and keep listening for the next change.
Just add this script:
"scripts": {
  "watch": "webpack --watch"
}
and run
npm run watch
or
yarn run watch
or
yarn watch
One nice feature of the watch mode is that the bundle is only changed if the build has no errors. If there are errors, watch will keep listening for changes, and try to rebuild the bundle, but the current, working bundle is not affected by those problematic builds.
Handling images
Webpack allows us to use images in a very convenient way, using the file-loader loader.
This simple configuration:
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: [
          'file-loader'
        ]
      }
    ]
  }
  /*...*/
}
Allows you to import images in your JavaScript:
import Icon from './icon.png'

const img = new Image()
img.src = Icon
element.appendChild(img)
(img is an HTMLImageElement. Check the Image docs)
file-loader can handle other asset types as well, like fonts, CSV files, xml, and more.
Another nice tool to work with images is the url-loader loader.
This example loads any PNG file smaller than 8KB as a data URL.
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.png$/,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 8192
            }
          }
        ]
      }
    ]
  }
  /*...*/
}
Process your SASS code and transform it to CSS
Using sass-loader, css-loader and style-loader:
module.exports = {
  /*...*/
  module: {
    rules: [
      {
        test: /\.scss$/,
        use: [
          'style-loader',
          'css-loader',
          'sass-loader'
        ]
      }
    ]
  }
  /*...*/
}
Generate Source Maps
Since webpack bundles the code, Source Maps are mandatory to get a reference to the original file that raised an error, for example.
You tell webpack to generate source maps using the devtool property of the configuration:
module.exports = {
  /*...*/
  devtool: 'inline-source-map',
  /*...*/
}
devtool has many possible values, the most used probably are:
•	none: adds no source maps
•	source-map: ideal for production, provides a separate source map that can be minimized, and adds a reference into the bundle, so development tools know that the source map is available. Of course you should configure the server to avoid shipping this, and just use it for debugging purposes
•	inline-source-map: ideal for development, inlines the source map as a Data URL
-
-
-
SonarQube (formerly Sonar)[2] is an open-source platform developed by SonarSource for continuous inspection of code quality to perform automatic reviews with static analysis of code to detect bugs, code smells, and security vulnerabilities on 20+ programming languages. SonarQube offers reports on duplicated code, coding standards, unit tests, code coverage, code complexity, comments, bugs, and security vulnerabilities.[3][4]
SonarQube can record metrics history and provides evolution graphs. SonarQube provides fully automated analysis and integration with Maven, Ant, Gradle, MSBuild and continuous integration tools (Atlassian Bamboo, Jenkins, Hudson, etc.).
 
Bir önceki yazımda ( Yazılım Ekiplerinde Kod Kalitesi ve Kalitede Sürekliliğin Sağlanması ) Continuous Code Quality kavramından, DevOps kültüründeki, ve bir CI pipleline’ındaki yerinden bahsetmiştim. Özellikle büyük veya büyüme kapasitesi olan ekiplerde her commit’in ana branch’e merge edilmeden önce mutlaka code-review işlemine tabi tutulması gerektiğini ve bu işlemden önce bir statik kod analiz aracı kullanımının, kod kalitesi, hatasızlık ve zaman tasarrufu açısından faydalı olacağından bahsetmiştim. Bu yazımda SonarQube statik kod analiz aracından bahsedeceğim.
 
SonarQube (eski ismiyle Sonar), Sonarsource firmasının iki ana ürününden birisidir. Diğer ürün SonarLint’de yine bir code quality tool’udur, ancak SonarQube’den farklı olarak yazılımın geliştirme aşamasında, yani henüz kodumuzu commit’lemeden önce bizi uyarır. Bir çok popüler IDE için desteği mevcuttur. “Fix issues before they exist” diye de bir sloganları var. Bu yazıda SonarLint’den bahsetmeyeceğim. Merak edenleriniz buradan inceleyebilirler.
SonarQube’ü açık kaynak projeleriniz için cloud üzerinden ücretsiz olarak kullanabileceğiniz gibi, private projeler için on-premise kurulum yaparak da kullanabilirsiniz. Cloud üzerinden private projeleriniz için ücret ödemeniz gerekiyor.
Amacım SonarQube kullanımı hakkında bilgi vermek olduğu için, kurulum kısmını atlayıp, konuyu cloud üzerinden yani https://sonarcloud.io uygulaması üzerinden anlatacağım. SonarQube’ü aşağıda listelediğim 6 ana başlıkta inceleyeceğiz;
•	https://sonarcloud.io uygulamasına giriş ve boş bir proje oluşturma
•	Kişisel bilgisayarımıza SonarScanner kurulumu
•	SonarScanner ile örnek bir .Net projesinin analiz edilmesi ve raporun sonarcloud.io ya gönderilmesi
•	sonarcloud.io ya gönderilen raporun yorumlanması
•	Quality Gates, Quality Profiles ve Rules kavramları hakkında
•	SonarQube’ün bir CI pipeline’ına dahil edilmesi
sonarcloud.io SaaS Uygulamasına Giriş
SonarQube’ü açık kaynak projeler için cloud üzerinden ücretsiz olarak kullanabiliyoruz. Giriş ekranında sizi 3 OAuth seçeneği karşılıyor. Ben github hesabımla giriş yaptım.
 
Ekran 1: OAuth login seçenekleri
Sağ üst köşedeki menüden “Create new organization” diyerek bir organizasyon oluşturarak başlıyoruz. SonarQube de her proje bir organizasyona bağlıdır. Daha sonra yine sağ üst köşeden “Analyze new project” diyoruz ve aşağıdaki ekranla karşılaşıyoruz.
 
 
Ekran 2: Mevcut organizasyona proje ekleme
Önceki adımda oluşturduğumuz organizasyonumuz seçili geliyor. Devam diyoruz ve sonraki adımda bir token oluşturuyoruz. Oluşan token değeri lazım olacak, hemen bir yere kopyalayıp devam ediyoruz ve aşağıdaki ekrandan projemizin ana programlama dilini seçiyoruz ve projemiz için bir anahtar kelime belirliyoruz.( Projede birden fazla dil olabileceğinden ötürü (c#, html, js) ana dil ifadesi kullanılmış )
 
 
Ekran 3: Projenin ana programlama dili seçimi
Done butonuna tıkladıktan sonra aşağıdaki ekranla karşılaşacaksınız. Bu ekranda gördüğünüz üzere Scanner’ı çalıştırmak ve projenizi analiz edebilmek için komut satırından çalıştırmanız gereken 3 adet komut yer almakta. Bu 3 komutu bir yere kopyalayıp ekranı kapatabilirsiniz.
 
 
Ekran 4: Proje ekleme son adım
SonarScanner Kurulumu
Yukarıdaki ekran görüntüsünde dikkat ederseniz ”Download and unzip the Scanner for MSBuild” ifadesi yer alıyor. Peki neden MSBuild Scanner? Dil olarak C# seçtiğimiz için SonarQube ilgili Scanner hangisiyse onu indirmemiz gerektiğini söylüyor. Download butonu ile yönlendirileceğiniz ekrandaki talimatları yerine getirerek MSBuild Scanner’ını bilgisayarınıza kurmuş olacaksınız. (%PATH% güncellemesini unutmayınız) Bu arada hangi tür Scanner kurarsanız kurun sisteminizde mutlaka java’nın kurulu olması gerektiğini belirteyim. JRE hakkındaki detayları da yine download butonuyla yönlendirileceğiniz sayfadan görebilirsiniz.
MSBuild SonarScanner İle Projenin Kod Analizi
Önceki adımda kurduğumuz Scanner’ı kullanarak C# dili ile yazılmış olan projemiz için static kod analizini yapabiliriz artık. Bunun için projenin ana dizinindeyken sırasıyla aşağıdaki 3 komutu çalıştırmamız yeterli. Son komuttan sonra 5 nolu ekran görüntüsüyle karşılaşmanız raporun oluştuğu ve sonarcloud’a gönderildiği anlamına gelir. (rabbitmq sonarcloud da projemi oluştururken verdiğim key’in ismi)
 
Ekran 5: Kod analizinin başarıyla yapılması
SonarScanner.MSBuild.exe begin /k:"<proje unique key buraya>" /d:sonar.organization="<organizasyon_adi_buraya>" /d:sonar.host.url="https://sonarcloud.io" /d:sonar.login="<olusturulan_token_adi_buraya>"MsBuild.exe /t:RebuildSonarScanner.MSBuild.exe end /d:sonar.login="<olusturulan_token_degeri_buraya>"
Bu 3 komutta koyulaştırdığım kısımlar sizin proje ve organizasyon isminize göre değişecektir. 4 nolu ekran görüntüsünde yer alan bu 3 komutu bir yere kopyaladıysanız, hızlıca komut satırından çalıştırabilirsiniz. Komut satırında “Post-processing succeded” ifadesini gördükten sonra artık sonarcloud’a geçiş yaparak projenizin analiz edildiğini görebilmelisiniz.
 
 
Ekran 6: “Passed” :)
106 sayısı kod satır sayısını ifade etmekte. Hemen altında da C# ibaresi, programlama dilini işaret ediyor. Evet, çok küçük ve XS (X Small) kategorisinde bir proje olmasına rağmen yeşil renkli “Passed” ifadesini görmek güzel hissettiriyor :) Buradan inceleyebilirsiniz.
Oluşan Raporun Yorumlanması
Raporu yorumlamadan önce hemen belirteyim, örnek proje zamanında RabbitMQ yü kurcalamak için oluşturduğum bir Asp.Net MVC uygulaması.
Proje public bir proje olduğu için sonarcloud hesabınız olmasa bile, yani sonarcloud a giriş yapmadan da oluşan son raporu buradan görebilirsiniz.
Linke tıkladıysanız aşağıdaki ekranla karşılaşmış olmanız gerekiyor.
 
Ekran 7: rabbitmq key’i ile oluşturduğum projemin sonarcloud dashboard’u
Dikkat ederseniz rapor 5 ana başlıktan oluşuyor. Bunlar;
Bugs
Projenizde bu kategoriye alınan kodlarınız varsa bir şeylerin yanlış veya eksik olduğundan emin olabilirsiniz. Eğer düzeltilmezse ileride başınız ağrıyabilir, dolayısıyla bu kategoriyi önemseyin. Bizim 109 satırlık küçük uygulamamızda Bug olarak nitelendirilecek bir şey bulamamış sevgili SonarQube. A alarak geçmişiz bu dersten :) Eğer ne tür durumların bug olarak ele alındığını merak ediyorsanız buraya tıklayarak public projeleri keşfedebilir, raporları dilediğinizce inceleyerek bir çok şey öğrenebilirsiniz.
Vulnerabilities
Güvenlik zafiyetine sebebiyet verecek olan kod parçacıkları bu kategoride raporlanmaktadır. Yani bu kategoride en az Bug kategorisi kadar önemli. Göz ardı etmemekte fayda var, bir örnek olması açısından rastgele public bir projeden aldığım aşağıda ekran görüntüsünü paylaşmak istedim.
 
 
Ekran 8: SonarQube’ün zafiyet olarak gördüğü alert kullanımı
Burada bir js dosyası içerisinde kullanılan alert metodu zafiyet olarak görülmüş. Üç nokta (…) icon’una tıklayarak açılan aşağıdaki bilgilendirme ekranında SonarQube’ün gerekçesini de görebilmeniz mümkün. Özetle, debug modda alert’e tamam ama production da hassas veri gösterme riski taşıdığından burada bir zafiyet var arkadaş, diyor SonarQube.
 
 
Ekran 9: SonarQube: Production ortamında unutulan alert can yakabilir
Code Smells
İlk 2 maddemiz kadar risk teşkil etmeyen ancak, kod okunabilirliği ve bakım maliyetleri açısından negatif etki yapabilecek kod parçacıkları bu kategoride değerlendirilmekte. Raporumuzda 3 adet code smells olduğu görülüyor. Hemen yanında yazan 14 min ifadesi ise, bu 3 adet sorunun tahmini çözüm süresi :) Evet SonarQube sağ olsun onu da hesaplıyor ama tabi bu değerde bir hata payı olabileceğini söylememe gerek yok sanırım. Şimdi bu 3 rakamına tıklayarak aşağıdaki detay ekranına erişiyoruz.
 
 
Ekran 10: Code Smell liste ekranı
Listede koyu renkle yazılı olan özet bilgisi aslında gerekli detayı veriyor. Örneğin ilk maddede sadece constructor içerisinden değer atanan _hostName adındaki field’ın readonly olarak işaretlenmesi gerektiğinden bahsediyor. Eğer bu maddenin üzerine tıklarsanız aşağıdaki detay ekranında ilgili kod dosyasının ilgili satırını görebiliyorsunuz.
 
 
Ekran 11: Code Smell detayı
Burada yine Make _hostName readonly ifadesinin yanındaki üç nokta (…) ya tıklarsanız ekranın en altında o maddeyle alakalı bilgilendirici açıklamayı görebilirsiniz. SonarQube sadece açıklarınız bulmuyor aynı zamanda eğitiyor da :) Gördüğünüz gibi içerikte örnek kod bile var.

Coverage
Buradan yazılan testlerin projenizin ne kadarını cover ettiğiniz görebilirsiniz. Bu küçük projede test yazılmadığı için değerimiz %0 ve kırmızı renk bir uyarı manasında, yani unit test yazılmadığını ifade ediyor.
Duplications
Proje genelinde tekrarlı kod satırlarının toplam kod satırına oranını ifade eder. Örneğin 1000 satır kod içerisinde toplamda 100 satır eğer tekrarlı ise bu değer %10 olacaktır. Örnek projemiz az sayıda kod içerdiğinden ötürü hiç tekrarlı kod yoktur. Ben orta ve büyük ölçekli projelerde bu değerin %40- 50 'lerde olabildiğini görmüştüm ki çok ciddi bir oran. SonarQube detaylı olarak aşağıdaki ekran görüntüsünde gördüğünüz gibi dosya bazında tekrarlı kod oranlarını başarılı şekilde raporlayabiliyor.
 
 
Ekran 13: Kod dosyası bazında rapor detayları
Quality Gates, Quality Profiles ve Rules Kavramları Hakkında
Quality Gate’ler projemizin production ortamı için hazır olup olmadığına karar veren kural dizileridir. Bir başka değişle, kod analiz raporunun başarılı mı (Passed), başarısız mı (Failed) olacağının belirlenmesi için kullanılırlar. 6 nolu ekran görüntüsünde yer alan yeşil renkli “Passed” ifadesi, kod analiz işlemi esnasında mevcut Quality Gate’lerin hepsinden geçildiği ve rapor sonucunun başarılı olduğu anlamına geliyor.
SonarQube desteklediği her programlama dili için default (ön tanımlı) olarak, Quality Profile, Rules ve Quality Gate tanımlamalarına sahip. Örneğin C# dili için buraya tıklayarak ulaşabileceğiniz, benim oluşturduğum public organizasyonun aşağıdaki ekranında ön tanımlı olarak gelen Quality Gate’leri görebilirsiniz.
Örneğin; en altta belirtilen kuraldan, Security notunun A’dan daha kötü olması raporun başarısız sonuçlanacağını anlamalıyız. Ve en önemlisi, sol üst köşedeki Create butonuyla, kendi custom Quality Gate’inizi oluşturabilirsiniz. Örneğin siz projenizde Security notunun B den daha kötü olması durumunda raporun başarısız olmasını sağlayabilirsiniz.
 
Ekran 14: Ön tanımlı Quality Gate’ler
Peki Security notu nasıl belirleniyor? Burada Rules kavramına değinmemiz gerekiyor. Yukarıdaki ekran görüntüsünde Rules sekmesine tıkladığınızda aşağıdaki ekrana erişeceksiniz. Sol taraftaki filtreleme özelliğini kullanarak yalnızca C# için tanımlı olan kuralları listeledim. Kurallara tıklayarak örnek kod parçacıklarının da yer verildiği bilgilendirici detay sayfalarına göz atabilirsiniz. Dikkat ederseniz C# dili için kural havuzunda toplam 358 adet (21.08.2018 tarihli kural sayısı ) kural tanımlı. Bu kurallar C# ve diğer diller için sürekli olarak artmakta, eklenen yeni kurallarla SonarQube geliştirilmeye devam etmektedir.
 
 
Ekran 15: C# dili için tanılı kurallar listesi
Quality Profile içinse en basit haliyle, çeşitli kuralları içeren gruplardır diyebiliriz. Yani C# dili için kendinize özel oluşturacağınız bir Quality Profile, en az 1 en fazla 358 adet kuraldan oluşabilir.
Özetle SonarQube’ün ön tanımlı Quality Gate ve Quality Profile ını kullanmayıp, kendi tanımlamalarınızı yapabilirsiniz. Üstelik bunları proje bazlı da yapabilirsiniz. Aşağıdaki ekrandan rabbitmq projemiz için Administrator sekmesinde tıkladığımızda açılan menüden bu değişikliği yapabiliriz.
 
 
Ekran 16: Proje bazlı admin ekranları için menü
Bu menüden Quality Gate sekmesinde tıkladığımızda gelen ekrandan, projemiz için istediğimiz Quality Gate’i seçebiliriz. Buradaki sample gate isimli Quality Gate benim örnek olması için yaptığım tanımlama. Dikkat ederseniz Sonar way için, default ibaresi var yani tüm projeler ilk oluşturulduklarında ön tanımlı olarak Sonar way Quality Gate’ine tabi tutulmaktalar.
 
 
Ekran 17: Projenin Quality Gate’inin değiştirilmesi
Aynı şekilde Quality Profiles linkine tıklayarak SonarQube’ün projenize atadığı ön tanımlı profili kullanmayıp kendi tanımladığınız profilin kullanılmasını sağlayabilirsiniz. Ön tanımlı gelen Sonar way isimli Quality Profile tüm kuralları içerirken siz kendi profiliniz için kapsamı daraltmak isteyebilirsiniz mesela.
Örnek vermek gerekirse; kendi özel tanımlayacağınız Quality Profile’ınızdan projemizde 2 adet Code Smell olarak değerlendirilen, readonly field kuralını çıkarırsanız, Code Smell sayımız bire inecektir. Bu yolla siz, “readonly field kuralı benim için code smell değildir”, demiş olursunuz aslında.
SonarQube’ü CI Pipeline’ınıza Dahil Edin
Eğer hali hazırda bir CI yazılımı kullanmaktaysanız, SonarQube veya benzeri bir statik kod analiz aracını CI pipeline’ınıza dahil edebilirsiniz. Bu noktada kullandığınız CI yazılımına göre eforunuz değişecektir. Jenkins, TeamCtiy, Travis CI vs. gibi bazı CI araçları SonarQube için sahip oldukları plugin’ler sayesinde bu eforu minimuma indirmekteler. Diğer bir ifadeyle SonarQube için doğal desteğe sahipler.
Doğal entegrasyona sahip CI araçlarında SonarQube rapor sonucuna göre pipeline’ınızı kırıp, ilgili yerlere bildirim yapabilirsiniz. Örneğin build adımından sonra SonarQube’ü tetikler, raporu sonucunu bekletir ve rapor başarısız olursa bir sonraki adıma geçmeyebilirsiniz.
Plugin ile doğal entegrasyon imkanı olmayan CI araçlarında SonarQube’ü tetiklemek için ise, yml scriptinize MSBuild SonarScanner İle Projenin Kod Analizi bölümünde belirttiğimiz komutları ekleyerek ilerleyebilirsiniz. Bu noktada rapor sonucunu bekleyerek, gelen sonucuna göre bir aksiyon almak mümkün müdür açıkçası bilmiyorum. Yorumlarınızı alabilirim.

-
-
-
UNIX		(GITHUB)
Unix nedir
Unix (/ˈjuːnɪks/; trademarked as UNIX) is a family of multitasking, multiuser computer operating systems that derive from the original AT&T Unix, development starting in the 1970s at the Bell Labs research center by Ken Thompson, Dennis Ritchie, and others.[3]
-Unix vs linux yazılar var: https://chandigarhinfo.in/unix-vs-linux-whats-the-difference/
-
UNIX türevi işletim sistemleri çok işlemcili çok pahalı makinalardan, tek işlemcili basit ve çok ucuz ev bilgisayarlarına kadar pek çok cihaz üzerinde çalışabilen esnek ve sağlamlığı çok değişik koşullarda test edilmiş sistemlerdir. Fakat özellikle kararlı yapısı ve çok kullanıcılı-çok görevli yapısıyla çok işlemcili sunucularda adeta standard haline gelmiştir ve özellikle akademik dünyada iş istasyonları üzerinde çok yaygın bir kullanım alanı bulmuştur. UNIX, Interdata 7/32, VAX, ve Motorola 68000 arasında hızla yayıldı.
Unix işletim sistemi 1969 yılında AT&T Bell Laboratuvarları'nda ABD de Ken Thompson, Dennis Ritchie, Brian Kernighan, Douglas McIlroy, Michael Lesk ve Joe Ossanna tarafından tasarlanıp uygulamaya konmuştur.İlk olarak 1971'de yayınlandı ve başlangıçta tamamen bilgisayar programlarının yazılmasında kullanılan alt seviyeli bir çevirme dilinde yazılmıştı. Daha sonra 1973'te Dennis Ritche tarafından C programlama dili ile tekrar yazıldı. Üst düzey bir dilde yazılmış bir işletim sisteminin geçerliliği diğer farklı bilgisayar platformlarına kolayca taşınabilirlik için olanak sağlar. Lisans için AT&T'yi zorlayan yasal bir aksaklık nedeniyle, UNIX hızlıca büyüdü ve öğretim kurumları ve işletmeler tarafından kabul edilir oldu.
UNIX, 1969 yılında,Ken Thompson, Dennis Ritchie, Brian Kernighan, Douglas McIlroy, Michael Lesk ve Joe Ossanna tarafından Bell Laboratuvarları'nda geliştirilmiş, çok kullanıcılı (multiuser), çok görevli yapıyı destekleyen (multitasking) bir bilgisayar işletim sistemidir. Komut yorumlayıcı yazılımlar (shell) aracılığı ile kullanıcı ve bilgisayar sisteminin iletişimi sağlanır.
Linus Torvalds tarafından temelleri atılan Linux, UNIX olmayıp bir UNIX türevidir. UNIX'ten ilham alan, bir grup bağımsız yazılımcı tarafından geliştirilen bir işletim sistemi çekirdeğidir. 
-
-
-
-
Linux 		(GITHUB)
Linux nedir

The name “Linux” comes from the Linux kernel. It is the software on a computer that allows applications and users to access the devices on the computer to perform certain specific functions.
Bilgisayar işletim sistemlerinin en temel parçası olan çekirdek yazılımlarından bir tanesidir.verilmiştir.[1]Günümüzde süper bilgisayarlarda, akıllı cihazların ve internet altyapısında kullanılan cihazların işletim sistemlerinde yaygın olarak kullanılmaktadır. Bunlardan en popüler olanı Google tarafından geliştirilen Android işletim sistemidir.
Android, Linux çekirdeği üzerine inşa edilmiş bir mobil işletim sistemidir.
Android işletim sistemi beş kısımdan oluşur.
1.	Çekirdek: Linux kernelidir. Güvenlik, hafıza yönetimi, süreç yönetimi, ağ yığınları ve sürücü modellerini içermektedir.
2.	Android Runtime: Sanal makinedir. Dalvik Sanal Makinesini de içermektedir. 5.0 ile Dalvik kaldırılmış ve ART'ye geçilmiştir.
3.	Kütüphaneler: Veritabanı kütüphaneleri, web tarayıcı kütüphaneleri, grafik ve arayüz kütüphanelerini içermektedir.
4.	Uygulama Çatısı: Uygulama geliştiricilere geniş bir platform sunan kısımdır.
5.	Uygulama Katmanı: Doğrudan Java (programlama dili) ile geliştirilmiş uygulamaları içermektedir.
-
-
-
-
-
-
-
-
-
UNIX vs. LINUX		(bosch)	 (bosch)
unix nedir, linux nedir, UNIX nedir
The UNIX is a multiuser computer operating systems was born in the late 1960s. AT & T Bell Labs released an OS called Unix written in C, which allows for faster modification, portability and acceptance. It began as a one-man project led by Ken Thompson of Bell Labs. It became the most widely used operating system. Unix is a proprietary operating system.
Unix OS works on CLI (Command Line Interface), but recently it has been developed for GUI on Unix systems. Unix is an operating system that is popular in companies, universities, large companies, etc
What is LINUX? 
Linux is an operating system built by Linus Torvalds at the University of Helsinki in 1991. The name “Linux” comes from the Linux kernel. It is the software on a computer that allows applications and users to access the devices on the computer to perform certain specific functions.
Linux OS forwards instructions from an application from the computer processor and sends the results back to the application via Linux OS. It can be installed on another type of computers, mobile phones, tablets, video game consoles, etc.
The development of Linux is one of the most prominent examples of collaboration with free and open source. Today, many companies and similar individuals have released their own version of the OS based on the Linux kernel.
 
 
 
Features of Unix OS
	Multitasking and Multi-user operating system
	It can be used as a master control program in servers and  workstations.
	Hundreds of commercial applications available
	In its day, UNIX was rapidly adopted and became the standard OS in universities.
if you are learn more about linux then Join CBitss Technologies. CBitss Provides Best Linux Training in Chandigarh Sector 34A. More details Call Now –  (+91) 9988741983
Features of Linux Operating System
	Support multitasking
	Programs consist of one or more processes, and each process has one or more threads
	It can easily co-exists along with other Operating systems.
	It can run multiple user programs
	Individual accounts are protected because of appropriate authorization
	Linux is a copy of UNIX but does not use its code
Difference between Unix and Linux
Cost 
	 Linux is freely distributed, downloaded via newspapers, books, websites, etc. There are also paid versions available for Linux.
	Unix – Different flavors of Unix have different prices depending on the supplier type
Development
	Linux is Open Source and thousands of programmers collaborate online and contribute to its development
	Unix systems have different versions. These versions are mainly developed by AT&T and other commercial suppliers
User
	Linux – All. From home users to both developers and computer enthusiasts.
	UNIX can be used on Internet servers, workstations, and computers
Text made interface
	BASH is the Linux shell. It offers support for several command interpreters
	Unix Originally build up to work in Bourne Shell. But it is now compatible with much other software.
GUI
	Linux has two GUIs, KDE and Gnome. Although there are many options like Mate, LXDE, Xfce, etc.
	Unix – Shared desktop environment and also has Gnome.
Viruses
	Linux has had about 60-100 viruses so far listed that are not currently spreading.
	There are between 80 and 120 viruses reported to date in Unix.
Threat detection
	Threat detection and resolution are very fast as Linux is mainly community-driven. So if any Linux user publishes some kind of threat, a team of qualified developers will start working to resolve this threat
	Unix users require longer waiting times to get the correct fix
Architectures
	Linux – Originally developed for Intel x86 hardware processors. It is available for over 20 different types of CPU, which also includes an ARM
	Unix – It is available on PA-RISC and Itanium machines
Usage
	Linux OS can be installed on different types of devices such as mobile, tablets
	The UNIX operating system is used for Internet servers, workstations, and computers
Best feature
	Linux – Kernel update without a reboot
	Unix – Feta ZFS – next-generation DTrace file system – dynamic kernel tracking
Versions
	Various versions of Linux are Redhat, Ubuntu, OpenSuse, Solaris etc
	Different versions of Unix are AIS, BSD, HP-UX, etc.
Supported file type
	File system supported by file type such as xfs, nfs, cramfsm ext 1 to 4, ufs, devpts, NTFS
	The file systems supported by file types are zfs, hfx, GPS, xfs, vxfs
Portability
	Linux is portable and is booted from a USB Stick
	Unix is not portable
Source Code
	Linux – The source is available to the general public
	Unix – The source code is not available to anyone
Limitation of Linux
	There’s no standard edition of Linux
	Linux has patchier support for drivers that can cause system-wide errors.
	Linux, at least for new users, is not as easy to use as Windows.
	Many of the programs we use for Windows will only run on Linux using a complicated emulator. For example. Microsoft Office
	Linux is best suitable for a corporate user. It’s much harder to introduce in a home setting.
Limitations of Unix
	The unfriendly, terse, inconsistent, and non-mnemonic user interface
	Unix Operating system is designed for a slow computer system, so you can’t expect fast performance.
	The Shell interface can be treacherous because typos can destroy files.
	Versions on different machines are slightly different, so it lacks consistency.
	Unix does not provide a secure response time for hardware failure, so it does not support real-time response systems.
-
-
-
UNIX		(bosch)	 (bosch)
unix nedir
UNIX türevi işletim sistemleri çok işlemcili çok pahalı makinalardan, tek işlemcili basit ve çok ucuz ev bilgisayarlarına kadar pek çok cihaz üzerinde çalışabilen esnek ve sağlamlığı çok değişik koşullarda test edilmiş sistemlerdir. Fakat özellikle kararlı yapısı ve çok kullanıcılı-çok görevli yapısıyla çok işlemcili sunucularda adeta standard haline gelmiştir ve özellikle akademik dünyada iş istasyonları üzerinde çok yaygın bir kullanım alanı bulmuştur. UNIX, Interdata 7/32, VAX, ve Motorola 68000 arasında hızla yayıldı.
Unix işletim sistemi 1969 yılında AT&T Bell Laboratuvarları'nda ABD de Ken Thompson, Dennis Ritchie, Brian Kernighan, Douglas McIlroy, Michael Lesk ve Joe Ossanna tarafından tasarlanıp uygulamaya konmuştur.İlk olarak 1971'de yayınlandı ve başlangıçta tamamen bilgisayar programlarının yazılmasında kullanılan alt seviyeli bir çevirme dilinde yazılmıştı. Daha sonra 1973'te Dennis Ritche tarafından C programlama dili ile tekrar yazıldı. Üst düzey bir dilde yazılmış bir işletim sisteminin geçerliliği diğer farklı bilgisayar platformlarına kolayca taşınabilirlik için olanak sağlar. Lisans için AT&T'yi zorlayan yasal bir aksaklık nedeniyle, UNIX hızlıca büyüdü ve öğretim kurumları ve işletmeler tarafından kabul edilir oldu.
UNIX, 1969 yılında,Ken Thompson, Dennis Ritchie, Brian Kernighan, Douglas McIlroy, Michael Lesk ve Joe Ossanna tarafından Bell Laboratuvarları'nda geliştirilmiş, çok kullanıcılı (multiuser), çok görevli yapıyı destekleyen (multitasking) bir bilgisayar işletim sistemidir. Komut yorumlayıcı yazılımlar (shell) aracılığı ile kullanıcı ve bilgisayar sisteminin iletişimi sağlanır.
Linus Torvalds tarafından temelleri atılan Linux, UNIX olmayıp bir UNIX türevidir. UNIX'ten ilham alan, bir grup bağımsız yazılımcı tarafından geliştirilen bir işletim sistemi çekirdeğidir. 
-
-
-
-
-
UNIX vs. LINUX		(bosch)	 (bosch)
unix nedir, linux nedir, UNIX nedir
The UNIX is a multiuser computer operating systems was born in the late 1960s. AT & T Bell Labs released an OS called Unix written in C, which allows for faster modification, portability and acceptance. It began as a one-man project led by Ken Thompson of Bell Labs. It became the most widely used operating system. Unix is a proprietary operating system.
Unix OS works on CLI (Command Line Interface), but recently it has been developed for GUI on Unix systems. Unix is an operating system that is popular in companies, universities, large companies, etc
What is LINUX? 
Linux is an operating system built by Linus Torvalds at the University of Helsinki in 1991. The name “Linux” comes from the Linux kernel. It is the software on a computer that allows applications and users to access the devices on the computer to perform certain specific functions.
Linux OS forwards instructions from an application from the computer processor and sends the results back to the application via Linux OS. It can be installed on another type of computers, mobile phones, tablets, video game consoles, etc.
The development of Linux is one of the most prominent examples of collaboration with free and open source. Today, many companies and similar individuals have released their own version of the OS based on the Linux kernel.
 
 
 
Features of Unix OS
	Multitasking and Multi-user operating system
	It can be used as a master control program in servers and  workstations.
	Hundreds of commercial applications available
	In its day, UNIX was rapidly adopted and became the standard OS in universities.
if you are learn more about linux then Join CBitss Technologies. CBitss Provides Best Linux Training in Chandigarh Sector 34A. More details Call Now –  (+91) 9988741983
Features of Linux Operating System
	Support multitasking
	Programs consist of one or more processes, and each process has one or more threads
	It can easily co-exists along with other Operating systems.
	It can run multiple user programs
	Individual accounts are protected because of appropriate authorization
	Linux is a copy of UNIX but does not use its code
Difference between Unix and Linux
Cost 
	 Linux is freely distributed, downloaded via newspapers, books, websites, etc. There are also paid versions available for Linux.
	Unix – Different flavors of Unix have different prices depending on the supplier type
Development
	Linux is Open Source and thousands of programmers collaborate online and contribute to its development
	Unix systems have different versions. These versions are mainly developed by AT&T and other commercial suppliers
User
	Linux – All. From home users to both developers and computer enthusiasts.
	UNIX can be used on Internet servers, workstations, and computers
Text made interface
	BASH is the Linux shell. It offers support for several command interpreters
	Unix Originally build up to work in Bourne Shell. But it is now compatible with much other software.
GUI
	Linux has two GUIs, KDE and Gnome. Although there are many options like Mate, LXDE, Xfce, etc.
	Unix – Shared desktop environment and also has Gnome.
Viruses
	Linux has had about 60-100 viruses so far listed that are not currently spreading.
	There are between 80 and 120 viruses reported to date in Unix.
Threat detection
	Threat detection and resolution are very fast as Linux is mainly community-driven. So if any Linux user publishes some kind of threat, a team of qualified developers will start working to resolve this threat
	Unix users require longer waiting times to get the correct fix
Architectures
	Linux – Originally developed for Intel x86 hardware processors. It is available for over 20 different types of CPU, which also includes an ARM
	Unix – It is available on PA-RISC and Itanium machines
Usage
	Linux OS can be installed on different types of devices such as mobile, tablets
	The UNIX operating system is used for Internet servers, workstations, and computers
Best feature
	Linux – Kernel update without a reboot
	Unix – Feta ZFS – next-generation DTrace file system – dynamic kernel tracking
Versions
	Various versions of Linux are Redhat, Ubuntu, OpenSuse, Solaris etc
	Different versions of Unix are AIS, BSD, HP-UX, etc.
Supported file type
	File system supported by file type such as xfs, nfs, cramfsm ext 1 to 4, ufs, devpts, NTFS
	The file systems supported by file types are zfs, hfx, GPS, xfs, vxfs
Portability
	Linux is portable and is booted from a USB Stick
	Unix is not portable
Source Code
	Linux – The source is available to the general public
	Unix – The source code is not available to anyone
Limitation of Linux
	There’s no standard edition of Linux
	Linux has patchier support for drivers that can cause system-wide errors.
	Linux, at least for new users, is not as easy to use as Windows.
	Many of the programs we use for Windows will only run on Linux using a complicated emulator. For example. Microsoft Office
	Linux is best suitable for a corporate user. It’s much harder to introduce in a home setting.
Limitations of Unix
	The unfriendly, terse, inconsistent, and non-mnemonic user interface
	Unix Operating system is designed for a slow computer system, so you can’t expect fast performance.
	The Shell interface can be treacherous because typos can destroy files.
	Versions on different machines are slightly different, so it lacks consistency.
	Unix does not provide a secure response time for hardware failure, so it does not support real-time response systems.
-
-
-
-



