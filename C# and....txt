Overload / Method overloading  	(GITHUB)
overload nedir, overloading nedir, method overloading nedir

Method Overloading is the common way of implementing polymorphism. It is the ability to redefine a function in more than one form. A user can implement function overloading by defining two or more functions in a class sharing the same name. C# can distinguish the methods with different method signatures. i.e. the methods can have the same name but with different parameters list (i.e. the number of the parameters, order of the parameters, and data types of the parameters) within the same class.
•	Overloaded methods are differentiated based on the number and type of the parameters passed as arguments to the methods.
•	You can not define more than one method with the same name, Order and the type of the arguments. It would be compiler error.
•	The compiler does not consider the return type while differentiating the overloaded method. But you cannot declare two methods with the same signature and different return type. It will throw a compile-time error. If both methods have the same parameter types, but different return type, then it is not possible.
Why do we need Method Overloading ??
If we need to do the same kind of the operation in different ways i.e. for different inputs. In the example described below, we are doing the addition operation for different inputs. It is hard to find many different meaningful names for single action.
Different ways of doing overloading methods-
Method overloading can be done by changing:
1.	The number of parameters in two methods.
2.	The data types of the parameters of methods.
3.	The Order of the parameters of methods.


using System; 
class GFG { 
    // adding two integer values. 
    public int Add(int a, int b) 
    { 
        int sum = a + b; 
        return sum; 
    } 
  
    // adding three integer values. 
    public int Add(int a, int b, int c) 
    { 
        int sum = a + b + c; 
        return sum; 
    } 
  
    // Main Method 
    public static void Main(String[] args) 
    { 
        // Creating Object 
        GFG ob = new GFG(); 
        int sum1 = ob.Add(1, 2); 
        Console.WriteLine("sum of the two "
                          + "integer value : " + sum1); 
  
        int sum2 = ob.Add(1, 2, 3); 
        Console.WriteLine("sum of the three "
                          + "integer value : " + sum2); 
    } 
} 
Output:
sum of the two integer value : 3
sum of the three integer value : 6

Diğer Örnek:

using System; 
class GFG { 
    // adding three integer values. 
    public int Add(int a, int b, int c) 
    { 
        int sum = a + b + c; 
        return sum; 
    } 
  
    // adding three double values. 
    public double Add(double a, 
                      double b, double c) 
    { 
        double sum = a + b + c; 
        return sum; 
    } 
  
    // Main Method 
    public static void Main(String[] args) 
    { 
  
        // Creating Object 
        GFG ob = new GFG(); 
  
        int sum2 = ob.Add(1, 2, 3); 
        Console.WriteLine("sum of the three "
                          + "integer value : " + sum2); 
        double sum3 = ob.Add(1.0, 2.0, 3.0); 
        Console.WriteLine("sum of the three "
                          + "double value : " + sum3); 
    } 
} 
Output:
sum of the three integer value : 6
sum of the three double value : 6


Diğer Örnek:

using System; 
class GFG { 
  
    // Method 
    public void Identity(String name, int id) 
    { 
  
        Console.WriteLine("Name : " + name + ", "
                          + "Id : " + id); 
    } 
      
    // Method 
    public void Identity(int id, String name) 
    { 
        Console.WriteLine("Name : " + name + ", "
                          + "Id : " + id); 
    } 
  
    // Main Method 
    public static void Main(String[] args) 
    { 
        // Creating Object 
        GFG obj = new GFG(); 
  
        obj.Identity("Akku", 1); 
        obj.Identity("Abby", 2); 
    } 
} 
Output:
Name : Akku, Id : 1
Name : Abby, Id : 2

What happens when method signature is same and the return type is different?
The compiler will give error as the return value alone is not sufficient for the compiler to figure out which function it has to call. Only if both methods have different parameter types (so, they have the different signature), then Method overloading is possible.

Example:

using System; 
class GFG { 
    // adding two integer value. 
    public int Add(int a, int b) 
    { 
  
        int sum = a + b; 
        return sum; 
    } 
  
    // adding three integer value. 
    public double Add(int a, int b) 
    { 
        double sum = a + b + 0.0; 
        return sum; 
    } 
  
    // Main Method 
    public static void Main(String[] args) 
    { 
        // Creating Object 
        GFG ob = new GFG(); 
  
        int sum1 = ob.Add(1, 2); 
        Console.WriteLine("sum of the two "
                          + "integer value :" + sum1); 
  
        int sum2 = ob.Add(1, 2); 
        Console.WriteLine("sum of the three "
                          + "integer value :" + sum2); 
    } 
} 
Compile Time Error:
prog.cs(15,19): error CS0111: A member `GFG.Add(int, int)’ is already defined. Rename this member or use different parameter types
prog.cs(7,16): (Location of the symbol related to previous error)

Resimde bir overload örneği görüyoruz:
-
-
ntegral Types (GITHUB)

integral type nedir, integral types nedir, Integral type nedir, Integral types nedir
Adına dikkat et zaten ne olduğu belli oluyor etimolojisinden: Integral -> Integer
The integral numeric types represent integer numbers. All integral numeric types are value types. They are also simple types and can be initialized with literals. All integral numeric types support arithmetic, bitwise logical, comparison, and equality operators.
Characteristics of the integral types
C# supports the following predefined integral types:
CHARACTERISTICS OF THE INTEGRAL TYPES
C# type/keyword	Range	Size	.NET type
sbyte	-128 to 127	Signed 8-bit integer	System.SByte

byte	0 to 255	Unsigned 8-bit integer	System.Byte

short	-32,768 to 32,767	Signed 16-bit integer	System.Int16

ushort	0 to 65,535	Unsigned 16-bit integer	System.UInt16

int	-2,147,483,648 to 2,147,483,647	Signed 32-bit integer	System.Int32

uint	0 to 4,294,967,295	Unsigned 32-bit integer	System.UInt32

long	-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807	Signed 64-bit integer	System.Int64

ulong	0 to 18,446,744,073,709,551,615	Unsigned 64-bit integer	System.UInt64

In the preceding table, each C# type keyword from the leftmost column is an alias for the corresponding .NET type. They are interchangeable. For example, the following declarations declare variables of the same type:
int a = 123;
System.Int32 b = 123;
The default value of each integral type is zero, 0. Each of the integral types has the MinValue and MaxValue constants that provide the minimum and maximum value of that type.
Use the System.Numerics.BigInteger structure to represent a signed integer with no upper or lower bounds.
Integer literals
Integer literals can be
•	decimal: without any prefix
•	hexadecimal: with the 0x or 0X prefix
•	binary: with the 0b or 0B prefix (available in C# 7.0 and later)
The following code demonstrates an example of each:
var decimalLiteral = 42;
var hexLiteral = 0x2A;
var binaryLiteral = 0b_0010_1010;
The preceding example also shows the use of _ as a digit separator, which is supported starting with C# 7.0. You can use the digit separator with all kinds of numeric literals.

The type of an integer literal is determined by its suffix as follows:
•	If the literal has no suffix, its type is the first of the following types in which its value can be represented: int, uint, long, ulong.
•	If the literal is suffixed by U or u, its type is the first of the following types in which its value can be represented: uint, ulong.
•	If the literal is suffixed by L or l, its type is the first of the following types in which its value can be represented: long, ulong.
 Note
You can use the lowercase letter l as a suffix. However, this generates a compiler warning because the letter l can be confused with the digit 1. Use L for clarity.
•	If the literal is suffixed by UL, Ul, uL, ul, LU, Lu, lU, or lu, its type is ulong.
If the value represented by an integer literal exceeds UInt64.MaxValue, a compiler error CS1021 occurs.
If the determined type of an integer literal is int and the value represented by the literal is within the range of the destination type, the value can be implicitly converted to sbyte, byte, short, ushort, uint, or ulong:
byte a = 17;
byte b = 300;   // CS0031: Constant value '300' cannot be converted to a 'byte'
As the preceding example shows, if the literal's value is not within the range of the destination type, a compiler error CS0031 occurs.
You can also use a cast to convert the value represented by an integer literal to the type other than the determined type of the literal:
var signedByte = (sbyte)42;
var longVariable = (long)42;










TryParse  	(GITHUB)
tryparse nedir

TryParse(String, Int32)	
Yukarıda TryParse metodunun parametrelerini görüyoruz. İlk parametresi string alıyormuş, diğeri ise int değer…
Yapısı ise şöyle:
public static bool TryParse (string s, out int result);

Yani ilk parametre olan string değerini alıyor, OUT ile bunu int'e çevirmeye çalışıyor.
Yani tryparse STRING'I INT'E ÇEVİRMEYE ÇALIŞIR.
Converts the string representation of a number to its 32-bit signed integer equivalent. A return value indicates whether the conversion succeeded.


Using TryParse
The most common and most recommended way of parsing an integer string is to use the TryParse static method on the Int32 type as follows:
string intString = "234";
int i = 0;
if (!Int32.TryParse(intString, out i))
{
   i = -1;
}
return i;
Using TryParse with Nullable Integer
When the above example fails to parse the string as a valid integer, you can see that we just set it to -1. This doesn't work too well if -1 one is a meaningful value in your program. Instead, we could parse the string and return a nullable int where the null value indicates that the input string was not a valid integer.
private int? ConvertStringToInt(string intString)
{
   int i=0;
   return (Int32.TryParse(intString, out i) ? i : (int?)null);
}
Using Convert
There is yet another way to parse a string to an integer which uses the Convert method, but this is a little less convenient than the previous example because we have to manage exceptions if something goes wrong. Exceptions are also expensive to throw so you don't generally want these to be an expected part of the flow of your program. This is especially true if the exceptions are throwing in a loop where there is the potential for a lot of them. This could really slow down your program. You'd be better in that case to use TryParse or maybe even Regex to validate the string is in the form you desire before trying the conversion.
int i = 0;
try
{
   i = System.Convert.ToInt32(intString);
}
catch (FormatException)
{
   // the FormatException is thrown when the string text does 
   // not represent a valid integer.
}
catch (OverflowException)
{
   // the OverflowException is thrown when the string is a valid integer, 
   // but is too large for a 32 bit integer.  Use Convert.ToInt64 in
   // this case.
}
There are benefits to using Convert over TryParse when you need to know why the parsing failed.
Also unlike the TryParse method, the Convert method has many overloads which allow you to convert almost any type to an integer. Here are just a few examples:
int i = 0;

// bool to Int32
bool b = true;
i = Convert.ToInt32(b);

// byte to Int32
byte bt = 3;
i = Convert.ToInt32(bt);

// char to Int32
char c = 'A';
i = Convert.ToInt32(c);

// DateTime to Int32
DateTime dt = DateTime.Now;
i = Convert.ToInt32(dt);

// Decimal to Int32
decimal d = 25.678m;
i = Convert.ToInt32(d);

// double to Int32
double db = 0.007234;
i = Convert.ToInt32(db);
That's just a few of the 19 or so different overloads for the Convert method. For all of them visit the MSDN documentation on Convert.ToInt32.
-
-
Type Casting	GITHUB)
Type casting nedir, casting nedir, convert nedir
Type casting is when you assign a value of one data type to another type.
Örnek:
       public static void Main(string[] args)
        {
            double x = 1234.7;
            int a;

            // Cast double to int.
            a = (int)x;

            Console.WriteLine(a);

            
            double newDouble;
            int newInt = 42;

            //newDouble = (double)newInt; //redundant casting.. Gereksiz... Şöyle yazılır kısaca:
            newDouble = newInt;

            //bool u inte e cast etmeyi deneyelim:

            bool newBool1 = true;
            int asd;

            //asd = Convert.ToInt32(newBool1); // always true. yani çalıştı

            asd = Convert.ToInt32(newBool1); // always true. çalıştı

            //asd = (int)newBool1; // HATA

            int newInt2 = 20;

           //alttaki ikisi arasında ne fark var?
            string as3 = Convert.ToString(newInt2);

            string as4 = newInt2.ToString();
            
            //The basic difference between them is the Convert function handles NULLS while i.ToString () does not; it will throw a NULL reference exception error. So as good coding practice using convert is always safe.

            Console.ReadLine();
        }
In C#, there are two types of casting:
•	Implicit Casting (automatically) - converting a smaller type to a larger type size
char -> int -> long -> float -> double

•	Explicit Casting (manually) - converting a larger type to a smaller size type
double -> float -> long -> int -> char
Implicit Casting
Implicit casting is done automatically when passing a smaller size type to a larger size type:
Example
int myInt = 9;
double myDouble = myInt;       // Automatic casting: int to double

Console.WriteLine(myInt);      // Outputs 9
Console.WriteLine(myDouble);   // Outputs 9
Run example »
________________________________________
Explicit Casting
Explicit casting must be done manually by placing the type in parentheses in front of the value:
Example
double myDouble = 9.78;
int myInt = (int) myDouble;    // Manual casting: double to int

Console.WriteLine(myDouble);   // Outputs 9.78
Console.WriteLine(myInt);      // Outputs 9
Örnek:
There are benefits to using Convert over TryParse when you need to know why the parsing failed.
Also unlike the TryParse method, the Convert method has many overloads which allow you to convert almost any type to an integer. Here are just a few examples:
int i = 0;

// bool to Int32
bool b = true; (true ise 1 oluyor, false ise 0)

Convert string to int

 int int1 = Convert.ToInt32(Console.ReadLine());

            int int2 = int.Parse(Console.ReadLine());

            //https://www.cambiaresearch.com/articles/68/convert-string-to-int-in-csharp

Önemli örnek::::
        public static int? ConvertStringToInt(string intString)
        {
            int i = 0;
            return Int32.TryParse(intString, out i) ? i : (int?)null;
        }

        public static void Main(string[] args)
        {
            ConvertStringToInt("1");
        }
-
-
ASP.NET CORE  (GITHUB)
Asp.net core nedir

ASP.NET FRAMEWORK VS ASP.NET CORE 
ASP.Net Framework: 
4'e kadar çıktı versiyonu. 4.x te bitti. Sonra .NET Core başladı.
İlk başta Core'un adı Core değilmiş. ASP.NET 5'miş. Sonra Core'a dönmüş.

 
 
ASP.Net sadece Windowsta Run edilir. COre ise Wİndows, macOS ve Lİnux'ta run edilir.
ASP.NET Sadece IIS'te host edilir.
Core: IIS, Apache, Docker veya Self-host olarak host edilebilir.

ASP.net Core application initially starts as a Console application. (zaten dikkat edersen Main metodu var)
Main metot, bu console app'I configure eder, böylelikle console app ---> Web application'a dönüşür.
Das 
CORE: Built in support for DEPENDENCY INJECTION.
Wwwroot ta ne var? Css js dosyaları var. yazdığımız style scriptler vb.
Iisexpress vs iis --> iis deploy ortamında çalışır, gerçek hayatta. Express ise development ortamında.
-
-
nullable bool and others
You typically use a nullable value type when you need to represent the undefined value of an underlying value type. For example, a Boolean, or bool, variable can only be either true or false. However, in some applications a variable value can be undefined or missing. For example, a database field may contain true or false, or it may contain no value at all, that is, NULL. You can use the bool? type in that scenario.
The default value of a nullable value type represents null, that is, it's an instance whose Nullable<T>.HasValue property returns false.
(as we know, represent means: be entitled or appointed to act or speak for (someone), especially in an official capacity.)
Nullable<int> n1 = new Nullable<int>(10);
private int n2 = new int();
int? n3 ;
int? n4 = null;

string s1 = new string("qqq");
--
Loop

            int val1 = 0;
            for (; val1 < 11; val1++)
            {
                Console.WriteLine(val1);
            }
Değişik bir loop daha:

            int val2 = 0;
            for (; val2 < 11;)
            {
                Console.WriteLine(val2);
                val2++;
            }

Değişik 2
Ayrıca break örneği

            int asd = 0;
            for (;;)
            {
                asd++;
                Console.WriteLine(asd);
                if (asd == 8)
                {
                    Console.WriteLine("broken!");
                    break;
                }
            }


-
-
Object Oriented Programming / OOP / NYP
oop nedir, object oriented programming nedir, nyp nedir

Object oriented prensipleri nelerdir ? JAVA
Encapsulation  : Değişkenler private yapı larak get.. ve set.. metodlarıylaerişilir
Abstraction  : Gereksiz ayrıntı lar kullanıcıya sunulmaz
Inheritance    :  Bir  sını fın  özellikleri  extend  anahtar  kelimesiyle  miras alınır.
Polymorphism  :  Runtime  sırasında  oluşturulan  sını fın  metodununçağrı lmasıdır.[4],[5]

Nesne yönelimli programlama (NYP), (İngilizce: Object - Oriented Programming)(OOP), Her işlevin nesneler olarak soyutlandığı bir programlama yaklaşımıdır. NYP destekleyen programlama dilleri yüksek seviye diller olarak adlandırılır.

NYP'dan önceki uygulamaların bakım maliyeti ve karmaşıklık ilişkisi
NYP'dan önceki uygulamaların bakım maliyeti ve karmaşıklık ilişkisi
1960'lı yılların sonuna doğru ortaya çıkan bu yaklaşım, o dönemin yazılım dünyasında beliren bir bunalımın sonucudur. Yazılımların karmaşıklığı ve boyutları sürekli artıyor, ancak belli bir nitelik düzeyi korumak için gereken bakımın maliyeti zaman ve çaba olarak daha da hızlı artıyordu. NYP'yi bu soruna karşı bir çözüm haline getiren başlıca özelliği, yazılımda birimselliği (modularity) benimsemesidir. NYP ayrıca, bilgi gizleme (information hiding), veri soyutlama (data abstraction), çok biçimlilik (polymorphism) ve kalıtım (inheritance) gibi yazılımın bakımını ve aynı yazılım üzerinde birden fazla kişinin çalışmasını kolaylaştıran kavramları da yazılım literatürüne kazandırmıştır. Sağladığı bu avantajlardan dolayı, NYP günümüzde geniş çaplı yazılım projelerinde yaygın olarak kullanılmaktadır.

NYP'nin altında yatan birimselliğin ana fikri, her bilgisayar programının (izlence), etkileşim içerisinde olan birimler veya nesneler kümesinden oluştuğu varsayımıdır. Bu nesnelerin her biri, kendi içerisinde veri işleyebilir, ve diğer nesneler ile çift yönlü veri alışverişinde bulunabilir. Hâlbuki NYP'den önce var olan tek yaklaşımda (Yordamsal programlama), programlar sadece bir komut dizisi veya birer işlev (fonksiyon) kümesi olarak görülmektedirler.

Günümüzde çok çeşitli nesne tabanlı programlama dilleri olmasıyla beraber, en popüler diller sınıflar üzerine kurulmuşlardır (class-based). Bu dillerde nesneler sınıfların birer üyesidir ve nesnelerin tipini de bu sınıflar belirlerler.

En yaygın NYP dillerinden bazıları, Python, C++, Objective-C, Smalltalk, Delphi, Java, Swift, C#, Perl, Ruby ve PHP' dir.
Nesne yönelimli programlama dilleri yukarıda adı geçen tüm ögelere sahip olurken, Ada, JavaScript, Visual Basic gibi nesne tabanlı programlama dilleri birkaçından yoksundur, bu dillerin başlıca yoksunluğu kalıtıma sahip olmamalarıdır.

Nesneler ve sınıflar
NYP'yi destekleyen programlama dilleri genellikle tekrar kullanım ve genişletilebilirlik açısından, prototipler ve sınıflar şeklinde kod kalıtımına sahiptirler ve NYP deki nesneler kimi zaman gerçek dünyada bulunan şeylere karşılık gelebilir. Mesela bir grafik programı "kare", "üçgen" ve "yuvarlak" gibi nesnelere sahip olabilir. Bazen nesneler daha soyut şeyleri de temsil edebilirler, mesela bir hesap makinesi programı logaritma almanızı ya da metreyi fite çevirmenizi sağlayacak nesnelere sahip olabilir. İşte bu bahsi geçen nesneler belli sınıflar altında bulunurlar, mesela "Kasım" adında bir nesne Aylar sınıfının bir üyesi olabilir ya da "Faktöriyel" olarak isimlendirilmiş bir nesne Fonksiyonlar sınıfında yer alıyor olabilir.
Dependency inversion nedir
Clean architecture’ın arkasındaki ana prensip’lerden birisi ise, Dependency Inversion prensibidir. Bu prensip ile mimari içerisindeki modüllerimizi birbirinden ve farklı teknolojilerden daha decoupled bir hale getirebilmek mümkündür. 
-
-
Git		(GITHUB)
git nedir

By far, the most widely used modern version control system in the world today is Git. Git is a mature, actively maintained open source project originally developed in 2005 by Linus Torvalds, the famous creator of the Linux operating system kernel. A staggering number of software projects rely on Git for version control, including commercial projects as well as open source. Developers who have worked with Git are well represented in the pool of available software development talent and it works well on a wide range of operating systems and IDEs (Integrated Development Environments).

Having a distributed architecture, Git is an example of a DVCS (hence Distributed Version Control System). Rather than have only one single place for the full version history of the software as is common in once-popular version control systems like CVS or Subversion (also known as SVN), in Git, every developer's working copy of the code is also a repository that can contain the full history of all changes.

In addition to being distributed, Git has been designed with performance, security and flexibility in mind.

Performance
The raw performance characteristics of Git are very strong when compared to many alternatives. Committing new changes, branching, merging and comparing past versions are all optimized for performance. The algorithms implemented inside Git take advantage of deep knowledge about common attributes of real source code file trees, how they are usually modified over time and what the access patterns are.

Unlike some version control software, Git is not fooled by the names of the files when determining what the storage and version history of the file tree should be, instead, Git focuses on the file content itself. After all, source code files are frequently renamed, split, and rearranged. The object format of Git's repository files uses a combination of delta encoding (storing content differences), compression and explicitly stores directory contents and version metadata objects.

Being distributed enables significant performance benefits as well.

For example, say a developer, Alice, makes changes to source code, adding a feature for the upcoming 2.0 release, then commits those changes with descriptive messages. She then works on a second feature and commits those changes too. Naturally these are stored as separate pieces of work in the version history. Alice then switches to the version 1.3 branch of the same software to fix a bug that affects only that older version. The purpose of this is to enable Alice's team to ship a bug fix release, version 1.3.1, before version 2.0 is ready. Alice can then return to the 2.0 branch to continue working on new features for 2.0 and all of this can occur without any network access and is therefore fast and reliable. She could even do it on an airplane. When she is ready to send all of the individually committed changes to the remote repository, Alice can "push" them in one command.

Security
Git has been designed with the integrity of managed source code as a top priority. The content of the files as well as the true relationships between files and directories, versions, tags and commits, all of these objects in the Git repository are secured with a cryptographically secure hashing algorithm called SHA1. This protects the code and the change history against both accidental and malicious change and ensures that the history is fully traceable.

With Git, you can be sure you have an authentic content history of your source code.

Some other version control systems have no protections against secret alteration at a later date. This can be a serious information security vulnerability for any organization that relies on software development.

Flexibility
One of Git's key design objectives is flexibility. Git is flexible in several respects: in support for various kinds of nonlinear development workflows, in its efficiency in both small and large projects and in its compatibility with many existing systems and protocols.

Git has been designed to support branching and tagging as first-class citizens (unlike SVN) and operations that affect branches and tags (such as merging or reverting) are also stored as part of the change history. Not all version control systems feature this level of tracking.

Version control with Git
Git is the best choice for most software teams today. While every team is different and should do their own analysis, here are the main reasons why version control with Git is preferred over alternatives:

Git is good
Git has the functionality, performance, security and flexibility that most teams and individual developers need. These attributes of Git are detailed above. In side-by-side comparisons with most other alternatives, many teams find that Git is very favorable.

Git is a de facto standard
Git is the most broadly adopted tool of its kind. This is makes Git attractive for the following reasons. At Atlassian, nearly all of our project source code is managed in Git.

Vast numbers of developers already have Git experience and a significant proportion of college graduates may have experience with only Git. While some organizations may need to climb the learning curve when migrating to Git from another version control system, many of their existing and future developers do not need to be trained on Git.

In addition to the benefits of a large talent pool, the predominance of Git also means that many third party software tools and services are already integrated with Git including IDEs, and our own tools like DVCS desktop client Sourcetree, issue and project tracking software, Jira, and code hosting service, Bitbucket.

If you are an inexperienced developer wanting to build up valuable skills in software development tools, when it comes to version control, Git should be on your list.

Git is a quality open source project
Git is a very well supported open source project with over a decade of solid stewardship. The project maintainers have shown balanced judgment and a mature approach to meeting the long term needs of its users with regular releases that improve usability and functionality. The quality of the open source software is easily scrutinized and countless businesses rely heavily on that quality.

Git enjoys great community support and a vast user base. Documentation is excellent and plentiful, including books, tutorials and dedicated web sites. There are also podcasts and video tutorials.

Being open source lowers the cost for hobbyist developers as they can use Git without paying a fee. For use in open-source projects, Git is undoubtedly the successor to the previous generations of successful open source version control systems, SVN and CVS.

Criticism of Git
One common criticism of Git is that it can be difficult to learn. Some of the terminology in Git will be novel to newcomers and for users of other systems, the Git terminology may be different, for example, revert in Git has a different meaning than in SVN or CVS. Nevertheless, Git is very capable and provides a lot of power to its users. Learning to use that power can take some time, however once it has been learned, that power can be used by the team to increase their development speed.

For those teams coming from a non-distributed VCS, having a central repository may seem like a good thing that they don't want to lose. However, while Git has been designed as a distributed version control system (DVCS), with Git, you can still have an official, canonical repository where all changes to the software must be stored. With Git, because each developer's repository is complete, their work doesn't need to be constrained by the availability and performance of the "central" server. During outages or while offline, developers can still consult the full project history. Because Git is flexible as well as being distributed, you can work the way you are accustomed to but gain the additional benefits of Git, some of which you may not even realise you're missing.

Now that you understand what version control is, what Git is and why software teams should use it, read on to discover the benefits Git can provide across the whole organization.
-
-
Compiler / Derleyici  (GITHUB) (örnek)
compiler nedir, derleyici nedir
Programcılıkta, bir programlama dilinde yazılmış olan kaynak kodunu başka bir dile (genellikle makine koduna) çeviren yazılım. Derleyiciye bunu yaptırmaktaki amaç genellikle çalışabilir bir yazılım elde etmektir. Kullanıcıların programları kullanırken kolaylık sağlamak amaçlı geliştirilmiştir... Örneğin, şu satırı bir programın kaynak kodunda (programın okunabilir hali) düşünelim:
 
Alttaki assembly'de yazılmış satırlar, aynı programın derlenmiş halidir:

LOAD A [0]        ;; belleğin 0 adresindeki veriyi A siciline yükle 

ADD  A BX         ;; A siciline BX sicilindeki adreste bulunan veriyi ekle 

STOR A [100]      ;; sonucu 100 adresine yaz

Bu örnekte çevirinin hedefi, programcının anladığı kaynak kodundan işlemcinin anladığı 0 ile 1 den oluşan makine dili kodunu üretmek (LOAD,ADD ve STOR komutları 0001, 0011 ve 0010 olarak yorumlanır)

 0001 01 00 00000000
 0011 01 10 00000010
 0010 01 00 00000100
 ---- -- -- ---------
  |   |  |   |_________bellek adresi
  |   |  |____________işaret   
  |   |______________sicil
  |_________________komut

In computing, a compiler is a computer program that translates computer code written in one programming language (the source language) into another language (the target language). The name "compiler" is primarily used for programs that translate source code from a high-level programming language to a lower level language (e.g., assembly language, object code, or machine code) to create an executable program.[1][2]:p1

However, there are many different types of compilers. If the compiled program can run on a computer whose CPU or operating system is different from the one on which the compiler runs, the compiler is a cross-compiler. A bootstrap compiler is written in the language that it intends to compile. A program that translates from a low-level language to a higher level one is a decompiler. A program that translates between high-level languages is usually called a source-to-source compiler or transcompiler. A language rewriter is usually a program that translates the form of expressions without a change of language. The term compiler-compiler refers to tools used to create parsers that perform syntax analysis.

A compiler is likely to perform many or all of the following operations: preprocessing, lexical analysis, parsing, semantic analysis (syntax-directed translation), conversion of input programs to an intermediate representation, code optimization and code generation. Compilers implement these operations in phases that promote efficient design and correct transformations of source input to target output. Program faults caused by incorrect compiler behavior can be very difficult to track down and work around; therefore, compiler implementers invest significant effort to ensure compiler correctness.[3]

Compilers are not the only language processor used to transform source programs. An interpreter is computer software that transforms and then executes the indicated operations.[2]:p2 The translation process influences the design of computer languages, which leads to a preference of compilation or interpretation. In practice, an interpreter can be implemented for compiled languages and compilers can be implemented for interpreted languages.

History
Main article: History of compiler construction

A diagram of the operation of a typical multi-language, multi-target compiler
A diagram of the operation of a typical multi-language, multi-target compiler
Theoretical computing concepts developed by scientists, mathematicians, and engineers formed the basis of digital modern computing development during World War II. Primitive binary languages evolved because digital devices only understand ones and zeros and the circuit patterns in the underlying machine architecture. In the late 1940s, assembly languages were created to offer a more workable abstraction of the computer architectures. Limited memory capacity of early computers led to substantial technical challenges when the first compilers were designed. Therefore, the compilation process needed to be divided into several small programs. The front end programs produce the analysis products used by the back end programs to generate target code. As computer technology provided more resources, compiler designs could align better with the compilation process.

It is usually more productive for a programmer to use a high-level language, so the development of high-level languages followed naturally from the capabilities offered by digital computers. High-level languages are formal languages that are strictly defined by their syntax and semantics which form the high-level language architecture. Elements of these formal languages include:

Alphabet, any finite set of symbols;
String, a finite sequence of symbols;
Language, any set of strings on an alphabet.
The sentences in a language may be defined by a set of rules called a grammar. 
 
A diagram of the operation of a typical multi-language, multi-target compiler
-
-
Polymorphism
Polymorphism nedir?
Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance. Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects.
•	At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays. When this occurs, the object's declared type is no longer identical to its run-time type.
•	Base classes may define and implement virtual methods, and derived classes can override them, which means they provide their own definition and implementation. At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method. Thus in your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.

The word polymorphism means having many forms. In object-oriented programming paradigm, polymorphism is often expressed as 'one interface, multiple functions'.
Polymorphism can be static or dynamic. In static polymorphism, the response to a function is determined at the compile time. In dynamic polymorphism, it is decided at run-time.


Instance Method = Non Static Method
Instance method nedir, instance method nedir, non static method nedir, non-static method nedir
Instance method bildiğin class'ın instance'ının sahip olduğu, bildiğimiz metodlardır. Static olmayan, bildiğimiz klasik metotlar.
Static Method	Non Static Method (Instance Method)
1. Static method is defined with the static keyword.	1. Non Static Method is defined without static keyword.
2. Static method is called by its class name	2. Non Static Method is called by making the object of a class.
3. We can’t use this keyword inside the Static Method	3. We can use thiskeyword inside Non Static Method
4. Static Method uses the memory of Class	4. Non Static Method uses a memory of an object


Instance method are methods which require an object of its class to be created before it can be called. To invoke a instance method, we have to create an Object of the class in within which it defined.
public void geek(String name)
{
 // code to be executed....
}
// Return type can be int, float String or user defined data type.
Memory allocation: These methods themselves are stored in Permanent Generation space of heap but the parameters (arguments passed to them) and their local variables and the value to be returned are allocated in stack. They can be called within the same class in which they reside or from the different classes defined either in the same package or other packages depend on the access type provided to the desired instance method.

Important Points:
•	Instance method(s) belong to the Object of the class not to the class i.e. they can be called after creating the Object of the class.
•	Every individual Object created from the class has its own copy of the instance method(s) of that class.
•	Instance methods are not stored on a per-instance basis, even with virtual methods. They’re stored in a single memory location, and they only “know” which object they belong to because the this pointer is passed when you call them.
•	They can be overridden since they are resolved using dynamic binding at run time. (dynamic binding'in runtime'da yapıldığını öğrenmiştik. metoda verilen argument'lerin zaten runtime'da değiştirilebildiğini biliyoruz.Yani buradan zaten bu sonuca kendimiz de varabiliriz: Bu bir Dynamic Binding olayıdır.


When to use static methods ??
•	When you have code that can be shared across all instances of the same class, put that portion of code into static method.
•	They are basically used to access static field(s) of the class.
 Instance method vs Static method
•	Instance method can access the instance methods and instance variables directly.
•	Instance method can access static variables and static methods directly.
•	Static methods can access the static variables and static methods directly.
•	Static methods can’t access instance methods and instance variables directly. They must use reference to object. And static method can’t use this keyword as there is no instance for ‘this’ to refer to.
References
•	https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html
•	Stackoverflow
This article is contributed by Nitsdheerendra. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

-
-
Static Method nedir? (GITHUB)
Static method nedir

A static method in C# is a method that keeps only one copy of the method at the Type level, not the object level. That means, all instances of the class share the same copy of the method and its data. The last updated value of the method is shared among all objects of that Type. 

Static methods are called by using the class name, not the instance of the class. 
 
The Console class and its Read and Write methods are an example of static methods. The following code example calls Console.WriteLine and Console.ReadKey methods without creating an instance of the Console class. 
C# supports two types of class methods, static methods, and non static methods. Any normal method is a non static method. 
1.	class Program  
2.	{  
3.	    public static void withoutObj()  
4.	    {  
5.	        Console.WriteLine("Hello");  
6.	    }  
7.	     static void Main()  
8.	    {  
9.	        Program. withoutObj();  
10.	        Console.ReadKey();  
11.	    }  
12.	}  

Using Static Method
Usually we define a set of data members for a class and then every object of that class will have a separate copy of each of those data members. Let's have an example.
1.	class Program  
2.	  {  
3.	      public int myVar;  //a non-static field  
4.	        static void Main()  
5.	      {  
6.	          Program p1 = new Program();  //a object of class  
7.	          p1.myVar = 10;  
8.	          Console.WriteLine(p1.myVar);  
9.	          Console.ReadKey();  
10.	      }  
11.	  }  

In the above example, myVar is a non-static field so to use this field we first need to create the object of that class. On the other hand, static data is shared among all the objects of that class. That is, for all the objects of a class, there will be only one copy of static data. Let's have an example.
1.	class Program  
2.	 {  
3.	     public static int myVar;  //a static field  
4.	       static void Main()  
5.	     {  
6.	         //Program p1 = new Program();  //a object of class  
7.	         myVar = 10;  
8.	         Console.WriteLine(myVar);  
9.	         Console.ReadKey();  
10.	     }  
11.	 }  
In the above we don't have an object of the class to use that field since the field is static.
If you create your own class and you think only one copy of the data (method) is needed among all instances of the class, you can create your own static method.  Learn more here: Static Class  and Static Class Members In C#
Notable Points here are:
1.	A static method can be invoked directly from the class level
2.	A static method does not require any class object
3.	Any main() method is shared through the entire class scope so it always appears with static keyword.
C# language also has several other types of methods. Read more Types of Methods in C#.
-
-
Static Class (GITHUB)
Static class nedir
A static class is a class which can not be instantiated. We do not need to create an object of a static class like we did in non-static classes. Members of static classes can be accessed directly using the class name followed by a (.) and class member name. Class Members can be methods, fields, properties, or events. A static class can contain only the static members while a non-static class can contain static members. Also, Static classes are by-default sealed so they cannot be inherited.

To declare a class and its members as static, 'static' keyword are used as shown below,
1.	using System;  
2.	  
3.	namespace Tutpoint  
4.	{  
5.	    // Static class  
6.	    static class TutLovers  
7.	    {  
8.	        // Static Variable  
9.	        public static int val_Static;  
10.	  
11.	        // Static Method  
12.	        public static void Addition_Static()  
13.	        {  
14.	            Console.Write("Static Method");  
15.	        }  
16.	  
17.	        // Static property  
18.	        public static int Addition_NonStatic  
19.	        {  
20.	            get; set;  
21.	        }  
22.	    }  
For more understanding see the example shown below,

The example shown below contains two non-static classes named "TutLovers" and "TutHaters". Here a class "TutLovers" contains static as well as non-static methods and variable. When we access them from class "TutHaters" then, For the static members, they will be accessed directly using class name followed by (.) and
For non-static members, we have created an object of that class.


1.	using System;  
2.	  
3.	namespace Tutpoint  
4.	{  
5.	    class TutLovers  
6.	    {  
7.	        public static int val_Static;  
8.	  
9.	        public int val_NonStatic;  
10.	  
11.	        public static void Addition_Static()  
12.	        {  
13.	            Console.Write("Static Method");  
14.	        }  
15.	  
16.	        public void Addition_NonStatic()  
17.	        {  
18.	            Console.Write("Non-Static Method");  
19.	        }  
20.	    }  
21.	  
22.	    //If the class is non-static  
23.	    class TutHaters  
24.	    {  
25.	        public void Haters()  
26.	        {  
27.	            //Object of TutLovers class is created  
28.	            TutLovers tutLovers = new TutLovers();  
29.	  
30.	            //Non-Static members can be called only from object  
31.	            tutLovers.Addition_NonStatic();  
32.	            tutLovers.val_NonStatic = 5;  
33.	  
34.	            //Static members can only be called using class_name followed by a (.)  
35.	            TutLovers.Addition_Static();  
36.	            TutLovers.val_Static = 5;  
37.	  
38.	            /* When we try to access static member from object then it will create an error  
39.	            Error as "Members 'TutLovers.Addition_Static()' can not be accessed with an instance referen            -ce; qualify it with a type name instead" */
40.	            tutLovers.Addition_Static();  
41.	  
42.	            /* When we try to access non-static member using class_name then it will create an error  
43.	            Error as "An object reference is required for the non-static field                                      , method or property 'TutLovers.Addition_NonStatic()'" */
44.	            TutLovers.Addition_NonStatic();  
45.	        }  
46.	    }  
47.	  
48.	}  
As shown above, when we try to access static member with an instance reference, it will create an error as "Members 'TutLovers.Addition_Static()' can not be accessed with an instance reference; qualify it with a type name instead" and when we try to access non-static member using class_name then it will create an error as "An object reference is required for the non-static field, method or property 'TutLovers.Addition_NonStatic()'".






-
-
AntiForgeryToken (GITHUB)
AntiForgeryToken nedir
“ValidateAntiForgeryToken” kısaca .NET platformunun dış saldırılara karşı aldığı, bilgi isteyen kişi gerçekten sen misin diye kontrol eden önlemidir.
Dizayn ettiğimiz siteye kullanıcılardan gelen isteklere (request), isteklerin doğruluğunu “Token”ler aracılığıyla anlayıp ona göre cevap verir. Sayfa Post edildiğinde Asp.Net Token post gövdesi içerisinde uzun ve karmaşık yapıda “Token” gönderir.
Bunu alan server tarafındaki controller’ımız kendisinde de bulunan token ile post ile gelen token’i karşılaştırır. Eğer tokenler eşleşiyorsa demektir ki request dışarıdan değil de; bizim uygulamamızdan geliyor   işleme devam edilir. Eğer eşleşme gerçekleşmiyorsa request gönderen karşı tarafa cevap (response) verilmez.
Kullanımı
-Controller- bölümümüzün başına
[ValidateAntiForgeryToken]
yazmamız gerekir.
Controller
[HttpPost]
[ValidateAntiForgeryToken]
public IActionResult Control()
{
 return View();
}
Tabi bununla birlikte View sayfasında form içerisine aşğıdaki kod parçacığını eklmemiz gerekiyor
@Html.AntiForgeryToken()
Hepsi bu kadar.
-
-
Virtual Method 	(GITHUB) (notread)
Virtual Method nedir

Virtual (sanal metod) ‘lar kalıtıldığı sınıflarda içeriği değiştirilebilen metodlardır. Yani temel sınfımız da bir method oluşturuyoruz. Bu methodun içeriğini ileride değiştirme ihtiyacı duyuyoruz bu gibi durumlarda methodumuza virtual anahtar kelimesini ekleyerek override (ezmek) etmeye olanak tanımış oluyoruz. Bir örnek ile anlatırsak daha iyi olabilir.
Virtual metodları aslında bir çok yerde kullanabiliriz, ama genel olarak kullanım şekilleri aşağıdaki gibidir.
•	Sadece metod isimlerini belirteceğimiz bir classımız olsun, metodların ne işlev yapacağını diğer classlarda belirtecek isek Virtual metod kullanırız.
•	Birden çok Class larımızın, aynı anlama gelen metodları varsa, bu metodu Virtual olarak tanımlarız.
•	Yazılımda standartlaşmak önemlidir, eğer geliştirilen uygulamamızın farklı modüllerinde, metod isimlerimizin aynı olması isteniyorsa, yine Virtual metod kullanırız.

Örneğimizi İnceleyelim;
public class Cizim
{
   public int sayi { get; set; }
    public virtual void Draw()
    {
        //Draw methodunu virtual olarak yazıyorum ki daha sonra içeriği değiştirilebilsin.
        Console.WriteLine("Ben cizim nesnesiyim");
     }
}
public class cizgi : Cizim
{
    public override void Draw()
    {
        //Override etmeden önceki kodu çalıştırç
        base.Draw();
        Console.WriteLine("Ben cizim nesnesiyim-----------------");
     }
}
Çıktısı;
 
Örneğimizde Çizim nesnesindeki Draw methodunu override ederek içeriğini değiştiriyoruz.
DETAY:
A virtual method is a method that can be redefined in derived classes. A virtual method has an implementation in a base class as well as derived the class. It is used when a method's basic functionality is the same but sometimes more functionality is needed in the derived class. A virtual method is created in the base class that can be overriden in the derived class. We create a virtual method in the base class using the virtual keyword and that method is overriden in the derived class using the override keyword.
 
When a method is declared as a virtual method in a base class then that method can be defined in a base class and it is optional for the derived class to override that method. The overriding method also provides more than one form for a method. Hence it is also an example for polymorphism.
 
When a method is declared as a virtual method in a base class and that method has the same definition in a derived class then there is no need to override it in the derived class. But when a virtual method has a different definition in the base class and the derived class then there is a need to override it in the derived class.
 
When a virtual method is invoked, the run-time type of the object is checked for an overriding member. The overriding member in the most derived class is called, which might be the original member, if no derived class has overridden the member.
Virtual Method in C#
1.	By default, methods are non-virtual. We can't override a non-virtual method.
2.	We can't use the virtual modifier with the static, abstract, private or override modifiers. 
Difference between virtual and non-virtual methods
 
We have two classes; one is a "Vehicle" class and another is a "Cart" class. The "Vehicle" class is the base class that has two methods; one is a virtual method "Speed()" and another is a non-virtual method "Average()". So the base class virtual method "Speed()" is overriden in the sub class. We have one more class "Program" (the execution class) that has an entry point where we create an instance of sub class "Cart" and that instance is assigned to the base class "Vehicle" type. When we call virtual and non-virtual methods by both class's instance then according to the run type the instance virtual method implementation is invoked; in other words both class's instances invoke the subclass override method and the non-virtual method invoked is determined based on the instance of the class.
1.	using System;  
2.	  
3.	namespace VirtualExample  
4.	{     
5.	    class Vehicle  
6.	    {     
7.	       public double distance=0.0;  
8.	       public double hour =0.0;  
9.	       public double fuel =0.0;   
10.	  
11.	       public Vehicle(double distance, double hour, double fuel)  
12.	       {  
13.	           this.distance = distance;  
14.	           this.hour = hour;  
15.	           this.fuel = fuel;  
16.	       }  
17.	  
18.	       public void Average()  
19.	       {  
20.	           double average = 0.0;  
21.	           average = distance / fuel;  
22.	           Console.WriteLine("Vehicle Average is {0:0.00}", average);  
23.	       }  
24.	  
25.	       public virtual void Speed()  
26.	       {  
27.	           double speed = 0.0;  
28.	           speed = distance / hour;  
29.	           Console.WriteLine("Vehicle Speed is {0:0.00}", speed);  
30.	       }  
31.	    }   
32.	  
33.	    class Car : Vehicle  
34.	    {  
35.	        public Car(double distance, double hour, double fuel)  
36.	            : base(distance, hour, fuel)  
37.	        {  
38.	        }  
39.	      public void Average()  
40.	        {  
41.	            double average = 0.0;  
42.	            average = distance / fuel;  
43.	            Console.WriteLine("Car Average is {0:0.00}", average);  
44.	        }  
45.	  
46.	        public override void Speed()  
47.	        {  
48.	            double speed = 0.0;             
49.	            speed = distance / hour;  
50.	            Console.WriteLine("Car Speed is {0:0.00}", speed);  
51.	        }  
52.	    }   
53.	  
54.	    class Program  
55.	   {  
56.	        static void Main(string[] args)  
57.	        {  
58.	             double distance,hour,fuel=0.0;  
59.	             Console.WriteLine("Enter the Distance");  
60.	             distance = Double.Parse(Console.ReadLine());  
61.	             Console.WriteLine("Enter the Hours");  
62.	             hour = Double.Parse(Console.ReadLine());  
63.	             Console.WriteLine("Enter the Fuel");  
64.	             fuel = Double.Parse(Console.ReadLine());  
65.	             Car objCar = new Car(distance,hour,fuel);  
66.	             Vehicle objVeh = objCar;  
67.	             objCar.Average();  
68.	             objVeh.Average();  
69.	             objCar.Speed();  
70.	             objVeh.Speed();  
71.	            Console.Read();  
72.	        }         
73.	    }  
74.	}   
 


Invoked Virtual Method that override and not override in derived classes
 
We have three classes "Shape","Rectangle" and "Circle". Class "Shape" is a base class. Both "Rectangle" and "Circle" are derived classes from the base class. Base class "Shape" has virtual method "Area()". Virtual method "Area()" is overriden in the derived class "Rectangle" but not overriden in the derived class "Circle". When the virtual methods are overriden in a derived class and that derived class uses an instance then invokes a derived class overriden method. When a virtual method is not overriden in a derived class and uses that derived class instance then invokes base class virtual method.
1.	using System;  
2.	  
3.	namespace VirtualExample  
4.	{     
5.	    class Shape  
6.	    {     
7.	       public double length=0.0;  
8.	       public double width =0.0;  
9.	       public double radius =0.0;   
10.	  
11.	       public Shape(double length, double width)  
12.	       {  
13.	           this.length = length;  
14.	           this.width = width;            
15.	       }  
16.	  
17.	       public Shape(double radius)  
18.	       {  
19.	           this.radius = radius;  
20.	       }  
21.	  
22.	       public  virtual void Area()  
23.	       {            
24.	           double area = 0.0;  
25.	           area = Math.PI * Math.Pow(radius, 2);  
26.	           Console.WriteLine("Area of Shape is :{0:0.00} ", area);  
27.	       }  
28.	    }   
29.	  
30.	    class Rectangle  : Shape  
31.	    {  
32.	  
33.	        public Rectangle(double length, double width): base(length, width)  
34.	        {  
35.	        }      
36.	  
37.	        public override void Area()  
38.	        {  
39.	            double area = 0.0;  
40.	            area = length * width;  
41.	            Console.WriteLine("Area of Rectangle is :{0:0.00} ", area);  
42.	        }  
43.	    }  
44.	     class Circle : Shape  
45.	    {  
46.	        public Circle(double radius)  
47.	            : base(radius)  
48.	        {  
49.	        }  
50.	    }    
51.	  
52.	    class Program  
53.	    {  
54.	        static void Main(string[] args)  
55.	        {  
56.	             double length,width,radius=0.0;  
57.	             Console.WriteLine("Enter the Length");  
58.	             length = Double.Parse(Console.ReadLine());  
59.	             Console.WriteLine("Enter the Width");  
60.	             width = Double.Parse(Console.ReadLine());  
61.	             Rectangle objRectangle = new Rectangle(length, width);  
62.	              objRectangle.Area();  
63.	             Console.WriteLine("Enter the Radius");  
64.	             radius = Double.Parse(Console.ReadLine());  
65.	             Circle objCircle = new Circle(radius);  
66.	             objCircle.Area();  
67.	            Console.Read();  
68.	        }         
69.	    }  
70.	} 
-
-
Command Line Interface / CLI (GITHUB)
Command Line Interface nedir, cli nedir, CLI nedir

Örneğin windows'taki CLI, şu siyah ekrana sahip olan, içinde sadece kodlar bulunan, içine sadece kodlar yazılan o ekrandır. 

CLI stands for:

Command Line Interface
Command Line Interpreter
Command Line Input
Command Line Input
CLI is a command line program that accepts text input to execute operating system functions.

In the 1960s, using only computer terminals, this was the only way to interact with computers.

In the 1970s an 1980s, command line input was commonly used by Unix systems and PC systems like MS-DOS and Apple DOS.

Today, with graphical user interfaces (GUI), most users never use command-line interfaces (CLI).

However, CLI is still used by software developers and system administrators to configure computers, install software, and access features that are not available in the graphical interface.

Examples
The software package manager npm uses command line input to install software:

Windows Example
C:\>npm install mysoftware
Mac OS Example
>npm install mysoftware
You can navigate your folders (directories) with command line commands:

Windows Example
C:\Users\myuser>cd ..
C:\Users\>cd ..
C:\>
Use CLI commands with great attention!!!

Wrong use can easily delete files or destroy your computer system completely.

Basic Linux CLI Commands
Command	Description
ls	List the directory (folder) system.
cd pathname	Change directory (folder) in the file system.
cd ..	Move one level up (one folder) in the file system.
cp	Copy a file to another folder.
mv	Move a file to another folder.
mkdir	Creates a new directory (folder).
rmdir	Remove a directory (folder).
clear	Clears the CLI window.
exit	Closes the CLI window.
man command	Shows the manual for a given command.
Basic Windows CLI Commands
Command	Description
dir	List the directory (folder) system.
cd pathname	Change directory (folder) in the file system.
cd \	Move to the root folder of the file system.
cd ..	Move one level up (one folder) in the file system.
copy	Copy a file to another folder.
move	Move a file to another folder.
type filename	Type a file.
mkdir or md	Creates a new directory (folder).
rmdir or rd	Removes a directory (folder).
cls	Clears the CLI window.
exit	Closes the CLI window.
help command	Shows the manual for a given command.
-
-
JIT Compiler (Just-In-Time Compiler)	(GITHUB) (not yet)
JIT Compiler nedir, jit compiler nedir, jit nedir
JIT compiler is a component of the Java Runtime Environment that improves the performance of Java applications at run time. Nothing in the JVM affects performance more than the compiler, and choosing a compiler is one of the first decisions made when running a Java application—whether you are a Java developer or an end-user.
-
-
Integration (GITHUB)  (read)
integration nedir
Integration is the act of bringing together smaller components into a single system that functions as one. In an IT context, integration refers to the end result of a process that aims to stitch together different, often disparate, subsystems so that the data contained in each becomes part of a larger, more comprehensive system that, ideally, quickly and easily shares data when needed. This often requires that companies build a customized architecture or structure of applications to combine new or existing hardware, software and other communications.

Integration is harder to achieve the greater the number of systems that are involved and companies often choose to have external contractors manage some or all phases of the development of the new system. Specific activities having to do with IT system integration include project planning, project management, design and implementation of application programming interfaces, Web services and any process that accounts for the free flow of data or information delivery.
Challenges to achieving integration mostly have to do with the inherent difficulties in linking a series of diverse existing systems that could be produced by multiple different manufacturers. Other integration challenges have to do with the lack of a coherent or unifying data structure linking all of the different systems, an unwieldy framework of multiple different applications and support systems, the sheer age of the different systems and the actual delivery of the information to key business units that need it. These integration challenges hinder overall process efficiency because poor data exchange between systems prevents quick communication among business units.
-
-
On-premises Software  	(GITHUB)
on premises software nedir, on-premises software nedir, on premise software nedir, on premise nedir
-Şirket içi yazılımlar, sunucu çiftliği veya bulut gibi uzak bir tesise değil, yazılımı kullanan kişi veya kuruluşun tesislerine yüklenir ve bilgisayarlarda çalışır.
Bildiğin "yerel" yani.
On-premises software (commonly misstated as on-premise, and alternatively abbreviated "on-prem")[1] is installed and runs on computers on the premises of the person or organization using the software, rather than at a remote facility such as a server farm or cloud. On-premises software is sometimes referred to as “shrinkwrap” software, and off-premises software is commonly called “software as a service” ("SaaS") or “cloud computing”.
Grammar
There is some debate as to the grammatical correctness of the term on-premise as a synonym for on-premises.[2][3][4] In normal English usage, a premise is a proposition or presupposition in a logical argument, while premises (as well as being the plural of premise) means a property and its grounds, and is used only in the plural form.[5] People have mistakenly used what they believe to be the singular form premise, yet such use is incorrect in common or legal contexts.[6] When referring to technology, many companies and news sources commonly misuse the term on-premise such that it has become a common variant of on-premises.[7] [8]
-
-
CLR	(GITHUB) (not yet)
CLR nedir
Common Language Runtime.
The exact meaning depends on the context, but Common Language Runtime usually refers to the runtime of .NET Framework. The CLR handles memory allocation and management. The CLR is also a virtual machine that not only executes apps but also generates and compiles code on-the-fly using a JIT compiler. The current Microsoft CLR implementation is Windows only.
.Net Framework ün en alt katmanında CLR (Common Languange Runtime – Ortak Dil Platformu) mevcuttur. 
.Net platformunda yazılmış olan kodların (c#, J# veya VB) ortak bir alanda işletim sisteminizin algılayacağı dile çevrilmesini sağlamaktadır. Bu işlem sırasında kodlar ilk olarak MSIL (Microsoft Intermediate Languange – Ara Dil) e çevrilir. Bu dönüştürmenin sebebi işletim sisteminin algılayacağı dile dönüştürmeden önce farklı dillerde yazılan kodları ortak noktada buluşturmaktır. Böylelikle MSIL kodu CLR katmanı ile farklı işletim sistemlerinde çalıştırılabilir hale gelir ve gelecekte yeni bir dille yazılan kodlar da MSIL a dönüştürerek işletim sisteminde çalışmasını sağlayacaktır.
-
-
ByteCode	(GITHUB) (not yet)
ByteCode nedir
Bytecode is program code that has been compiled from source code into low-level code designed for a software interpreter. It may be executed by a virtual machine (such as a JVM) or further compiled into machine code, which is recognized by the processor.
Different types of bytecode use different syntax, which can be read and executed by the corresponding virtual machine. A popular example is Java bytecode, which is compiled from Java source code and can be run on a Java Virtual Machine (JVM). Below are examples of Java bytecode instructions.
new (create new object)
aload_0 (load reference)
istore (store integer value)
ladd (add long value)
swap (swap two values)
areturn (return value from a function)
While it is possible to write bytecode directly, it is much more difficult than writing code in a high-level language, like Java. Therefore, bytecode files, such as Java .CLASS files, are most often generated from source code using a compiler, like javac.

Bytecode vs Assembly Language
Bytecode is similar to assembly language in that it is not a high-level language, but it is still somewhat readable, unlike machine language. Both may be considered "intermediate languages" that fall between source code and machine code. The primary difference between the two is that bytecode is generated for a virtual machine (software), while assembly language is created for a CPU (hardware).
The key of java power "Write once, run everywhere" is bytecode. The way bytecodes get converted to the appropriate native instructions for an application has a huge impact on the speed of an application. These bytecode can be interpreted, compiled to native code or directly executed on a processor whose Instruction Set Architecture is the bytecode specification. Interpreting the bytecode which is the standard implementation of the Java Virtual Machine (JVM) makes execution of programs slow. To improve performance, JIT compilers interact with the JVM at run time and compile appropriate bytecode sequences into native machine code. When using a JIT compiler, the hardware can execute the native code, as opposed to having the JVM interpret the same sequence of bytecode repeatedly and incurring the penalty of a relatively lengthy translation process. This can lead to performance gains in the execution speed, unless methods are executed less frequently. The time that a JIT compiler takes to compile the bytecode is added to the overall execution time, and could lead to a higher execution time than an interpreter for executing the bytecode if the methods that are compiled by the JIT are not invoked frequently. The JIT compiler performs certain optimizations when compiling the bytecode to native code. Since the JIT compiler translates a series of bytecode into native instructions, it can perform some simple optimizations. Some of the common optimizations performed by JIT compilers are data-analysis, translation from stack operations to register operations, reduction of memory accesses by register allocation, elimination of common sub-expressions etc. The higher the degree of optimization done by a JIT compiler, the more time it spends in the execution stage. Therefore a JIT compiler cannot afford to do all the optimizations that is done by a static compiler, both because of the overhead added to the execution time and because it has only a restricted view of the program.
-
-
Memory Allocation	(GITHUB) (not yet)
Memory Allocation nedir
What does Memory Allocation mean?
Memory allocation is a process by which computer programs and services are assigned with physical or virtual memory space.

Memory allocation is the process of reserving a partial or complete portion of computer memory for the execution of programs and processes. Memory allocation is achieved through a process known as memory management.
Memory allocation is primarily a computer hardware operation but is managed through operating system and software applications. Memory allocation process is quite similar in physical and virtual memory management. Programs and services are assigned with a specific memory as per their requirements when they are executed. Once the program has finished its operation or is idle, the memory is released and allocated to another program or merged within the primary memory.
Memory allocation has two core types;
Static Memory Allocation: The program is allocated memory at compile time.
Dynamic Memory Allocation: The programs are allocated with memory at run time.
-
-
Nesne Yönelimli Olmayan Diller (GITHUB)
Nesne Yönelimli Olmayan Diller nedir
Temel olarak 
•	C
•	FORTRAN
•	COBOL
•	PASCAL
•	BASIC
Daha pek çok dil sayılabilir. Modern dillerin tamamı OOP'tur. 
Nesne yönelimli diller  listesi haricindeki tüm diller demek daha kolay.
-
-
Executable Code (GITHUB)
Executable Code nedir
Software in a form that can be run in the computer. Executable code generally refers to machine language, which is the set of native instructions the computer carries out in hardware. Executable files in the DOS/Windows world use .EXE and .COM file extensions, while executable files in Mac, Linux and Unix do not require specific extensions. They are identified by their file structure.

Executable code may also refer to programs written in interpreted languages that require additional software to actually execute. Some interpreted languages remain in their source code form, such as JavaScript and VBScript, while others are compiled into an intermediate language, such as Java and Visual Basic. Interpreted languages require software "runtime engines" to convert the program into executable instructions for a particular CPU family that the hardware executes. See machine language, runtime engine, linker, compiler, intermediate language, x86 and Java Virtual Machine.
-
-
J# (GITHUB)
J# nedir 
Visual J# (pronounced "jay-sharp") is an implementation of the J# programming language that was a transitional language for programmers of Java and Visual J++ languages, so they could use their existing knowledge and applications with the .NET Framework.[1][2] It was introduced in 2002 and discontinued in 2007, with support for the final release of the product continuing until October 2017.
Fundamental differences between J# and Java
Java and J# use the same general syntax but there are non-Java conventions in J# to support the .NET environment. For example, to use .NET "properties" with a standard JavaBean class, it is necessary to prefix getter and setter methods with the Javadoc-like annotation:            /** @beanproperty   */ 
J# does not compile Java-language source code to Java bytecode.
JavaWorld said: "J#'s interface to the .NET framework is solid, but not as seamless as C#. In particular, J# code cannot define new .NET attributes, events, value types, or delegates. J# can make use of these language constructs if they are defined in an assembly written in another language, but its inability to define new ones limits J#'s reach and interoperability compared to other .NET languages."[5]
-
-
microservices (GITHUB)  (Read)
microservice nedir, monolithic nedir, monolithic software nedir
Microservice: Bir pattern'dir. Bilgisayar sistemlerini servisler şeklinde verme.
What are microservices?
Microservices - also known as the microservice architecture - is an architectural style that structures an application as a collection of services that are
•	Highly maintainable and testable
•	Loosely coupled
•	Independently deployable
•	Organized around business capabilities
•	Owned by a small team
The microservice architecture enables the rapid, frequent and reliable delivery of large, complex applications. It also enables an organization to evolve its technology stack.
-
-
Statik Tipli Diller İle Dinamik Tipli Diller Arasındaki Farklar 	(edited,ekle) (Read)
Statik tipli dil nedir, statik tipli diller nedir, statik dil nedir
Programlama dillerinde yapılan her işlem öncesi hataları önlemek için verilerin tip kontrolü yapılır. Bu tür kontrollere ”Checking”  adı verilir. Checking işlemleri compile-time (derleme esnasında) veya run-time (çalışma esnasında) olarak yapılır. 

İşte bu farklılık Statik Tipli ve Dinamik Tipli dillerin temel ayrım noktalarından biridir.

Statik Tipli dillerde her değişkenin değişmez bir tipi olmak zorundadır. Uygulama geliştirenler ya bu tipi bizzat belirler yada Derleyici tarafından belirlenir. 

Statik Tipli dillerde yapılan işlemlerden önce Tip Konrolü yapıldığı için, operandların tiplerinin belirlenmesi gerekir. Tip kontrolleri compile (derleme) esnasında yapılır. 
Bu tarz dillere örnek olarak Java, C, C++ ,C# ,F# ,Ada ,Fortran ,Haskell ,ML ,Objective-C ,Pascal dilleri verilebilir.

Dinamik Tipli dillerde değerler değişmez bir tipe sahiptir. Ancak değişkenler ve ifadelerin belirli bir tipe sahip olma zorunlulukları yoktur (what). Her bir işlem esnasında, operandlar değişik değerler üretebilir. Değişkenlerin ve ifadelerin tipleri run-time (çalışma) esnasında belirlenir. 

Bu tarz dillere örnek olarak Groovy, Javascript, Lisp, Lua, PHP, Prolog, Python, Ruby, Smalltalk dilleri verilebilir.

Statik Tipli Diller ile Dinamik Tipli dillerin birbirlerine üstünlükleri konusunda birçok fikir ortaya atılıyor. İkisinin de birbirlerine üstün oldukları noktalar var.

Statik Tipli dillerde derleme (compile-time) esnasında tip kontrolü yapıldığı için programın çalışması esnasında ekstra tip kontrolü yapılmaz, bu da uygulamanın çok daha verimli ve hızlı çalışması anlamına gelir. 

Dinamik Tipli dillerde ise çalışma (run-time) esnasında kontrol yapılması ufak da olsa bir yavaşlamaya sebep olmaktadır. Ayrıca yine bu özellikten dolayı her değişkenin tip bilgisi hafızada saklanmak zorundadır. Bu durum ekstra bir hafıza yükü anlamına gelir. Statik Tipli dillerde derleme (compile-time) esnasında tip kontrolü yapıldığı için ekstra bir hafızaya gerek duyulmaz.

Statik Tipli dillerde derleme (compile-time) esnasında herhangi bir hata yakalanmadı ise tip hatası oluşmamış demektir yani Dinamik Tipli dillere nazaran çok daha güvenlidir. Dinamik Tipli dillerde ise böyle bir kesinlik bulunmaz. 

Öte yandan Dinamik Tipli diller Developer’lara çok büyük esneklik sağlar. Gelen verinin türünün bilinmediği uygulamalarda çok kullanışlıdır. Ayrıca uygulama geliştirenler bir değişkene farklı noktalarda farklı değerler atayabilirler.

Dynamic typing vs. static typing
This topic is provided for reverence only as it explains the differences between dynamic and static typing. Understanding the differences between dynamic and static typing is key to understanding the way in which transformation script errors are handled, and how it is different from the way Groovy handles errors. This will also help you interpret errors created by your transformation script.
Note: It is important to know that the Groovy implementation within Big Data Discovery enforces static typing. For information on exception handling in Transform, which uses a static parser overriding Groovy's dynamic typing behavior, see Exception handling and troubleshooting your scripts.
There are two main differences between dynamic typing and static typing that you should be aware of when writing transformation scripts.
First, dynamically-typed languages perform type checking at runtime, while statically typed languages perform type checking at compile time. This means that scripts written in dynamically-typed languages (like Groovy) can compile even if they contain errors that will prevent the script from running properly (if at all). If a script written in a statically-typed language (such as Java) contains errors, it will fail to compile until the errors have been fixed.
Second, statically-typed languages require you to declare the data types of your variables before you use them, while dynamically-typed languages do not. Consider the two following code examples:
// Java example
int num;
num = 5;
// Groovy example
num = 5
Both examples do the same thing: create a variable called num and assign it the value 5. The difference lies in the first line of the Java example, int num;, which defines num's data type as int. Java is statically-typed, so it expects its variables to be declared before they can be assigned values. 
Groovy is dynamically-typed and determines its variables' data types based on their values, so this line is not required.
Dynamically-typed languages are more flexible and can save you time and space when writing scripts. However, this can lead to issues at runtime. For example:
// Groovy example
number = 5
numbr = (number + 15) / 2  // note the typo
The code above should create the variable number with a value of 5, then change its value to 10 by adding 15 to it and dividing it by 2. However, number is misspelled at the beginning of the second line. Because Groovy does not require you to declare your variables, it creates a new variable called numbr and assigns it the value number should have. This code will compile just fine, but may produce an error later on when the script tries to do something with number assuming its value is 10.
Güzel anlatım:
What is static typing? And what’s dynamic typing? I’ll answer both questions in this introductory article, and we’ll discuss the debate surrounding the very definition of these concepts.
You do not have to know any particular programming language to understand the concepts; however, I shall make references to the programming language Perl, PHP and Python, (in the form of codes) in the article. Those who don’t know Python should think of the code as pseudocode, and things will just be fine. Static typing and dynamic typing are the concerns of programming language design; thus a lack of knowledge of any particular type is not going to harm your understanding of these concepts. In all the code fragments within this article, I have explicitly mentioned the programming language in which the code is written, using "/*……*/" (quotes not included).
To begin with, I should mention that "typing" in terms of static and dynamic typing refers to "type" as in data type — not the process of pressing keys on a keyboard. Though this might have sounded quite obvious, it may not be to some. "Static" and "dynamic" are the types of "typing" that we shall see in the sections that follow. Languages that have static typing or dynamic typing are said to be "static typed" or "dynamic typed".
Static Typing
Static typed programming languages are those in which variables need not be defined before they’re used. This implies that static typing has to do with the explicit declaration (or initialization) of variables before they’re employed. Java is an example of a static typed language; C and C++ are also static typed languages. Note that in C (and C++ also), variables can be cast into other types, but they don’t get converted; you just read them assuming they are another type.
Static typing does not imply that you have to declare all the variables first, before you use them; variables maybe be initialized anywhere, but developers have to do so before they use those variables anywhere. Consider the following example:
/* C code */ 
static int num, sum; // explicit declaration 
num = 5; // now use the variables 
sum = 10; 
sum = sum + num;
The above code fragment is an example of how variable declaration in static typed languages generally appears. Note that in the above code, static has nothing to do with static typing; it has been used along with int only to initialize num and sum to zero.
Dynamic Typing
Dynamic typed programming languages are those languages in which variables must necessarily be defined before they are used. This implies that dynamic typed languages do not require the explicit declaration of the variables before they’re used. Python is an example of a dynamic typed programming language, and so is PHP. Consider the following example:
/* Python code */ 
num = 10 // directly using the variable
In the above code fragment, we have directly assigned the variable num the value 10 before initializing it. This is characteristic to dynamic typed programming languages.
Another Analogy
A lot of people define static typing and dynamic typing with respect to the point at which the variable types are checked. Using this analogy, static typed languages are those in which type checking is done at compile-time, whereas dynamic typed languages are those in which type checking is done at run-time.
This analogy leads to the analogy we used above to define static and dynamic typing. I believe it is simpler to understand static and dynamic typing in terms of the need for the explicit declaration of variables, rather than as compile-time and run-time type checking.
Static Typing and Dynamic Typing versus Strong Typing and Weak Typing
Static and dynamic typing, and strong and weak typing, are two totally different concepts, which, unfortunately, are very often confused. It is erroneous to say that a language that is static or dynamic typed cannot be strong or weak typed. Static and dynamic typing, and strong and weak typing, are different forms of classification of programming languages, and one of each class necessarily characterizes a given language. It is thus imperative to discuss strong and weak typing vis-a-vis static and dynamic typing.
Programming languages that exhibit "strong typing" are "strong typed," and those that exhibit "weak typing" are "weak typed".
Strong Typing
Programming languages in which variables have specific data types are strong typed. This implies that in strong typed languages, variables are necessarily bound to a particular data type. Python is strong typed, and so is Java. The distinction between strong typing and weak typing is more subtle and thus more difficult to grasp than is the distinction between static typing and dynamic typing. Consider the following example:
/* Python code */ 
>>> foo = "x" 
>>> foo = foo + 2 
Traceback (most recent call last): 
  File "<pyshell#3>", line 1, in ? 
    foo = foo + 2 
TypeError: cannot concatenate 'str' and 'int' objects 
>>>
In the above Python example (run from the Python shell), foo is of str type. In the second line, we’re attempting to add 2 (an int) to a variable of str type. As we can see, a TypeError is returned, indicating that a str object cannot be concatenated with an int object. This is what characterizes strong typed languages: variables are bound to a particular data type.
Weak Typing
As opposed to strong typed languages, weak typed languages are those in which variables are not of a specific data type. It should be noted that this does not imply that variables do not have types; it does mean that variables are not "bound" to a specific data type. PHP and C are examples of weak typed languages. Consider the following:
/* PHP code */ 
<?php 
$foo = "x"; 
$foo = $foo + 2; // not an error 
echo $foo; 
?>
In this example, foo is initially a string type. In the second line, we add this string variable to 2, an integer. This is permitted in PHP, and is characteristic of all weak typed languages.
Now that we know about the two concepts, we can augment both of them to characterize any given language. Thus, Python is dynamic typed and strong typed; Java is static typed and strong typed; PHP is dynamic typed and weak typed; C is static typed and weak typed (owing to its casting ability).
Dynamic Typing is Good
In a dynamic typed language, you don’t have to initialize variables, which is a big bonus for many developers. Programmers like the fact that you can use a variable at will when required (without having to initialize it). Dynamic typing is characteristic of many of the scripting languages: Perl, PHP, Python, etc. Dynamic typing, in fact, does save you from writing a few "extra" lines of code, which, in turn, means less time spent writing code.
Or Is It?
  



 
The very characteristic of dynamic typed languages that appeals to many developers is also a pitfall, and a major one at that. Consider the following simple example:
/* Python code */ 
my_variable = 10 
while my_variable > 0: 
        i = foo(my_variable) 
        if i < 100: 
                my_variable++ 
        else 
                my_varaible = (my_variable + i) / 10 // spelling error intentional
As you can see in the above code, my_varaible is a spelling mistake that the programmer could have very well made. The problem here is that, since Python is dynamically typed, it will not return an error, but instead will create a new variable called my_varaible. So, now we have two variables: my_variable and my_varaible. This obviously is a serious problem; some would suggest that forced variable declaration is an important requirement in any programming language.
Static Typed Behavior in Dynamic Typed Languages
Perl is a dynamic typed programming language. However, it provides a means to "simulate" static typing by means of a pragma called strict. Consider the following Perl example:
/* Perl code */ 
$sum = 10; 
print $sum;
The above code will run without any problem, and will print 10 to the console. Note that here, we have not initialized the variable sum; this exemplifies the dynamic typing characteristic of Perl. To enforce variable declaration, we make use of the strict pragma as follows:
/* Perl code */ 
use strict; 
$sum = 10; 
print $sum;
The above code fragment will return the following error when you try to run it:
Global symbol "$num" requires explicit package name at perl.pl line 2. 
Execution of perl.pl aborted due to compilation errors.
To rectify the above error, we are forced to declare the variable num as follows:
/* Perl code */ 
use strict; 
my $num; // forced declaration 
$sum = 10; 
print $sum;
The above codes are specific to Perl; not all programming languages have a way to enforce variable declaration: Python, for example doesn’t have a way to enforce variable declaration. However, there is a tool, called "pychecker" (available here), that can be used to "detect" stray variables; this is, of course, far from a desirable solution.
Static Typed or Dynamic Typed?
There are advocates of both forms of typing. Asserting that one is better than the other would only lead to a debate of no consequence.
There are those who advocate dynamic typing for the simplicity and saving in terms of time that it offers; they believe that type checking need not be an integral part of the programming language design per se, but instead, that third-party solutions (like pychecker) could be used to server that purpose.
On the other hand, there are advocates of static typing, who believe that static typing (leading to forced variable declaration) is an important requirement of programming language design.
Conclusion
Static typing and dynamic typing, and strong and weak typing, are topics of programming language design that are not always clearly defined and, as a result, are not very well understood. This article has given you an insight into the concepts of static and dynamic typing as well as strong and weak typing.
-
-
Entity Framework için constructor (GITHUB)
Entity Framework için constructor

class User(
..
..
public User(bilmemNe bilmemNe){
}

protected User(){
}

)

içine parametre alan bir constructor oluşturmuşsan eğer:

parametresiz bir constructor da oluşturmalısın. Boş kalsın. Neden bunu yapmamız gerekiyor?

Entity framework, User class'ının instance'ını bu parametreli constructor'u kullanarak oluşturamaz da ondan. Bir düşün. Entity framework nasıl instance oluştursun (veya obje initialize etsin) eğer boş bir constructor yoksa?

O yüzden,

Boş ctor oluşturmamız gerekiyor. Bu boş ctor wrong state'e girmemize yol açabilir. Yani boş olan ctor bazı sıkıntılara yol açabilir. O yüzden boş ctor'u protected yapabiliriz. Çok iyi olur.
-
Navigation Property (GITHUB)
Navigation property nedir
A navigation property is an optional property on an entity type that allows for navigation from one end of an association to the other end. Unlike other properties, navigation properties do not carry data.
A navigation property definition includes the following:
•	A name. (Required)
•	The association that it navigates. (Required)
•	The ends of the association that it navigates. (Required)
Önemli:
Navigation properties are optional on both entity types at the ends of an association. If you define a navigation property on one entity type at the end of an association, you do not have to define a navigation property on the entity type at the other end of the association.
The data type of a navigation property is determined by the multiplicity of its remote association end. For example, suppose a navigation property, OrdersNavProp, exists on a Customer entity type and navigates a one-to-many association between Customer and Order. Because the remote association end for the navigation property has multiplicity of many (*), its data type is a collection (of Order). Similarly, if a navigation property, CustomerNavProp, exists on the Order entity type, its data type would be Customer, because the multiplicity of the remote end is one (1).
-
ERRORS  (GITHUB)
404: Links that don’t lead anywhere are known as 'dead links' or 'broken links'. The HTTP status code 404 is often referred to as 'error 404', 'HTTP 404', or '404 code'.
The typical trigger for an error 404 message is when website content has been removed or moved to another URL. There are also other reasons why an error message could appear. These include:

The URL or its content (such as files or images) was either deleted or moved (without adjusting any internal links accordingly)
The URL was writtenincorrectly (during the creation process or a redesign), linkedincorrectly, or typed into the browser incorrectly
The server responsible for the website is not running or the connection is broken
The requested domain name can’t be converted to an IP by the domain name system (DNS)
The entered domain name doesn’t exist (anymore)
-
test
-

public static string trKarakterDuzelt(string duzenlenecek)
{
    var sb = new StringBuilder(duzenlenecek);
    sb.Replace('ü', 'u');
    sb.Replace('ğ', 'g');
    sb.Replace('ş', 's');
    sb.Replace('ç', 'c');
    sb.Replace('ö', 'o');
 
    sb.Replace('Ü', 'U');
    sb.Replace('Ğ', 'G');
    sb.Replace('Ş', 'S');
    sb.Replace('Ç', 'C');
    sb.Replace('Ö', 'O');
    return sb.ToString();

-
-
HTTPGet vs HTTPPost	(GITHUB) 
Httpget nedir httppost nedir
https://www.youtube.com/watch?v=Un2JTC7tFPI
Videoyu izle…
Get yapınca veriler url ye yazılır. Post ta ise form yollanır… Url ile yollanmaz veri. Message body içinde yollanır.
Get metotlara url'ye yazıp enter yaparak ulaşılır. O yüzden tehlikeli olabilir…
DB'deki değerleri hem Get hem Post ile değiştirebiliriz tabi ki. Ama dediğimiz gibi get ile bunu yapmak tehlikelidir.

HTTPPost method hides information from URL and does not bind data to URL. It is more secure than HttpGet method but it is slower than HttpGet. It is only useful when you are passing sensitive information to the server.
The GET Method
GET is used to request data from a specified resource. 
GET is one of the most common HTTP methods. 
Note that the query string (name/value pairs) is sent in the URL of a GET request: 
/test/demo_form.php?name1=value1&name2=value2
Some other notes on GET requests: 
GET requests can be cached
GET requests remain in the browser history
GET requests can be bookmarked
GET requests should never be used when dealing with sensitive data
GET requests have length restrictions
GET requests are only used to request data (not modify)

The POST Method
POST is used to send data to a server to create/update a resource. 
The data sent to the server with POST is stored in the request body of the HTTP request: 
POST /test/demo_form.php HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
(yukarıda request body'nin neye benzediğini görmüş olduk. Get request'lerde request body yoktur. Veri url'den gönderilir)
Some other notes on POST requests:
POST requests are never cached
POST requests do not remain in the browser history
POST requests cannot be bookmarked
POST requests have no restrictions on data length

GET methodu HTTP istekleri arasındaki varsayılan yöntemdir.  GET metodu ile yapılan istekler tarayıcının adres satırında görünür. Sadece belirli boyutta veri gönderileceği zaman kullanılır.
POST metodu ise URL’ de görünmesini istemediğimiz veriler olduğunda kullanılabilir. POST yönteminde gönderebileceğimiz verinin boyutu ile ilgili bir sınır yoktur. Ayrıca gönderdiğimiz parametrelerin adres satırında görünmemesi dolayısıyla GET yöntemine göre daha güvenlidir. HTML form gönderileceği zaman neredeyse her zaman POST yöntemi tercih edilir.
Örnek vermek gerekirse Kisilers tablomuzun olduğu bir proje üzerinde kişi bilgilerini düzenlemek isteyebiliriz. Bunun için genellikle iki Action oluştururuz. Bunlardan biri kişinin ID sini parametre olarak alan gelen ID ye göre kişinin bilgilerini Edit formunda açan Action iken diğeri POST olduğunda yani Kaydet butonuna tıklandığında kullanılacak Actiondur.

public ActionResult Edit(int? id)
{
if (id == null)
{  return new HttpStatusCodeResult(HttpStatusCode.BadRequest);  } 
Kisiler kisiler = db.Kisilers.Find(id);
if (kisiler == null) 
{
return HttpNotFound();
}
return View(kisiler);
} 
Yukarıda ki Action’ da querystring’imiz kisa iken aşağıdakinde Kisilers tablosundaki kolon sayısına göre uzunluğu değişecek bir querystring söz konusu. Ayrıca buradan dönen bilgilerinde adres çubuğunda görünmesini istemediğimiz için POST methodunu kullanırız.

Önemli:
Browsers can cache GET requests, generally on static data, like images or scripts. But you can also allow browsers to cache GET requests to controller actions as well, using [OutputCache] or other similar ways, so if caching is turned on for a GET controller action, it's possible that clicking on a link leading to /Home/Index doesn't actually run the Index method on the server, but rather allows the browser to serve up the page from its own cache.
With this line of thinking, you can safely turn on caching on GET actions in which the data you're serving up doesn't change (or doesn't change often), with the knowledge that your server action won't fire every time.
POSTs won't be cached by the browser, so any POST is guaranteed to make it to the server.

Güzel bir açıklama:
Ignore caching for a moment. Another way of thinking about this is that search engines will store HTTP GET links during their indexing/crawling process, therefore they will show up in search results.
Suppose if your /Home/Index is implemented as GET but it lets say deletes a row in your Database, every time this link shows up on a search engine and somebody clicks it, you will have a delete row, and soon you have a lot deleted rows.
-
-
-
-
-
-
Mutable / Immutable
Mutable nedir, immutable nedir:
Mutable and Immutable ?
In English Language Mutable means "can change" and immutable means "cannot change". The term Immutable Object means that the state of the Object cannot change after its creation. An immutable type sets the property or state of the object as read only because it cannot be modified after it is assigned during initialization.
Is String in .Net immutable ?
Yes, the String in .Net is immutable. The System.String class is an immutable type provided in the .NET framework class library. Since a String is an immutable type, it cannot be modified. When you modify a string you are actually creating a new string object with the desired value.
e.g.
 
The above code will create 1000 new string variables in the memory.
Immutability of strings has positive significance in multithreaded applications because it provides automatic thread safety. Instances of immutable types are inherently thread-safe, because no thread can modify it.
The main drawback of immutable types is that they require more resources than other object types. Because each time it modified, it creates a new one.
The above code segment creates 1000 new string variables. In these type of situations you should use the StringBuilder class, which allows you to modify the text without making new String class instances. StringBuilder is a Mutable type, that means when you alter it , it still holding same data.
-
-
-
-
-
-
Pointer
Pointer nedir?

C# supports pointers in a limited extent. A C# pointer is nothing but a variable that holds the memory address of another type. 

But in C# pointer can only be declared to hold the memory address of value types and arrays. Unlike reference types, pointer types are not tracked by the default garbage collection mechanism. For the same reason pointers are not allowed to point to a reference type or even to a structure type which contains a reference type. We can say that pointers can point to only unmanaged types which includes all basic data types, enum types, other pointer types and structs which contain only unmanaged types.

Stack: static memory allocation, çok hızlı. Allocation compile sırasında olur. Ne kadar memory e ihtiyacın olduğunu kestirebiliyosan Stack kullan.

Heap: Dynamic memory allocation, allocation run time'da olur. Bu memory'e erişim yavaştır. Dependency yoktur sağdaki soldaki elementlere. Yani kolayca silip memory yi boşaltabilirsin. Bu olaylar işi kompleksleştirir ve memorynin neresi boş neresi dolu bilmeyi zorlaştırır. Ne kadar memory e ihtiyacın olduğunu kestiremiyorsan bunu kullan. Üst üste yığma alegorisi. Yığ yığabildiğin kadar. Aynı alegoriden ötürü -> yavaş çalışır --> neyin nerede olduğu belirsiz çünkü üst üste yığıyorsun. Stack ise hızlı çünkü herşey düzgün şeklide üst üste koyuluyor.

-
-
-
-
-
-
Semantics 
semantics nedir, semantic nedir
In programming language theory, semantics is the field concerned with the rigorous mathematical study of the meaning of programming languages. It does so by evaluating the meaning of syntactically valid strings defined by a specific programming language, showing the computation involved. In such a case that the evaluation would be of syntactically invalid strings, the result would be non-computation. Semantics describes the processes a computer follows when executing a program in that specific language. This can be shown by describing the relationship between the input and output of a program, or an explanation of how the program will be executed on a certain platform, hence creating a model of computation.
Formal semantics, for instance, helps to write compilers, better understand what a program is doing, and to prove, e.g., that the following if statement
if 1 == 1 then S1 else S2
has the same effect as S1 alone.
Overview
The field of formal semantics encompasses all of the following:
•	The definition of semantic models
•	The relations between different semantic models
•	The relations between different approaches to meaning
•	The relation between computation and the underlying mathematical structures from fields such as logic, set theory, model theory, category theory, etc.
It has close links with other areas of computer science such as programming language design, type theory, compilers and interpreters, program verification and model checking.
-
-
-
-
-
-
Extension Methods in C#  (GITHUB-UPDATED) (read)
Extension method nedir 
https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods
Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type. Extension methods are static methods, but they're called as if they were instance methods on the extended type. For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.
The most common extension methods are the LINQ standard query operators that add query functionality to the existing System.Collections.IEnumerable and System.Collections.Generic.IEnumerable<T> types. To use the standard query operators, first bring them into scope with a using System.Linq directive. Then any type that implements IEnumerable<T> appears to have instance methods such as GroupBy, OrderBy, Average, and so on. You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an IEnumerable<T> type such as List<T> or Array.
OrderBy Example
The following example shows how to call the standard query operator OrderBy method on an array of integers. The expression in parentheses is a lambda expression. Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods. For more information, see Lambda Expressions.
class ExtensionMethods2
{

    static void Main()
    {
        int[] ints = { 10, 45, 15, 39, 21, 26 };
        var result = ints.OrderBy(g => g);
        foreach (var i in result)
        {
            System.Console.Write(i + " ");
        }
    }
}
//Output: 10 15 21 26 39 45
…
The following is the extension method we have created.
public static int myExtensionMethod(this string str) {
   return Int32.Parse(str);
}
Let us see an example wherein we have used extension method.
using System;
using System.Text;
namespace Program {
   public static class Demo {
      public static int myExtensionMethod(this string str) {
         return Int32.Parse(str);
      }
   }
   class Program {
      static void Main(string[] args) {
         string str1 = "565";
         int n = str1.myExtensionMethod();
         Console.WriteLine("Result: {0}", n);
         Console.ReadLine();
      }
   }
}
Output
Result: 565

Detaylı:
Extension methods are defined as static methods but are called by using instance method syntax. Their first parameter specifies which type the method operates on. The parameter is preceded by the this modifier. Extension methods are only in scope when you explicitly import the namespace into your source code with a using directive.
The following example shows an extension method defined for the System.String class. It's defined inside a non-nested, non-generic static class:
C#Copy
namespace ExtensionMethods
{
    public static class MyExtensions
    {
        public static int WordCount(this String str)
        {
            return str.Split(new char[] { ' ', '.', '?' },
                             StringSplitOptions.RemoveEmptyEntries).Length;
        }
    }
}
The WordCount extension method can be brought into scope with this using directive:
C#Copy
using ExtensionMethods;
And it can be called from an application by using this syntax:
C#Copy
string s = "Hello Extension Methods";
int i = s.WordCount();
You invoke the extension method in your code with instance method syntax. The intermediate language (IL) generated by the compiler translates your code into a call on the static method. The principle of encapsulation is not really being violated. Extension methods cannot access private variables in the type they are extending.
-
-
Type Safety / Type Safe		(GITHUB)	
Type safety nedir, type safe nedir type-safe neir
Type safety means preventing type errors. Type error occurs when data type of one type is assigned to other type UNKNOWINGLY and we get undesirable results.
Type-safety should not be confused with static / dynamic typing or strong / weak typing.
A type-safe language is one where the only operations that one can execute on data are the ones that are condoned by the data's type. That is, if your data is of type X and X doesn't support operation y, then the language will not allow you to to execute y(X).
This definition doesn't set rules on when this is checked. It can be at compile time (static typing) or at runtime (dynamic typing), typically through exceptions. It can be a bit of both: some statically typed languages allow you to cast data from one type to another, and the validity of casts must be checked at runtime (imagine that you're trying to cast an Object to a Consumer - the compiler has no way of knowing whether it's acceptable or not).
Type-safety does not necessarily mean strongly typed, either - some languages are notoriously weakly typed, but still arguably type safe. Take Javascript, for example: its type system is as weak as they come, but still strictly defined. It allows automatic casting of data (say, strings to ints), but within well defined rules. There is to my knowledge no case where a Javascript program will behave in an undefined fashion, and if you're clever enough (I'm not), you should be able to predict what will happen when reading Javascript code.
An example of a type-unsafe programming language is C: reading / writing an array value outside of the array's bounds has an undefined behaviour by specification. It's impossible to predict what will happen. C is a language that has a type system, but is not type safe.

In computer science, type safety is the extent to which a programming language discourages or prevents type errors. A type error is erroneous or undesirable program behaviour caused by a discrepancy between differing data types for the program's constants, variables, and methods (functions), e.g., treating an integer (int) as a floating-point number (float). Type safety is sometimes alternatively considered to be a property of a computer program rather than the language in which that program is written; that is, some languages have type-safe facilities that can be circumvented by programmers who adopt practices that exhibit poor type safety. The formal type-theoretic definition of type safety is considerably stronger than what is understood by most programmers.
-
-
-
-
-
-
operand
operand nedir

int a = 2;
int b = 3;
int c = a * b;
yukarıdaki int c = a * b;  
işlemindeki a ve b değişkenlerine operand denir. 
a değişkeni: sol operand
b değişkeni: sağ operand
Kaynak: aşağıdaki text
+	Adds two operands
-	Subtracts the second operand from the first
*	Multiplies both operands
/	Divides the numerator by de-numerator
%	Modulus Operator and a remainder of after an integer division
++	Increment operator increases integer value by one
--	Decrement operator decreases integer value by one

Relational Operators
These are operators used for performing Relational operations on numbers. Below is the list of relational operators available in C#.
Operator	Description
==	Checks if the values of two operands are equal or not, if yes then condition becomes true.
!=	Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.
>	Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.
<	Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.
>=	Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.
<=	Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.
-
-
-
-
-
-
operator
operator nedir, operatör nedir operators nedir, operatörler nedir
+  -  *  / << == >> gibi işaretler operatördür.
Operator in C# is a special symbol that specifies which operations to perform on operands. For example, in mathematics the plus symbol (+) signifies the sum of the left and right numbers. In the same way, C# has many operators that have different meanings based on the data types of the operands. C# operators usually have one or two operands. Operators that have one operand are called Unary operators.
The following table list some of the operators available in C#.
Operator category	Operators
Primary	x.y
Unary	+x
Multiplicative	x * y
Additive	x + y
Shift	x << y
Relational and type testing	x < y
Equality	x == y
Logical AND	x & y
Logical XOR	x ^ y
Logical OR	x | y
Conditional AND	x && y
Conditional OR	x || y
Null-coalescing	x ?? y
Conditional	?:
Assignment and lambda expression	x = y
As mentioned before, certain operators have different meanings based on the datatype of the operand. For example, if the + operator is used with numbers, it will add the numbers but if it is used with strings, it will concatenate the two strings.
When an operator does different things based on the datatype of the operands, it is called operator over loading.
The following C# code shows the use of the + sign operator on different datatypes:

Example: + Operator
static void Main(string[] args)
{
    string message1 = "Hello";

    string message2 = message1 + " World!!";    

    Console.WriteLine(message2);

    int i = 10, j = 20;

    int sum = i + j;

    Console.WriteLine("{0} + {1} = {2}", i, j, sum);

-
-
-
-
-
-
F# / F Sharp 
Fsharp nedir f sharp nedir f# nedir
F# originates from Microsoft Research, Cambridge, UK. The language was originally designed and implemented by Don Syme,[6] according to whom in the fsharp team, they say the F is for "Fun".[24] Andrew Kennedy contributed to the design of units of measure.[6] The Visual F# Tools for Visual Studio are developed by Microsoft.[6] The F# Software Foundation developed the F# open-source compiler and tools, incorporating the open-source compiler implementation provided by the Microsoft Visual F# Tools team.[11]

F# (pronounced F sharp) is a general purpose, strongly typed, multi-paradigm programming language that encompasses functional, imperative, and object-oriented programming methods. F# is most often used as a cross-platform Common Language Infrastructure (CLI) language, but it can also generate JavaScript[9] and graphics processing unit (GPU) code.[10]

Syntax:
F# da göze çarpan ilk önemli komut "let" dir. Bu komut ile bir değişkene değeri kaydederiz. Örnek: 
let ahmet = 10 <- 19
-
-
-
-
-
-
Operator Overloading
[operator overloading nedir] 

Most operators in C# can be overloaded, meaning they can be redefined for custom actions.
For example, you can redefine the action of the plus (+) operator in a custom class.

class Box
{
    public int Height { get; set; }
    public int Width { get; set; }
    public Box(int h, int w)
    {
        Height = h;
        Width = w;
    }
    public static Box operator +(Box a, Box b) // eksi işareti de kullanılabilirdi. Sonuç değişmez. Operatörle ilgisi yok yani. + - * / hepsi aynı sonuç.
    {
        int h = a.Height + b.Height;
        int w = a.Width + b.Width;
        Box res = new Box(h, w);
        return res;
    }
}
static void Main(string[] args)
{
    Box b1 = new Box(14, 3);
    Box b2 = new Box(5, 7);
    Box b3 = b1 + b2;
 
    Console.WriteLine(b3.Height); //19
    Console.WriteLine(b3.Width); //10
    Console.ReadKey();
}

The method  public static Box operator +(Box a, Box b) defines an overloaded operator + with two Box object parameters and returning a new Box object whose Height and Width properties equal the sum of its parameter's corresponding properties.
Additionally, the overloaded operator must be static. 
-
-
-
-
-
-
String  	(GITHUB)
String nedir
Note that you do not use the new operator to create a string object except when initializing the string with an array of chars.
Msdn goes here:
A string is an object of type String whose value is text. Internally, the text is stored as a sequential read-only collection of Char objects. There is no null-terminating character at the end of a C# string; therefore a C# string can contain any number of embedded null characters ('\0'). The Length property of a string represents the number of Char objects it contains, not the number of Unicode characters. To access the individual Unicode code points in a string, use the StringInfo object.
string vs. System.String
In C#, the string keyword is an alias for String. Therefore, String and string are equivalent, and you can use whichever naming convention you prefer. 
Declaring and Initializing Strings
You can declare and initialize strings in various ways, as shown in the following example:
(declare nedir örnek, initialization nedir örnek)
// Declare without initializing.
string message1;

// Initialize to null.
string message2 = null;

// Initialize as an empty string.
// Use the Empty constant instead of the literal "".
string message3 = System.String.Empty;

// Initialize with a regular string literal.
string oldPath = "c:\\Program Files\\Microsoft Visual Studio 8.0";

// Initialize with a verbatim string literal.
string newPath = @"c:\Program Files\Microsoft Visual Studio 9.0";

// Use System.String if you prefer.
System.String greeting = "Hello World!";

// In local variables (i.e. within a method body)
// you can use implicit typing.
var temp = "I'm still a strongly-typed System.String!";

// Use a const string to prevent 'message4' from
// being used to store another string value.
const string message4 = "You can't get rid of me!";

// Use the String constructor only when creating
// a string from a char*, char[], or sbyte*. See
// System.String documentation for details.
char[] letters = { 'A', 'B', 'C' };
string alphabet = new string(letters);

Note that you do not use the new operator to create a string object except when initializing the string with an array of chars.
Initialize a string with the Empty constant value to create a new String object whose string is of zero length. The string literal representation of a zero-length string is "". By initializing strings with the Empty value instead of null, you can reduce the chances of a NullReferenceException occurring. Use the static IsNullOrEmpty(String) method to verify the value of a string before you try to access it.
-
-
-
-
-
-
Combobox / Combo box / Combination Box (GITHUB)
Combobox nedir, Combo box nedir, combination box nedir
The ComboBox control is used to display a drop-down list of various items. It is a combination of a text box in which the user enters an item and a drop-down list from which the user selects an item.
-
-
-
-
-
-
Quicksort		(GITHUB)
Quicksort nedir

Derin konu: tekrar dön ve yaz: https://www.geeksforgeeks.org/quick-sort/
Hızlı sıralama (İngilizcesi: Quicksort) günümüzde yaygın olarak kullanılan bir sıralama algoritmasıdır. Hızlı sıralama algoritması n adet sayıyı, ortalama bir durumda, {\displaystyle {\mathcal {O))(n~log(n))} karmaşıklığıyla, en kötü durumda ise  {\displaystyle {\mathcal {O))(n^{2})} karmaşıklığıyla sıralar. Algoritmanın karmaşıklığı aynı zamanda yapılan karşılaştırma sayısına eşittir.
-
-
-
-
-
-
Big Data
Big data nedir, bigdata nedir
Big Data is also data but with a huge size. Big Data is a term used to describe a collection of data that is huge in size and yet growing exponentially with time. In short such data is so large and complex that none of the traditional data management tools are able to store it or process it efficiently.
Big Data, sosyal medya paylaşımları, fotoğraf arşivlerimiz, sürekli kayıt aldığımız ‘log’ dosyaları gibi farklı kaynaklardan elde ettiğimiz tüm bu verilerin anlamlı ve işlenebilir hale dönüştürülmüş biçimidir.

Big Data Kullanım Alanları Ile Ilgili Örnekler:
Firmaların müşterileri, malzeme tedarikçileri, şirket içerisindeki her türlü işlem ve ürünleri ile ilgili trilyonlarca bayt’ lık veri toplamakta ve anlamlı raporlar üretilmektedir.

Sosyal medya paylaşımları sayesinde her gün milyarlarca kilobayt veri elde edilmektedir.
Günümüzde normal bir tüketicinin günlük yaşamında internette yaptığı haberleşme, arama, satın alma ve paylaşma türü işlemlerin yarattığı verilerin de tümü saklanmaktadır.

Twitter’ da günlük işlenen veri boyutu: 7 terabyte’a yaklaşmakta ve günden güne artmaktadır.

Sağlık Kuruluşları; hastalarına yönelik bireysel ve kişiselleştirilmiş sağlık hizmetleri sağlayabilmek için, bireysel durumdaki verileri kendi sayısal ortamlarında depolamaktadırlar.

Kullanım örnek:
Nöral Ağlarla Rüzgar Güç Kaynağı Tahmini
Rüzgar enerjisi üretilen bir alanda bu enerjinin miktarının doğru tahmin edilmesi aşağıdaki özellikleri sağlar:
►Rüzgar gücünün anlık kullanıma uygun bir enerji kaynağı olarak kullanımı
►Rüzgar gücü miktarının spot piyasadaki düzeni
►Rüzgar türbini bakım işlerinin optimum zamanlanması
►Verimli enerji şebekesi yönetimi
Gaz Türbinleri İçin Veri Yönetimi ve Gerçek Zamanlı Görüntüleme
►Gerçek Zamanlı Veri analizleri (1000 nöral model)
►Veritabanı: input(giriş) verisi ve model sonuçları
►Bütün veri ve bağımlılık analizleri artı optimizasyon öğrenimi
-
-
-
-
-
-
Linux 
Linux nedir
The name “Linux” comes from the Linux kernel. It is the software on a computer that allows applications and users to access the devices on the computer to perform certain specific functions.
Bilgisayar işletim sistemlerinin en temel parçası olan çekirdek yazılımlarından bir tanesidir.verilmiştir.[1]Günümüzde süper bilgisayarlarda, akıllı cihazların ve internet altyapısında kullanılan cihazların işletim sistemlerinde yaygın olarak kullanılmaktadır. Bunlardan en popüler olanı Google tarafından geliştirilen Android işletim sistemidir.

Android, Linux çekirdeği üzerine inşa edilmiş bir mobil işletim sistemidir.
Android işletim sistemi beş kısımdan oluşur.
1.	Çekirdek: Linux kernelidir. Güvenlik, hafıza yönetimi, süreç yönetimi, ağ yığınları ve sürücü modellerini içermektedir.
2.	Android Runtime: Sanal makinedir. Dalvik Sanal Makinesini de içermektedir. 5.0 ile Dalvik kaldırılmış ve ART'ye geçilmiştir.
3.	Kütüphaneler: Veritabanı kütüphaneleri, web tarayıcı kütüphaneleri, grafik ve arayüz kütüphanelerini içermektedir.
4.	Uygulama Çatısı: Uygulama geliştiricilere geniş bir platform sunan kısımdır.
5.	Uygulama Katmanı: Doğrudan Java (programlama dili) ile geliştirilmiş uygulamaları içermektedir.
-
-
-
-
-
-
UNIX
Unix nedir
Unix (/ˈjuːnɪks/; trademarked as UNIX) is a family of multitasking, multiuser computer operating systems that derive from the original AT&T Unix, development starting in the 1970s at the Bell Labs research center by Ken Thompson, Dennis Ritchie, and others.[3]
-Unix vs linux yazılar var: https://chandigarhinfo.in/unix-vs-linux-whats-the-difference/
-
-
-
-
-
-
Web Server	 (GITHUB)
Web server nedir

Web server ya da ağ sunucusu, internet üzerinde bir web sitesinin yayınından sorumlu olan sunucudur. Web server, Hosting ya da “barındırma” işlemini internet protokolü üzerinden sunan bir sunucudur. 
A Web server is software or hardware that uses HTTP (Hypertext Transfer Protocol) and other protocols to respond to client requests made over the World Wide Web (WWW). Web server software controls how a user accesses hosted files. It is accessed through the domain names of websites and ensures the delivery of the site's content to the requesting user. As hardware, a Web server is a computer that holds web server software and other files related to a website, such as HTML documents, images and JavaScript files. Web server hardware is connected to the internet and allows data to be exchanged with other connected devices.
The Web server process is an example of the client/server model. All computers that host Web sites must have Web server software. Leading Web servers include Apache, Microsoft's Internet Information Server (IIS) and Nginx -- pronounced engine X. Other Web servers include Novell's NetWare server, Google Web Server (GWS) and IBM's family of Domino servers.
Web servers often come as part of a larger package of internet- and intranet-related programs that are used for:
•	Sending and receiving emails.
•	Downloading requests for File Transfer Protocol (FTP) files.
•	Building and publishing Web pages.
Considerations in choosing a Web server include how well it works with the operating system and other servers; its ability to handle server-side programming; security characteristics; and the particular publishing, search engine and site building tools that come with it.
So basically a web server is the software that receives your request to access a web page. It runs a few security checks on your HTTP request and takes you to the web page. Depending on the page you have requested, the page may ask the server to run a few extra modules while generating the document to serve you. It then serves you the document you requested. Pretty awesome isn’t it.

Web server ya da ağ sunucusu, internet üzerinde bir web sitesinin yayınından sorumlu olan sunucudur. Web server, Hosting ya da “barındırma” işlemini internet protokolü üzerinden sunan bir sunucudur. Barındırma ya da hosting, Web sayfalarını internette yayınlamak için gerekli alanın kiralanmasıdır. Diğer bir ifade ile hosting, bir Web sitesinde yayınlanmak istenen sayfaların, resimlerin veya dokümanların internet kullanıcıları tarafından erişebileceği bir bilgisayarda tutulmasıdır.
-
-
-
-
-
-
Terminal 	(GITHUB)
Terminal nedir

Terminal, Apple bilgisayarları ve Linux işletim sistemi kullanılan bilgisayarların içerisinde yer alan, kullanıcıların bir klavye ve ekran yardımıyla işletim sistemi yada yazılımları kontrol etmesine yardımcı olan komut ekranıdır. 

A terminal is simply a text-based interface to the computer. In a terminal, you can type commands, manipulate files, execute programs, and open documents. When working in a terminal, the current directory is called your working directory. A terminal will usually start in the top-level directory of your account.
Directories are separated by a backslash /. The topmost directory is indicated by a single backslash. The total directory tree is all relative to the top level directory.
On MacOS, there is a Volumes directory at the top that lists all mounted drives (networked or local). So if you have mounted your network directory, the path to it will look like the following if you substitute your username for mine.
/Volumes/Personal/bmaxwell
In a terminal, you generally type a command and any modifiers or arguments the command requires, then hit return and the command is executed. For example, to set your current (working) directory to your home directory, type cd and the prompt and hit return. Below is an example of a terminal and some commands.
-
-
-
-
-
-
Windows PowerShell 	(GITHUB)
Windows powershell nedir

To give you a better understanding of PowerShell, we should first define what a shell is. No, we're not talking about a turtle's shell. :) In computer science, a shell is a user interface that gives you access to various services of an operating system. A shell can be command-line based, or it can include a graphical user interface (GUI).
Windows PowerShell is a shell initially developed by Microsoft for the purposes of task automation and configuration management. PowerShell is now an open source project, and it can be installed on Windows, macOS, and Linux platforms. This shell is based on the .NET framework, and it includes a command-line shell and a scripting language.

Windows PowerShell, Microsoft tarafından Windows komut satırı cmd.exe ve Windows Script Host'a alternatif olarak geliştirilen yeni nesil bir komut satırı uygulamasıdır. Windows PowerShell'in sunduğu yeni komut yapısı Unix sistemindeki komut yapısına benzemektedir. Kullanıcı herhangi bir komutu çalıştırdığında farklı komutlar ile bağ kurabilmektedir. Windows PowerShell 30 Kasım 2006'da ilk olarak Windows Vista işletim sisteminin bir parçası olarak planlanmıştır. Microsoft Exchange Server 2007 ile beraber ilk kez piyasaya sürülmüştür. Windows PowerShell 1.0 sürümü Windows XP, Windows Server 2003 ve Windows Vista için ücretsiz indirilebilmektedir. Windows 7'den itibaren Windows PowerShell 2.0 işletim sistemi ile beraber gelmektedir. Windows PowerShell 2.0 bir önceki sürümünden farklı olarak görsel kullanıcı arayüzüne sahptir.
-
-
-
-
-
-
Variable	(GITHUB)
Variable nedir, değişken nedir

Creating a variable reserves a memory location, or a space in memory, for storing values. 
To use a variable, it must first be declared by specifying the name and data type. 
A variable name, also called an identifier, can contain letters, numbers and the underscore character (_) and must start with a letter or underscore. 
For example, firstName and lastName are good descriptive variable names.
-
-
-
-
-
-
Double vs Float
Double nedir, float nedir
As the name implies, a double has 2x the precision of float. In general a double has 15 decimal digits of precision, while float has 7.
-
-
-
-
-
-
Scalability 	(GITHUB)

Scalability nedir

Türkçesi ölçeklenebilirlik
Scalability is the property of a system to handle a growing amount of work by adding resources to the system. In an economic context, a scalable business model implies that a company can increase sales given increased resources.
-
-
-
-
-
-
Json		(GITHUB)
json nedir
Json türündeki veriler iki parçadan oluşur: key (anahtar) ve value (değer). Anahtar’da nesnenin hangi özelliğinin olduğu (koddaki değişken ismi gibi düşünülebilir) tanımlanırken değerde ise anahtar özelliğinin değeri (değişkenin değeri) tanımlanır. Nesnelerdeki anahtar ve değerler string türünde tanımlanır. Aşağıda basit bir json nesnesi örneği bulunmaktadır.
{
   "Ad": "Veysel Uğur",
   "Soyad": "Kızmaz"
}


Detay:

What Is JSON?
JSON is short for JavaScript Object Notation, and is a way to store information in an organized, easy-to-access manner. In a nutshell, it gives us a human-readable collection of data that we can access in a really logical manner.
Storing JSON Data
As a simple example, information about me might be written in JSON as follows:
	var jason = {
		"age" : "24",
		"hometown" : "Missoula, MT",
		"gender" : "male"
	};
view rawgistfile1.js hosted with   by GitHub
This creates an object that we access using the variable jason. By enclosing the variable’s value in curly braces, we’re indicating that the value is an object. Inside the object, we can declare any number of properties using a "name": "value" pairing, separated by commas. To access the information stored in jason, we can simply refer to the name of the property we need. For instance, to access information about me, we could use the following snippets:
	document.write('Jason is ' jason.age); // Output: Jason is 24
	document.write('Jason is a ' jason.gender); // Output: Jason is a male
view rawgistfile1.js hosted with   by GitHub
Storing JSON Data in Arrays
A slightly more complicated example involves storing two people in one variable. To do this, we enclose multiple objects in square brackets, which signifies an array. For instance, if I needed to include information about myself and my brother in one variable, I might use the following:
	var family = [{
	    "name" : "Jason",
	    "age" : "24",
	    "gender" : "male"
	},
	{
	    "name" : "Kyle",
	    "age" : "21",
	    "gender" : "male"
	}];
view rawgistfile1.js hosted with   by GitHub
To access this information, we need to access the array index of the person we wish to access. For example, we would use the following snippet to access info stored in family:
	document.write(family[1].name); // Output: Kyle
	document.write(family[0].age); // Output: 24
view rawgistfile1.js hosted with   by GitHub
NOTE: This is beneficial if it will be necessary to loop through stored information, as it lends itself to a for loop with an automatically incrementing value.
Nesting JSON Data
Another way to store multiple people in our variable would be to nest objects. To do this, we would create something similar to the following:
	var family = {
	    "jason" : {
	        "name" : "Jason Lengstorf",
	        "age" : "24",
	        "gender" : "male"
	    },
	    "kyle" : {
	        "name" : "Kyle Lengstorf",
	        "age" : "21",
	        "gender" : "male"
	    }
	}
view rawgistfile1.js hosted with   by GitHub
Accessing information in nested objects is a little easier to understand; to access information in the object, we would use the following snippet:
	document.write(family.jason.name); // Output: Jason Lengstorf
	document.write(family.kyle.age); // Output: 21
	document.write(family.jason.gender); // Output: male
view rawgistfile1.js hosted with   by GitHub
Nested JSON and arrays can be combined as needed to store as much data as necessary.
Why Does JSON Matter?
With the rise of AJAX-powered sites, it’s becoming more and more important for sites to be able to load data quickly and asynchronously, or in the background without delaying page rendering. Switching up the contents of a certain element within our layouts without requiring a page refresh adds a “wow” factor to our applications, not to mention the added convenience for our users. Because of the popularity and ease of social media, many sites rely on the content provided by sites such as Twitter, Flickr, and others. These sites provide RSS feeds, which are easy to import and use on the server-side, but if we try to load them with AJAX, we run into a wall: we can only load an RSS feed if we’re requesting it from the same domain it’s hosted on. An attempt to load my Flickr account’s RSS feed via jQuery’s $.ajax() method results in the following JavaScript error:
	[Exception... "Access to restricted URI denied" code: "1012" 
	nsresult: "0x805303f4 (NS_ERROR_DOM_BAD_URI)" 
	location: "http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js Line: 19"]
view rawgistfile1.js hosted with   by GitHub
JSON allows us to overcome the cross-domain issue because we can use a method called JSONP that uses a callback function to send the JSON data back to our domain. It’s this capability that makes JSON so incredibly useful, as it opens up a lot of doors that were previously difficult to work around.
How Do We Load JSON into a Project?
One of the easiest ways to load JSON data into our web applications is to use the $.ajax() method available in the jQuery library. The ease of retrieving data will vary based on the site providing the data, but a simple example might look like this:
	$.ajax(
	    type:'GET',
	    url:"http://example.com/users/feeds/",
	    data:"format=json&id=123",
	    success:function(feed) {
	        document.write(feed);
	    },
	    dataType:'jsonp'
	);
view rawgistfile1.js hosted with   by GitHub
This example would request the latest feed items in JSON format and output them to the browser. Obviously, we wouldn’t want to output raw JSON data to the browser, but this example shows the basics of loading JSON from an external source.
A Practical Example: Loading Flickr Streams with JSON and jQuery
[demolink]See the Demo | Download the Source[/demolink]
To show how JSON works in a real-world example, let’s load photos from Flickr using jQuery and the JSON version of Flickr’s “Latest” photo feed.
Step 1: Create the AJAX Request
Flickr’s photostream feeds are relatively easy to access. All users have a unique ID number, which we will send as part of the request to this URL.
	http://api.flickr.com/services/feeds/photos_public.gne
view rawgistfile1.html hosted with   by GitHub
The request we need to send asks for the latest photos from the user in question, along with flags asking for a JSON-formatted response. The request we need to send will look like this:
	id=XXXXXXXX@NXX&lang=en-us&format=json&jsoncallback=?
view rawgistfile1.html hosted with   by GitHub
In the above example, XXXXXXXX@NXX needs to be replaced with the user’s ID. We’ll be writing a function, so the user’s ID will be passed as an argument called flickrID. Our function will be called loadFlickr(). Let’s create the function that will load our JSON response:
	function loadFlickr(flickrid)
	{
	    $('#feed').html('<span><img src="/blog/images/lightbox-ico-loading.gif" alt=""></span>');
	    $.ajax({
	        type:'GET',
	        url:"http://api.flickr.com/services/feeds/photos_public.gne",
	        data:"id="+flickrid+"&lang=en-us&format=json&jsoncallback=?",
	        success:function(feed) {
	            // Do something with the response
	        },
	        dataType:'jsonp'
	    });
	}
view rawgistfile1.js hosted with   by GitHub
The returned JSON data will look something like this (note that I’ve removed all but one of the returned photos for the sake of brevity):
	({
	    "title": "Uploads from ennuidesign",
	    "link": "http://www.flickr.com/photos/ennuidesign/",
	    "description": "",
	    "modified": "2009-03-17T03:53:36Z",
	    "generator": "http://www.flickr.com/",
	    "items": [
	    {
	        "title": "This Is How You Get People to Talk About You",
	        "link": "http://www.flickr.com/photos/ennuidesign/3361269251/",
	        "media": {"m":"http://farm4.static.flickr.com/3470/3361269251_9c55e6dc24_m.jpg"},
	        "date_taken": "2009-03-16T21:53:36-08:00",
	        "description": "<p><a href="http://www.flickr.com/people/ennuidesign/">ennuidesign</a> posted a photo:</p> <p><a title="This Is How You Get People to Talk About You" href="http://www.flickr.com/photos/ennuidesign/3361269251/"><img src="http://farm4.static.flickr.com/3470/3361269251_9c55e6dc24_m.jpg" alt="This Is How You Get People to Talk About You" width="240" height="180"></a></p> <p>A guy I know, Trevor Gnauck, made this custom pint glass for me. He runs a company called <a href="http://www.bluedragonllc.com/">Blue Dragon Custom Laser Engraving</a> with his family, and he had no reason whatsoever to do anything nice for me.<br> <br> He did, though, and look how cool that is! I can now drink a beer out of my own likeness.<br> <br> I know it wasn't his intention, but this is how you get people to talk about you. Unprovoked kindness will always inspire kindness in return, and the power of a kind gesture should never be overlooked.</p>",
	        "published": "2009-03-17T03:53:36Z",
	        "author": "nobody@flickr.com<script type="text/javascript">
	/* <![CDATA[ */
	(function(){try{var s,a,i,j,r,c,l=document.getElementById("__cf_email__");a=l.className;if(a){s='';r=parseInt(a.substr(0,2),16);for(j=2;a.length-j;j+=2){c=parseInt(a.substr(j,2),16)^r;s+=String.fromCharCode(c);}s=document.createTextNode(s);l.parentNode.replaceChild(s,l);}}catch(e){}})();
	/* ]]> */
	</script> (ennuidesign)",
	        "author_id": "29080075@N02",
	        "tags": "gift ennuidesign trevorgnauck bluedragoncustomlaserengraving"
	    }
	 
	    // The rest of the photo entries go here...
	 
	    ]
	})
view rawgistfile1.json hosted with   by GitHub
Step 2: Process the JSON Data
What we’re going to do is display the thumbnails of the latest 16 photos, which will link to the medium-sized display of the image. The Flickr JSON is a little confusing, and it doesn’t provide a direct link to the thumbnail version of our photos, so we’ll have to use some trickery on our end to get to it, which we’ll cover in just a moment. Each photo entry is stored in an array called items, which we access in our AJAX call using feed.items. To get to the data about each entry, we’ll loop through the items until we’ve either hit the last available photo or 16 total photos; whichever comes first. Let’s modify our function and set up the loop:
	function loadFlickr(flickrid)
	{
	    // Display a loading icon in our display element
	    $('#feed').html('<span><img src="/blog/images/lightbox-ico-loading.gif" alt=""></span>');
	 
	    // Request the JSON and process it
	    $.ajax({
	        type:'GET',
	        url:"http://api.flickr.com/services/feeds/photos_public.gne",
	        data:"id="+flickrid+"&lang=en-us&format=json&jsoncallback=?",
	        success:function(feed) {
	            // Create an empty array to store images
	            var thumbs = [];
	 
	            // Loop through the items
	            for(var i=0, l=feed.items.length; i < l && i < 16;   i) 
	            {
	                // Process each image
	            }
	 
	            // Display the thumbnails on the page
	        },
	        dataType:'jsonp'
	    });
	}
view rawgistfile1.js hosted with   by GitHub
The element we’re interested in is the “m” element stored within the “media” element. This can be accessed within our loop using feed.items[i].media.m. We’re going to run a regular expression on this value to get both the medium and thumbnail image paths, which we’ll assemble into a linked thumbnail image. Then, we’ll push the newly assembled HTML into the array of thumbs we created. After we’ve finished the loop, we’ll combine all the images into one string of HTML and replace the contents of our display element with the loaded thumbnails. Let’s add this functionality to our script:
	function loadFlickr(flickrid)
	{
	    // Display a loading icon in our display element
	    $('#feed').html('<span><img src="/blog/images/lightbox-ico-loading.gif" alt=""></span>');
	 
	    // Request the JSON and process it
	    $.ajax({
	        type:'GET',
	        url:"http://api.flickr.com/services/feeds/photos_public.gne",
	        data:"id="+flickrid+"&lang=en-us&format=json&jsoncallback=?",
	        success:function(feed) {
	            // Create an empty array to store images
	            var thumbs = [];
	 
	            // Loop through the items
	            for(var i=0, l=feed.items.length; i < l && i < 16;   i) 
	            {
	                // Manipulate the image to get thumb and medium sizes
	                var img = feed.items[i].media.m.replace(
	                    /^(.*?)_m.jpg$/, 
	                    '<a href="/blog/$1.jpg"><img src="/blog/$1_s.jpg" alt=""></a>'
	                );
	 
	                // Add the new element to the array
	                thumbs.push(img);
	            }
	 
	            // Display the thumbnails on the page
	            $('#feed').html(thumbs.join(''));
	 
	            // A function to add a lightbox effect
	            addLB();
	        },
	        dataType:'jsonp'
	    });
	}
view rawgistfile1.js hosted with   by GitHub
Note that I’ve also added a function called addLB() to the end of this function; this adds the lightbox effect to our thumbnails, which is purely for aesthetics.
Step 3: Call Our Function
At this point, we’re ready to call our function. To load my Flickr stream, we would need to call our function as follows:
	loadFlickr("29080075@N02");
view rawgistfile1.js hosted with   by GitHub
The example posted will pull multiple users’ photostreams into the containing box without causing a page refresh. Look at the source code on the demo to see how it was done. NOTE: Keep in mind that this demo was to show how to load JSON data, and not on how to implement the code to call the function. The JavaScript calls are inline, which should NOT be used in a production script.
[demolink]See the Demo | Download the Source[/demolink]
-
-
-
-
-
-
SharePoint 
sharepoint nedir
SharePoint is a web-based collaborative platform that integrates with Microsoft Office. Launched in 2001, SharePoint is primarily sold as a document management and storage system, but the product is highly configurable and usage varies substantially among organizations.
Microsoft states that SharePoint has 190 million users across 200,000 customer organizations.
There are the Windows SharePoint Services (WSS), the Microsoft Office SharePoint Server (MOSS) and Microsoft Search Server. Each bring their own functionalities to the table and build upon each other. 
When looking up what SharePoint is, you get a lot of different answers from the Internet:
•	Microsoft SharePoint is a browser-based collaboration and document management platform from Microsoft - Wikipedia
•	Microsoft's content management system. It allows groups to set up a centralized, password protected space for document sharing. Documents can be stored, downloaded and edited, then uploaded for continued sharing. - SAIT Polytechnic Teaching - Glossary
•	SharePoint is a web-based intranet that can help improve your organization's effectiveness by streamlining the management of and access to data. - Creative SharePoint
•	SharePoint is an enterprise information portal, from Microsoft, that can be configured to run Intranet, Extranet and Internet sites. - SharePoint HQ
•	{..} SharePoint is a sort of sharing/blogging/wiki-style server that mainly provides a back end to Microsoft Office - Jack Schofield, Technical Writer Guardian newspaper, UK.
So what is SharePoint? Let's first look at it from a technical perspective. There are the Windows SharePoint Services (WSS), the Microsoft Office SharePoint Server (MOSS) and Microsoft Search Server. Each bring their own functionality to the table and build upon each other.
Windows SharePoint Services function the basic functionality that Gartner calls Basic Content Services. It offers the user access to Versioning and Check-in/Checkout functionality. WSS can then be extended through the use of the applets to add additional collaborative functions like email alerts, shared calendars, etc.
Microsoft Office SharePoint Server (MOSS) sits on top of WSS and adds additional features, both to the underlying WSS layer as well as additional ways for the end-user to interact with the repository. The data resides in a SQL Database. Using Webparts it can then present this information to the user using a wide range of different modules and for interaction in different business scenarios. These include such diverse applications as Collaboration, Document management, Records Management (including DOD 5015.2 certified components), Workflow, Personalization, more complex metadata models as well as Blogs and Wikis from the Web 2.0 side. 
https://www.youtube.com/watch?time_continue=104&v=s12Jb5Z2xaE&feature=emb_logo
https://medium.com/@serdalkepil/sharepoint-nedir-neden-kullan%C4%B1l%C4%B1r-79a1e8426599
-
-
-
-
-
-
Difference between readonly and const keyword in C#  	 (GITHUB)
const nedir, readonly nedir  
In C#, a const keyword is used to declare constant fields and constant local. The value of the constant field is the same throughout the program or in other words, once the constant field is assigned the value of this field is not be changed. In C#, constant fields and locals are not variables, a constant is a number, string, null reference, boolean values.

Example:
// C# program to illustrate the 
// use of const keyword 
using System; 
  
class GFG { 
  
    // Constant fields 
    public const int myvar = 10; 
    public const string str = "GeeksforGeeks"; 
  
    // Main method 
    static public void Main() 
    { 
  
        // Display the value of Constant fields 
        Console.WriteLine("The value of myvar: {0}", myvar); 
        Console.WriteLine("The value of str: {0}", str); 
    } 
} 
Output:



The value of myvar: 10
The value of str: GeeksforGeeks
In C#, you can use a readonly keyword to declare a readonly variable. This readonly keyword shows that you can assign the variable only when you declare a variable or in a constructor of the same class in which it is declared.
Example:
filter_none
edit
play_arrow
brightness_4
// C# program to illustrate the use  
// of the readonly keyword 
using System; 
  
class GFG { 
  
    // readonly variables 
    public readonly int myvar1; 
    public readonly int myvar2; 
  
    // Values of the readonly  
    // variables are assigned 
    // Using constructor 
    public GFG(int b, int c) 
    { 
  
        myvar1 = b; 
        myvar2 = c; 
        Console.WriteLine("Display value of myvar1 {0}, "+ 
                        "and myvar2 {1}", myvar1, myvar2); 
    } 
  
    // Main method 
    static public void Main() 
    { 
        GFG obj1 = new GFG(100, 200); 
    } 
} 
Output:
Display value of myvar1 100, and myvar2 200
-
-
-
-
-
-
readonly Modifier

[readonly nedir, readonly modifier nedir, readonly keyword nedir, const nedir]

The readonly modifier prevents a member of a class from being modified after construction. It means that the field declared as readonly can be modified only when you declare it or from within a constructor.

        class Person
        {
            private readonly string name = "John";
            public Person(string name)
            {
                this.name = name;
            }
        }
If we try to modify the name field anywhere else, we will get an error.

There are three major differences between readonly and const fields. 
First, a constant field must be initialized when it is declared, whereas a readonly field can be declared without initialization, as in:

        readonly string name; // OK
        const double PI; // Error
 
Second, a readonly field value can be changed in a constructor, but a constant value cannot.
Third, the readonly field can be assigned a value that is a result of a calculation, but constants cannot, as in:

        readonly double a = Math.Sin(60); // OK
        const double b = Math.Sin(60); // Error
-
-
-
-
-
-
this Keyword	    (GITHUB)

this nedir, this keyword nedir
The this keyword is used inside the class and refers to the current instance of the class, meaning it refers to the current object.
One of the common uses of this is to distinguish class members from other data, such as local or formal parameters of a method, as shown in the following example:
        class Person
        {
            private string name;
            public Person(string name)
            {
                this.name = name; // member of the class
            }
        }

Here, this.name represents the member of the class, whereas name represents the parameter of the constructor.

Another common use of this is for passing the current instance to a method as parameter: ShowPersonInfo(this);
-
-
-
-
-
-
Initialization (GITHUB)
Initialization nedir
Object'in property'lerini objenin creation time'ında Set etmeye yarar. Yani objeyi üretirken property'lerini set etmeye yarayan bir şeydir (neydir? Bir Special Feature'dir [pluralsight]

        public class Employee
        {

        }

        public static void Main(string[] args)
        {
            Employee emp = new Employee(); // null dönmeyecektir.. initialize ettik. Constructor kullandık. Ne olmuş oldu? emp üretilmiş oldu... Hatırlayalım ki constructor kullanıldığı zaman yeni obje (instance) üretilmiş olur.
            Employee emp2; // null dönecektir.

            Console.WriteLine(emp); // hata üretmez
            Console.WriteLine(emp2); // HATA! Might not be initialized before accessing.

            Console.ReadLine();
	}
Initialization MSDN anlatımı:
Local variables in C# must be initialized before they are used. For example, you might declare a local variable without initialization as in the following example:
            int myInt; // Declaration
You cannot use it before you initialize it. You can initialize it using the following statement:
            myInt = new int();  // Initialization // Invoke default constructor for int type.
This statement is equivalent to the following statement:

            myInt = 0;         // Assign an initial value, 0 in this example.  
You can, of course, have the declaration and the initialization in the same statement as in the following examples:
            int myInt = new int(); // declaration and the initialization
–or–
            int myInt = 0; // declaration and the initialization
Using the new operator calls the default constructor of the specific type and assigns the default value to the variable. In the preceding example, the default constructor assigned the value 0 to myInt. For more information about values assigned by calling default constructors, see Default Values Table.
With user-defined types, use new to invoke the default constructor. For example, the following statement invokes the default constructor of the Point struct: 

            Point p = new Point(); // Invoke default constructor for the struct.  

After this call, the struct is considered to be definitely assigned; that is, all its members are initialized to their default values.
Örnek:
  int myInt = new int(); // 0 dönüyor
            int otherInt; // 0 dönüyor //initialize etmediğimiz halde 0 değerini aldı. String'de null değer alabildi. Neden int null alamadı? Cevabı aşağıdaki notta: Reference type value type olayı!
            //int otherInt2 = null; // hata verir. Cannot convert null to int.

            //string myString = new string(); // böyle bir şey yazamazsın. Hata verir.
            string otherString; // null dönüyor
            string otherString2 = null; // null dönüyor

// int is a primitive type and only ReferenceTypes (objects) are nullable.
// not2: An int is a value type. It is really of type Int32. Objects that can be nullable are reference types. At a basic level the difference is that a value type will store the value with the variable where a reference type will store a reference to the value. A reference can be null, meaning that it doesn't point to a value. Where a value type always has a value.
Nullable wraps a value type to allow you to have the option of being null. Using int? is just a compiler shortcut to declare a nullable type.
// not3: int is a value type, which can only hold a value...
-
-
-
-
-
-
ArrayList Class  (GITHUB)
arrayList nedir
Implements the IList interface using an array whose size is dynamically increased as required.
The following example shows how to create and initialize an ArrayList and how to display its values.
using System;
using System.Collections;
public class SamplesArrayList  {

   public static void Main()  {

      // Creates and initializes a new ArrayList.
      ArrayList myAL = new ArrayList();
      myAL.Add("Hello");
      myAL.Add("World");
      myAL.Add("!");

      // Displays the properties and values of the ArrayList.
      Console.WriteLine( "myAL" );
      Console.WriteLine( "    Count:    {0}", myAL.Count );
      Console.WriteLine( "    Capacity: {0}", myAL.Capacity );
      Console.Write( "    Values:" );
      PrintValues( myAL );
   }

   public static void PrintValues( IEnumerable myList )  {
      foreach ( Object obj in myList )
         Console.Write( "   {0}", obj );
      Console.WriteLine();
   }

}


/* 
This code produces output similar to the following:

myAL
    Count:    3
    Capacity: 4
    Values:   Hello   World   !

*/

 Important
We don't recommend that you use the ArrayList class for new development. Instead, we recommend that you use the generic List<T> class. The ArrayList class is designed to hold heterogeneous collections of objects. However, it does not always offer the best performance. Instead, we recommend the following:
•	For a heterogeneous collection of objects, use the List<Object> (in C#) or List(Of Object) (in Visual Basic) type.
•	For a homogeneous collection of objects, use the List<T> class.
See Performance Considerations in the List<T> reference topic for a discussion of the relative performance of these classes. See Non-generic collections shouldn't be used on GitHub for general information on the use of generic instead of non-generic collection types.
The ArrayList is not guaranteed to be sorted. You must sort the ArrayList by calling its Sort method prior to performing operations (such as BinarySearch) that require the ArrayList to be sorted. To maintain a collection that is automatically sorted as new elements are added, you can use the SortedSet<T> class.
The capacity of an ArrayList is the number of elements the ArrayList can hold. As elements are added to an ArrayList, the capacity is automatically increased as required through reallocation. The capacity can be decreased by calling TrimToSize or by setting the Capacity property explicitly.
.NET Framework only: For very large ArrayList objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the enabled attribute of the <gcAllowVeryLargeObjects> configuration element to true in the run-time environment.
Elements in this collection can be accessed using an integer index. Indexes in this collection are zero-based.
The ArrayList collection accepts null as a valid value. It also allows duplicate elements.
Using multidimensional arrays as elements in an ArrayList collection is not supported.
-
-
-
-
-
-
Strongly Typed 	(GITHUB)
Strongly Typed nedir? Strongly type nedir, weakly typed nedir, loosely typed nedir
A LANGUAGE IS STRONGLY TYPED if the compiler can guarantee that the accepted programs will execute without type errors. Lisp languages are usually weakly typed:

C# is a strongly-typed language. It means we must declare the type of a variable which indicates the kind of values it is going to store such as integer, float, decimal, text, etc.
The following declares and initialized variables of different data types.
Example: Variables of Different Data Types

string stringVar = "Hello World!!";
int intVar = 100;
float floatVar = 10.2f;
char charVar = 'A';
bool boolVar = true;
 
In computer programming, programming languages are often colloquially classified as to whether the language's type system makes it strongly typed or weakly typed (loosely typed). Generally, a strongly typed language has stricter typing rules at compile time, which implies that errors and exceptions are more likely to happen during compilation. However, dynamically typed languages (where type checking happens at run time) can also be strongly typed. Most of these rules affect variable assignment, return values and function calling. On the other hand, a weakly typed language has looser typing rules and may produce unpredictable results or may perform implicit type conversion at runtime.[1] A different but related concept is latent typing.
-
-
            // Create two DataTable instances.
            DataTable dataTable1 = new DataTable("Books");
            //dataTable1.Clear();
            dataTable1.Columns.Add("Name");
            dataTable1.Columns.Add("Id");
            dataTable1.Rows.Add("Monte Cristo", 1);
            dataTable1.Rows.Add("Jane Eyre", 2);
 
            DataTable dataTable2 = new DataTable("Medications");
            dataTable2.Columns.Add("Id");
            dataTable2.Columns.Add("Medication");
            dataTable2.Rows.Add(1, "Atenolol");
            dataTable2.Rows.Add(2, "Amoxicillin");
 
            // Oluşturduğumuz dataTable'ları dataSet içine koyalım.
 
            DataSet dataSet = new DataSet("dataSetNam");
            dataSet.Tables.Add(dataTable1);
            dataSet.Tables.Add(dataTable2);

-
-
-
-
Örnek kod
Static class örnek, static class nedir, list oluşturma, list nedir, static nedir
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    public class Student
    {
        public int Id;
        public string Name;
    }
 
    //static class'ın member'ları da static olmalıdır
    public static class CreateStudents
    {
        //public string SampleProperty { get; set; } //hata verir, static olmalıdır
        public static string SampleProperty { get; set; }
 
        //public void Create() //hata verir, static olmalıdır
        public static List<Student> StudentsList { get; set; } = new List<Student>
        {
            new Student()
            {
                Id = 1,
                Name = "Ali"
            },
            new Student()
            {
                Id = 2,
                Name = "Ahmet"
            },
            new Student()
            {
                Id = 3,
                Name = "Veli"
            }
        };
    }
 
    static void Main()
    {
        var studentsQuery =
            from s in CreateStudents.StudentsList
            where s.Id > 1
            select s;
 
        foreach (var item in CreateStudents.StudentsList)
        {
            Console.WriteLine(item.Name);
        }
 
        Console.WriteLine("--");
 
        foreach (var item in studentsQuery)
        {
            Console.WriteLine(item.Id);
        }
    }
}
-
-
-
-
-
-
Declarative Programming / Imperative Programming  (GITHUB)

Declarative nedir, imperative nedir, declarative programming nedir, imperative programming nedir

In computer science, declarative programming is a programming paradigm that expresses the logic of a computation without describing its control flow.

Declarative programming is when you say what you want, and imperative language is when you say how to get what you want.


İmperative: Emir verebilirsin


Imperative programming, anlaşılacağı üzere Emirli. 

Imperative: NASIL yapacağım diye sorar. Kontrol akışı vardır.

Declarative: NE yapacağım diye sorar. Kontrol akışı tanımlamaz, direk computation’a odaklanır.
Stack      (GITHUB)
Stack Nedir
Videoyu izle: https://www.youtube.com/watch?v=HlzAtIHFRk0
 
Resmi incele.

Value type olanlar (örneğin int) ---> Stack içinde saklanır.
Pointer'lar da Stack içinde saklanır.
Ama objeler Heap içinde saklanır.

Yani neymiş, örneğin Report report = new Report(); deyince; buradaki report, (YANİ OBJE DEĞİL, POINTER!) -- STACK içinde tutuluyor. AMA report aracılığıyla üretilen yeni OBJE HEAP'TE TUTULUYOR. Güzel bilgi bu… 
Dikkat et… report dediğin şey bir pointer'dir, objenin kendisi değildir. Inıtialize yapıyorsan bu pointer gidip bir OBJE üretecektir. Ama kendisi, yani report, o yeni üretilen objeye işaret eden bir pointer'dir.

Report report2 = report; deyince görüldüğü üzere yeni bir obje üretmedik. Zaten initialization olmadığı belli… new Report(); deyip constructor çalıştırmadık veya bir property'sine bir değer atamadık. Yani yeni bir obje oluşmamış oldu. Yani aynı referansı tutuyor report ile…..
-
-
-
-
-
-
ORM (Object relational Mapping)  (GITHUB)

İlişkisel veritabanı (RDBMS) ile nesneye yönelik programlanın arasında bir tür köprü özelliği gören ve ilişkisel veritabanındaki bilgilerimizi yönetmek için, nesne modellerimizi kullandığımız bir tekniktir”. Basite indirgemek istersek: “Nesnelerimizi ilişkisel veritabanındaki tablomuza bağlayan ve veri alış-verişini bizim için yapan bir tekniktir/metodtur”. ORM tekniği belli bir programlama diline bağlı değildir ve her OO dilinde yazılabilir/kullanılabilir.
-
-
-
-
-
-
ADO.NET  (GITHUB)
Ado nedir ado.net nedir
Microsoft'un veriye erişme teknolojisinin adıdır. 
ADO.NET temelde bir teknoloji olarak görülmektedir. Tamamen bir ORM aracı değildir.
Veritabanı ile C# dilini konuşturmak için kullanılan teknolojilerden bir tanesidir. ADO.NET bir programlama dili değildir.

ActiveX teknolojisi ile geliştirilmiştir. ADO.NET'e temel olan teknoloji ADO'dur. Ortak olan, veriye erişim felsefesidir. ADO.NET, .NET Framework ile geliştirilen veri işlemlerini kolaylaştırır. N katmanlı mimariler geliştirmek için hazırlanmış olup çevrimdışı sistemleri ve XML'e tam destek veren bir sistemdir.
-
-
-
-
-
-
SOA (Service Oriented Architecture) Principles    (GITHUB)
Soa nedir, service oriented architecture nedir
SOA is based on some key principles which are mentioned below
1.	Standardized Service Contract - Services adhere to a service description. A service must have some sort of description which describes what the service is about. This makes it easier for client applications to understand what the service does.
2.	Loose Coupling – (geniş bir yere yayılmış insanlar düşün, yani birbirlerinden uzaklar, birbirlerine bağımlı değiller). Less dependency on each other. This is one of the main characteristics of web services which just states that there should be as less dependency as possible between the web services and the client invoking the web service. So if the service functionality changes at any point in time, it should not break the client application or stop it from working.
3.	Service Abstraction - Services hide the logic they encapsulate from the outside world. The service should not expose how it executes its functionality; it should just tell the client application on what it does and not on how it does it.
4.	Service Reusability - Logic is divided into services with the intent of maximizing reuse. In any development company re-usability is a big topic because obviously one wouldn't want to spend time and effort building the same code again and again across multiple applications which require them. Hence, once the code for a web service is written it should have the ability work with various application types.
5.	Service Autonomy - Services should have control over the logic they encapsulate. The service knows everything on what functionality it offers and hence should also have complete control over the code it contains.
6.	Service Statelessness - Ideally, services should be stateless. This means that services should not withhold information from one state to the other. This would need to be done from either the client application. An example can be an order placed on a shopping site. Now you can have a web service which gives you the price of a particular item. But if the items are added to a shopping cart and the web page navigates to the page where you do the payment, the responsibility of the price of the item to be transferred to the payment page should not be done by the web service. Instead, it needs to be done by the web application.
7.	Service Discoverability - Services can be discovered (usually in a service registry). We have already seen this in the concept of the UDDI, which performs a registry which can hold information about the web service.
8.	Service Composability - Services break big problems into little problems. One should never embed all functionality of an application into one single service but instead, break the service down into modules each with a separate business functionality.
9.	Service Interoperability - Services should use standards that allow diverse subscribers to use the service. In web services, standards as XML and communication over HTTP is used to ensure it conforms to this principle.
-
-
-
-
-
-
Stack
Stack nedir

Stack bir data tipidir; ama abstract bir data tipidir.

In computer science, a stack is an abstract data type that serves as a collection of elements, with two principal operations:
•	push, which adds an element to the collection, and
•	pop, which removes the most recently added element that was not yet removed.
 
Örnek:

Stack myStack = new Stack();
myStack.Push("Hello!!");
myStack.Push(null);
myStack.Push(1);
myStack.Push(2);


https://www.tutorialsteacher.com/csharp/csharp-stack
-
-
-
-
-
-
In computer science, imperative programming is a programming paradigm that uses statements that change a program's state. In much the same way that the imperative mood in natural languages expresses commands, an imperative program consists of commands for the computer to perform. 

Imperative programming focuses on describing how a program operates.
The term is often used in contrast to declarative programming, which focuses on what the program should accomplish without specifying how the program should achieve the result.

In computer science, declarative programming is a programming paradigm—a style of building the structure and elements of computer programs—that expresses the logic of a computation without describing its control flow. 

Declarative Programming devam: Many languages that apply this style attempt to minimize or eliminate side effects by describing what the program must accomplish in terms of the problem domain, rather than describe how to accomplish it as a sequence of the programming language primitives[2](the how being left up to the language's implementation). This is in contrast with imperative programming, which implements algorithms in explicit steps.
-
-
-
-
-
-
Declarative Query Languages: Definition and Examples (GITHUB)

Some well-known general declarative programming languages include Ruby, R and Haskell. SQL (Structured Query Language) is a declarative query language and is the industry standard for relational databases.
Declarative query nedir, declarative query language nedir
The two main paradigms of database query languages are imperative and declarative. Understanding the difference between these two approaches is essential if you’re going to be successful in database development.

If the query languages were human archetypes, imperative languages would be the micromanaging boss who gives instructions down to the final detail.

In the most basic sense, imperative query languages are used to describe how you want something done specifically. This is accomplished with explicit control in a detailed, step-by step manner; the sequence and wording of each line of code plays a critical role.

Some well-known general imperative programming languages include Python, C and Java.

In the world of graph database technology, there aren’t any purely imperative query languages. However, both Gremlin and the Java API (for Neo4j) include imperative features. These two options provide you with more detailed power over the execution of their task. If written correctly, there are no surprises – you will get exactly what you want done.

However, imperative database query languages can also be limiting and not very user-friendly, requiring an extensive knowledge of the language and deep technical understanding of physical implementation details prior to usage. Writing one part incorrectly creates faulty outcomes.

As a result, imperative languages are more prone to human error. Additionally, users must double-check the environment before and after the query and be prepared to deal with any potential erroneous scenarios.

To better illustrate the differences, imagine you have two children: Isabel and Duncan. Isabel represents an imperative query language and Duncan the declarative query language.

To get the two children to make their beds, you take differing approaches. For Duncan, it is easy. Simply instruct Duncan to make his bed and he will do it however he sees fit. Yet, he might make it differently than you had in mind, especially if you’re a picky parent.

Isabel requires an entirely different process. You must first inform her that she needs both sheets and blankets to make her bed, and that those materials are found on top of her bed. Then she requires step-by-step instructions, such as “spread the sheet over the mattress” and “tuck in the edges.”

The final result will be closely similar to Duncan’s (or perhaps, exactly the same). At the end of the process, both children have their beds made.

Declarative Query Languages: Definition and Examples

All too often, declarative query languages are often defined as being any database query language that is not imperative. However, to define it in such a manner is too broad.

Declarative query languages let users express what data to retrieve, letting the engine underneath take care of seamlessly retrieving it. They function in a more general manner and involve giving broad instructions about what task is to be completed, rather than the specifics on how to complete it. They deal with the results rather than the process, focusing less on the finer details of each task.

Some well-known general declarative programming languages include Ruby, R and Haskell. SQL (Structured Query Language) is a declarative query language and is the industry standard for relational databases.

Using a declarative database query language may also result in better code than what can be created manually, and it is usually easier to understand the purpose of the code written in a declarative language. Declarative query languages are also easier to use as they simply focus on what must be retrieved and do so quickly.

However, declarative languages have their own trade-offs. Users have little to no control over how inputs are dealt with; if there is a bug in the language, the user will have to rely on the providers of the language to fix the problem. Likewise, if the user wants to use a function that the query language doesn’t support, they are often at a loss.

In the previous example of the children, Duncan was able to complete his task in a method faster and easier for his parent than Isabel. However, imagine now that you want to them to wash the dishes.

It is the same process for Isabel: You’d need to walk through each step with her so she can learn how the process works.

For Duncan, however, we have hit a snag. Duncan has never learned how to wash the dishes. You will stay in that impasse with Duncan unless his programming engineers decide to teach him how to wash the dishes. (Duncan isn’t like most children.)

Conclusion

You should select the best query language paradigm for your specific use case. Neither paradigm is better than the other; they each have different strengths for software development.

If your project requires finer accuracy and control, imperative query languages do the job well. If the speed and productivity of the development process matter more, declarative languages offer the flexibility of getting results without as much effort. Ultimately, the choice depends on you.
-
-
-
-
-
-
LINQ  (GITHUB)
Linq nedir
Language-Integrated Query (LINQ) is the name for a set of technologies based on the integration of query capabilities directly into the C# language. Traditionally, queries against data are expressed as simple strings without type checking at compile time or IntelliSense support. Furthermore, you have to learn a different query language for each type of data source: SQL databases, XML documents, various Web services, and so on. With LINQ, a query is a first-class language construct, just like classes, methods, events. You write queries against strongly typed collections of objects by using language keywords and familiar operators. The LINQ family of technologies provides a consistent query experience for objects (LINQ to Objects), relational databases (LINQ to SQL), and XML (LINQ to XML).
For a developer who writes queries, the most visible "language-integrated" part of LINQ is the query expression. Query expressions are written in a declarative query syntax. By using query syntax, you can perform filtering, ordering, and grouping operations on data sources with a minimum of code. You use the same basic query expression patterns to query and transform data in SQL databases, ADO .NET Datasets, XML documents and streams, and .NET collections.
You can write LINQ queries in C# for SQL Server databases, XML documents, ADO.NET Datasets, and any collection of objects that supports IEnumerable or the generic IEnumerable<T> interface. LINQ support is also provided by third parties for many Web services and other database implementations.
The following example shows the complete query operation. The complete operation includes creating a data source, defining the query expression, and executing the query in a foreach statement.
C#Copy
class LINQQueryExpressions
{
    static void Main()
    {
        
        // Specify the data source.
        int[] scores = new int[] { 97, 92, 81, 60 };

        // Define the query expression.
        IEnumerable<int> scoreQuery =
            from score in scores
            where score > 80
            select score;

        // Execute the query.
        foreach (int i in scoreQuery)
        {
            Console.Write(i + " ");
        }            
    }
}
// Output: 97 92 81
The following illustration from Visual Studio shows a partially-completed LINQ query against a SQL Server database in both C# and Visual Basic with full type checking and IntelliSense support:
 
Query expression overview
•	Query expressions can be used to query and to transform data from any LINQ-enabled data source. For example, a single query can retrieve data from a SQL database, and produce an XML stream as output.
•	Query expressions are easy to master because they use many familiar C# language constructs.
•	The variables in a query expression are all strongly typed, although in many cases you do not have to provide the type explicitly because the compiler can infer it. For more information, see Type relationships in LINQ query operations.
•	A query is not executed until you iterate over the query variable, for example, in a foreach statement. For more information, see Introduction to LINQ queries.
•	At compile time, query expressions are converted to Standard Query Operator method calls according to the rules set forth in the C# specification. Any query that can be expressed by using query syntax can also be expressed by using method syntax. However, in most cases query syntax is more readable and concise. For more information, see C# language specification and Standard query operators overview.
•	As a rule when you write LINQ queries, we recommend that you use query syntax whenever possible and method syntax whenever necessary. There is no semantic or performance difference between the two different forms. Query expressions are often more readable than equivalent expressions written in method syntax.
•	Some query operations, such as Count or Max, have no equivalent query expression clause and must therefore be expressed as a method call. Method syntax can be combined with query syntax in various ways. For more information, see Query syntax and method syntax in LINQ.
•	Query expressions can be compiled to expression trees or to delegates, depending on the type that the query is applied to. IEnumerable<T> queries are compiled to delegates. IQueryable and IQueryable<T> queries are compiled to expression trees. For more information, see Expression trees.
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Hello World!");
 
        // Specify the data source.
 
        int[] scores = new int[] { 97, 92, 81, 60 };
 
        // Define the query expression.
        // Burada List<int> yazamayız. listemiz IEnumerable olmalıdır:
 
        IEnumerable<int> scoreQuery =
            from score in scores
            where score > 80
            select score;
 
        // Execute the query:
 
        foreach (int i in scoreQuery)
        {
            Console.WriteLine(i + "(scoreQuery");
        }
 
        // Yukarıda Ienumerable bir değişkenin içinde döndüğümüze dikkat edelim. Yani toList işlemi yapmadan içinde dönmüş olduk.
 
        // Yukarıdaki IEnumerable olan scoreQuery üzerinde ToList işlemi yapabiliriz ve oluşacak yeni değeri bir değişkene atayabiliriz
        // Aşağıda bunu yapıyoruz:
 
        List<int> toListtenGelenList = scoreQuery.ToList();
 
        // ToList metodunun ne yaptığını okuyalım şunu yapıyor, çok önemli:
 
        // Ienumerable<out T> tipinden List<T> tipine dönüşüm sağlıyor. --> english -->
        // Creates a List<T> from an IEnumerable<T>.
 
        // şimdi tolist ile listeye dönüştürdüğümüz değişkenin içinde dönelim ve değerleri ekrana yazdıralım:
 
        foreach (var item in toListtenGelenList)
        {
            Console.WriteLine(item + "(toListtenGelenList)");
        }
 
        Console.ReadKey();
    }
}

-
-
-
-
-
-
Runtime vs Compile time
Runtime nedir, compile time nedir,  run time nedir, compile nedir
Runtime and compile time are programming terms that refer to different stages of software program development. Compile-time is the instance where the code you entered is converted to executable while Run-time is the instance where the executable is running. The terms "runtime" and "compile time" are often used by programmers to refer to different types of errors too.
Compile-time checking occurs during the compile time. Compile time errors are error occurred due to typing mistake, if we do not follow the proper syntax and semantics of any programming language then compile time errors are thrown by the compiler. They wont let your program to execute a single line until you remove all the syntax errors or until you debug the compile time errors. The following are usual compile time errors:
	Syntax errors
	Typechecking errors
	Compiler crashes (Rarely)
Run-time type checking happens during run time of programs. Runtime errors are the errors that are generated when the program is in running state. These types of errors will cause your program to behave unexpectedly or may even kill your program. They are often referred as Exceptions . The following are some usual runtime errors:
	Division by zero
	Dereferencing a null pointer
	Running out of memory
-
-
-
-
-
-
Stateless - Stateful
stateless nedir, stateful nedir
Stateful and stateless are adjectives that describe whether a computer or computer program is designed to note and remember one or more preceding events in a given sequence of interactions with a user, another computer or program, a device, or other outside element. 
Stateful means the computer or program keeps track of the state of interaction, usually by setting values in a storage field designated for that purpose. 
Stateless means there is no record of previous interactions and each interaction request has to be handled based entirely on information that comes with it. 
Stateful and stateless are derived from the usage of state as a set of conditions at a moment in time. (Computers are inherently stateful in operation, so these terms are used in the context of a particular set of interactions, not of how computers work in general.)
The Internet's basic protocol, the Internet Protocol ( IP ), is an example of a stateless interaction. Each packet travels entirely on its own without reference to any other packet. When you request a Web page from a Web site, the request travels in one or more packets, each independent of the other as far as the Internet Protocol program itself is concerned. (The upper layer Transmission Control Protocol - TCP - does relate packets to each other, but uses the information within the packet rather than some external information to do this.) The term connectionless is also used to describe communication in which a connection is made and terminated for each message that is sent. IP is connectionless as well as stateless.
The Web's Hypertext Transfer Protocol ( HTTP ), an application layer above TCP/IP, is also stateless. Each request from a user for a Web page or URL results in the requested pages being served, but without the Web (HTTP) server remembering the request later. In other words, there is no recorded continuity. Each communication is discrete and unrelated to those that precede or follow. In order to have stateful communication, a site developer must furnish a special program that the server can call that can record and retrieve state information. Web browsers such as Netscape Explorer and Microsoft Internet Explorer provide an area in their subdirectories where state information can be stored and accessed. The area and the information that Web browsers and server applications put in this area is called a cookie .
In formal protocol specifications, a finite state machine is an abstract desciption of how a stateful system works that describes the action that follows each possible state.
The Internet (including the World Wide Web) can be thought of as a stateless system or machine. Most computers, human beings, and elephants are stateful.
-
-
-
-
-
-
Query String
Query string nedir, stateless nedir
ÇOK ÖNEMLİ TEXT:
A query string is the portion of a URL where data is passed to a web application and/or back-end database. The reason we need query strings is that the HTTP protocol is stateless by design. For a website to be anything more than a brochure, you need to maintain state (store data). 
There are a number of ways to do this: On most web servers, you can use something like session state server-side. On the client, you can store via cookies. Or in the URL, you can store data via a query string. 

On the world wide web, all URLs can be broken down into the protocol, the location of the file (or program) and the query string. The protocol you see in a browser is almost always HTTP; the location is the typical form of the hostname and filename (for example, www.techopedia.com/somefile.html), and the query string is whatever follows the question mark sign ("?").
For example, in the URL below, the bolded area is the query string that was generated when the term "database" was searched on the Techopedia website.
//www.techopedia.com/search.aspx?q=database§ion=all
-
-
-
-
-
-
IIS- Internet Information Services  (GITHUB)
IIS nedir, iis nedir
Stands for "Internet Information Services." IIS is a web server software package designed for Windows Server. It is used for hosting websites and other content on the Web.
Microsoft’s Internet Information Services provides a graphical user interface (GUI) for managing websites and the associated users. It provides a visual means of creating, configuring, and publishing sites on the web. The IIS Manager tool allows web administrators to modify website options, such as default pages, error pages, logging settings, security settings, and performance optimizations.
IIS can serve both standard HTML webpages and dynamic webpages, such as ASP.NET applications and PHP pages. When a visitor accesses a page on a static website, IIS simply sends the HTML and associated images to the user’s browser. When a page on a dynamic website is accessed, IIS runs any applications and processes any scripts contained in the page, then sends the resulting data to the user’s browser.
While IIS includes all the features necessary to host a website, it also supports extensions (or “modules”) that add extra functionality to the server. For example, the WinCache Extension enables PHP scripts to run faster by caching PHP processes. The URL Rewrite module allows webmasters to publish pages with friendly URLs that are easier for visitors to type and remember. A streaming extension can be installed to provide streaming media to website visitors.
IIS is a popular option for commercial websites, since it offers many advanced features and is supported by Microsoft. However, it also requires requires a commercial license and the pricing increases depending on the number of users. Therefore, Apache HTTP Server, which is open source and free for unlimited users, remains the most popular web server software.

Internet Information Service (IIS), Microsoft firmasının Windows işletim sistemlerinde ve sunucularında kullandığı, Web servisini sunan alt yazılımdır.
-
-
-
-
-
-
CakePHP 	(GITHUB)
CakePHP is an open-source web framework. It follows the model–view–controller (MVC) approach and is written in PHP, modeled after the concepts of Ruby on Rails, and distributed under the MIT License.

CakePHP uses well-known software engineering concepts and software design patterns, such as convention over configuration, model–view–controller, active record, association data mapping, and front controller.

CakePHP started in April 2005, when a Polish programmer Michal Tatarynowicz[3] wrote a minimal version of a rapid application development framework in PHP, dubbing it Cake.[4][5][6] He published the framework under the MIT license, and opened it up to the online community of developers. In December 2005, L. Masters and G. J. Woodworth founded the Cake Software Foundation to promote development related to CakePHP.[6] Version 1.0 was released in May 2006.

One of the project's inspirations was Ruby on Rails, using many of its concepts. The community has since grown and spawned several sub-projects.
-
-
-
-
-
-
Android SDK 	 (GITHUB)
Sdk nedir, android sdk nedir
The Android SDK (software development kit) is a set of development tools used to develop applications for Android platform. 
The Android SDK includes the following:
Required libraries
Debugger
An emulator
Relevant documentation for the Android application program interfaces (APIs)
Sample source code
Tutorials for the Android OS
-
-
-
-
-
-
Android 	(GITHUB)
Android nedir, android operation system nedir, android işletim sistemi nedir
Android; Google ve Open Handset Alliance tarafından, mobil cihazlar için geliştirilmekte olan, Linux tabanlı özgür ve ücretsiz bir işletim sistemidir.
Google Android OS is Google’s Linux-based open source operating system for mobile devices. Android has been the world’s most widely used smartphone platform as of 2010, with a worldwide smartphone market share of 75%.
Android is a mobile operating system based on a modified version of the Linux kernel and other open source software, designed primarily for touchscreen mobile devices such as smartphones and tablets. Android is developed by a consortium of developers known as the Open Handset Alliance, with the main contributor and commercial marketer being Google.

Initially developed by Android Inc., which Google bought in 2005, Android was unveiled in 2007, with the first commercial Android device launched in September 2008. The current stable version is Android 10, released on September 3, 2019. The core Android source code is known as Android Open Source Project (AOSP), which is primarily licensed under the Apache License. This has allowed variants of Android to be developed on a range of other electronics, such as game consoles, digital cameras, PCs and others, each with a specialized user interface. Some well known derivatives include Android TV for televisions and Wear OS for wearables, both developed by Google.
-
-
-
-
-
-
Encapsulation
encapsulation nedir
Encapsulation is implemented by using access specifiers. An access specifier defines the scope and visibility of a class member. C# supports the following access specifiers −
•	Public
•	Private
•	Protected
•	Internal
•	Protected internal

Encapsulation is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates. In a different way, encapsulation is a protective shield that prevents the data from being accessed by the code outside this shield.
•	Technically in encapsulation, the variables or data of a class are hidden from any other class and can be accessed only through any member function of own class in which they are declared.
•	As in encapsulation, the data in a class is hidden from other classes, so it is also known as data-hiding.
•	Encapsulation can be achieved by: Declaring all the variables in the class as private and using C# Properties in the class to set and get the values of variables.
 

using System;
  
public class DemoEncap
{
    // private variables declared 
    // these can only be accessed by public methods of class 
    private String studentName;
    private int studentAge;
 
    // using accessors to get and set the value of studentName 
    public String Name
    {
        get
        {
            return studentName;
        }
 
        set
        {
            studentName = value;
        }
    }
 
    // using accessors to get and set the value of studentAge 
    public int Age
    {
        get
        {
            return studentAge;
        }
 
        set
        {
            studentAge = value;
        }
    }
}
 
// Driver Class 
class GFG
{
 
    // Main Method 
    static public void Main()
    {
 
        // creating object 
        DemoEncap obj = new DemoEncap();
 
        // calls set accessor of the property Name,  
        // and pass "Ankita" as value of the  
        // standard field 'value' 
        obj.Name = "Ankita";
 
        // calls set accessor of the property Age,  
        // and pass "21" as value of the  
        // standard field 'value' 
        obj.Age = 21;
 
        // Displaying values of the variables 
        Console.WriteLine("Name: " + obj.Name);
        Console.WriteLine("Age: " + obj.Age);
    }
}

 
Output:
Name: Ankita
Age: 21
Explanation: In the above program the class DemoEncap is encapsulated as the variables are declared as private. To access these private variables we are using the Name and Age accessors which contains the get and set method to retrieve and set the values of private fields. Accessors are defined as public so that they can access in other class.

Advantages of Encapsulation:
•	Data Hiding: The user will have no idea about the inner implementation of the class. It will not be visible to the user that how the class is stored values in the variables. He only knows that we are passing the values to accessors and variables are getting initialized to that value.
•	Increased Flexibility: We can make the variables of the class as read-only or write-only depending on our requirement. If we wish to make the variables as read-only then we have to only use Get Accessor in the code. If we wish to make the variables as write-only then we have to only use Set Accessor.
•	Reusability: Encapsulation also improves the re-usability and easy to change with new requirements.
•	Testing code is easy: Encapsulated code is easy to test for unit testing.
-
-
-
-
-
-
The .NET Core command-line interface (CLI)   (GITHUB)
cli nedir
The .NET Core command-line interface (CLI) is a new cross-platform toolchain for developing .NET applications. The CLI is a foundation upon which higher-level tools, such as Integrated Development Environments (IDEs), editors, and build orchestrators, can rest.
-
-
-
-
-
-
Result set   (GITHUB)
Result set nedir
An SQL result set is a set of rows from a database, as well as metadata about the query such as the column names, and the types and sizes of each column. Depending on the database system, the number of rows in the result set may or may not be known. Usually, this number is not known up front because the result set is built on-the-fly.

A result set is effectively a table. The ORDER BY clause can be used in a query to impose a certain sort condition on the rows. Without that clause, there is no guarantee whatsoever on the order in which the rows are returned.
-
-
-
-
-
-
Microsoft Azure HDInsight
Microsoft Azure HDInsight nedir
Azure HDInsight is a cloud-based service from Microsoft for big data analytics that helps organizations process large amounts of streaming or historical data. Microsoft promotes HDInsight for applications in data warehousing and ETL (extract, transform, load) scenarios as well as machine learning and Internet of Things (IoT) environments.
The fully-managed and open source service is based on the Hortonworks Data Platform (HDP) Hadoop distribution and includes implementations of Apache products, including:
•	Spark
•	HBase
•	Storm
•	Pig
•	Hive
•	Sqoop
•	Oozie
•	Ambari
HDInsight enables integration with business intelligence tools like Power BI, Excel, SQL Server Analysis Services and SQL Server Reporting Services. The service's security measures for data include encryption, monitoring, virtual networks, Active Directory authentication, authorization and role-based access control (RBAC).
Açık kaynak analize yönelik uygun maliyetli, kurumsal sınıf bir hizmet olan Azure HDInsight’ı kullanarak Apache Hadoop, Spark ve Kafka dahil olmak üzere popüler açık kaynak çerçeveleri kolayca çalıştırın. Azure’ın küresel ölçeği sayesinde çok büyük miktarda veriyi hiç çaba harcamadan işleyin ve geniş açık kaynak ekosisteminin tüm avantajlarına sahip olun.

-
-
-
-
-
-
ANSI C
Ansi c nedir, ANSI C nedir, ISO c nedi, iso c nedir

ANSI C, ISO C and Standard C are successive standards for the C programming language published by the American National Standards Institute (ANSI) and the International Organization for Standardization (ISO). Historically, the names referred specifically to the original and best-supported version of the standard (known as C89 or C90). Software developers writing in C are encouraged to conform to the standards, as doing so helps portability between compilers.
-
-
-
-
-
-
MySQL, MsSQL, T-SQL, Oracle, PL-SQL, SQL 	(GITHUB)
MySQL nedir, MsSQL nedir, T-SQL nedir, t sql nedir, tsql nedir, oracle nedir, plsql nedir, pl-sql nedir, pl/sql nedir
MsSQL -> T-SQL
MySQL -> SQL
Oracle --> PL/SQL
https://db-engines.com/en/system/Microsoft+SQL+Server%3BMySQL%3BOracle

MySQL is a database itself that uses SQL language.
PL/SQL is an extension of Structured Query Language (SQL) that is used in Oracle. Oracle is a Database (RDBMS).
Biz T-SQL üzerinden çalışıyoruz (MSSQL'de), peki MySQL nedir?
MySQL is an open source SQL database, which is developed by a Swedish company – MySQL AB. MySQL is pronounced as "my ess-que-ell," in contrast with SQL, pronounced "sequel."
MySQL is supporting many different platforms including Microsoft Windows, the major Linux distributions, UNIX, and Mac OS X.
MySQL has free and paid versions, depending on its usage (non-commercial/commercial) and features. MySQL comes with a very fast, multi-threaded, multi-user and robust SQL database server.
PL/SQL vs MySQL
DESCRIPTION- in one sentence we can actually find the major differnce btw them, see plsql is basically a DATABASE PROGRAMMING LANGUAGE that is used in ORACLE DATABASE.
1.	and MYSQL is itself is database which that uses SQL programming language and SQL is just a ANSI standard, and is used as a base with most Database systems, like Microsoft SQL Server, Oracle, MySQL, IBM DB2 have used this as a base and extended/enhanced in their database systems.

SQL vs MySQL
KEY DIFFERENCE:
•	SQL is a language which is used to operate your database whereas MySQL was one of the first open-source database available in the market
•	SQL is used in the accessing, updating, and manipulation of data in a database while MySQL is an RDBMS that allows keeping the data that exists in a database organized
•	SQL is a Structured Query Language and MySQL is a RDBMS to store, retrieve, modify and administrate a database.
•	SQL is a query language while MYSQL is a database software

MS SQL 
MsSQL Server is a Relational Database Management System (RDBMS) developed by Microsoft Inc. Its primary query languages are − T-SQL, ANSI SQL

Oracle
It is a very large multi-user based database management system. Oracle is a relational database management system developed by 'Oracle Corporation'.

Oracle works to efficiently manage its resources, a database of information among the multiple clients requesting and sending data in the network.
It is an excellent database server choice for client/server computing. Oracle supports all major operating systems for both clients and servers, including MSDOS, NetWare, UnixWare, OS/2 and most UNIX flavors.
PL/SQL is an Oracle's procedural language extension to SQL. It is a server-side, stored procedural language that is easy-to-use, seamless with SQL, portable, and secure. PL/SQL enables you to mix SQL statements with procedural constructs.
- - -
Oracle ile MYSQL arasındaki farklar üzerine:
SQL is a database language used with Oracle Database.
MySQL is a database itself that uses SQL language.
The difference is that MySQL is free, and the world's most popular database, and Oracle isn't free (except with trials and certain products) and makes billions from selling premium database software to large enterprises and SME.

There are many more differences between Oracle and MySQL.We can summarise them as follows-
1.Oracle is way more powerful than MySQL
2.Oracle supports distributed databases while MySQL doesn’t
3.Oracle supports save points while MySQL doesn’t
4.Oracle allows programs within the database while MySQL doesn’t
5.Oracle is suited for enterprise deployments while MySQL is suited for small to medium scale
6.Oracle requires that you pay a licensing fee while MySQL doesn’t

-- Daha anlamlı bir açıklama:

This might be a slightly controversial view ( and this is all in my opinion).
   
I have been a Developer for most of my career and I have used an old hierarchical DB, called HP Image 3000, Oracle, MS SQL and MySQL.
IMO, there is a lot of snobbery around Oracle. Its very good, but very expensive and in my opinion largely unnecessary and over used.
When you consider how many large companies and applications use MySQL without any issue, it will cope with 90% of demand. Hardware is so powerful now and the original concerns about performance are largely negated by the raw power of the hardware. Oracle should be a niche market and not a large player, as it really isn’t needed.
I worked for a large American company who used Oracle, I asked why, they said because its the best, I persisted and said what do you mean, they had no answer.
MySQL will be fine for most things and as its free, why not use that. The advent of cloud computing and the pricing model of many data centers, makes licencing very expensive (virtual CPU’s cores) for both Oracle and MS SQL.
Facebook, Uber and Google, used/use MySQL, so the idea its not scalable, is a bit ridiculous.
What is sad and I really mean it, is that the traditional IT Operations and the DBA role in IT, will slowly disappear, as its not really needed unless in some extreme situations.
-- Diğer açıklama:

Oracle is a Database tool that uses PL/SQL language.
MySQL is a also a Database tool itself that uses SQL language.

	What is PL/SQL?
Pl-sql nedir plsql nedir pl/sql nedir
PL/SQL is an extension of Structured Query Language (SQL) that is used in Oracle. Unlike SQL, PL/SQL allows the programmer to write code in a procedural format. Full form of PL/SQL is "Procedural Language extensions to SQL".
It combines the data manipulation power of SQL with the processing power of procedural language to create super powerful SQL queries.
PL/SQL means instructing the compiler 'what to do' through SQL and 'how to do' through its procedural way.
Similar to other database languages, it gives more control to the programmers by the use of loops, conditions and object-oriented concepts.

-
-
-
-
-
-
NoSQL	(GITHUB)
Nosql nedir
https://www.kdnuggets.com/2016/06/top-nosql-database-engines.html
İlişkisiz veritabanıdır. NoSQL is not a relational database.
Bir NoSQL veritabanında, kayıtlar genellikle bir JSON belgesi olarak saklanır.
Why NoSQL? It's high performance with high availability, and offers rich query language and easy scalability.

NoSQL (ilişkisel olmayan) Veritabanları Nasıl Çalışır?
NoSQL veritabanları, verilere erişmek ve verileri yönetmek için belge, grafik, anahtar-değer, bellek içi ve arama dahil olmak üzere çeşitli veri modelleri kullanır. Bu tür veritabanları, özellikle büyük veri hacmi, düşük gecikme süresi ve esnek veri modelleri gerektiren uygulamalar için optimize edilmiştir. Bu gereksinimler, diğer veritabanlarının veri tutarlılığı kısıtlamalarının bir kısmı esnetilerek karşılanır.
NoSQL is a whole new way of thinking about a database. NoSQL is not a relational database. The reality is that a relational database model may not be the best solution for all situations. The easiest way to think of NoSQL, is that of a database which does not adhering to the traditional relational database management system (RDMS) structure. Sometimes you will also see it revered to as 'not only SQL'.

Imagine that you have coupons that you wanted to push to mobile customers that purchase a specific item. This is a customer facing system of engagement requires location data, purchase data, wallet data, and so on. You want to engage the mobile customer in real-time.

What you require is a very agile delivery system that is easily able to processes unstructured data. The system of engagement would need to be extremely dynamic. 

Basit bir kitap veritabanının şemasını modelleme örneğini ele alalım:
•	İlişkisel bir veritabanında genellikle bir kitap kaydı gizlenerek (veya “normalleştirilerek”) ayrı tablolarda depolanırken, ilişkiler birincil ve yabancı anahtar kısıtlamaları tarafından tanımlanır. Bu örnekte Books (Kitaplar) tablosu ISBN, Book Title (Kitap Başlığı) ve Edition Number (Baskı Sayısı) sütunlarına; Authors (Yazarlar) tablosu AuthorID (Yazar Kimliği) ve Author Name (Yazar Adı) sütunlarına; Author-ISBN (Yazar-ISBN) tablosu ise AuthorID (Yazar Kimliği) ve ISBN sütunlarına sahiptir. İlişkisel model, veritabanının yedekliliği azaltacak şekilde normalleştirilmiş ve genel olarak depolama için optimize edilmiş tablolar arasında başvurusal bütünlük uygulamasına imkan tanıyacak şekilde tasarlanmıştır.
•	Bir NoSQL veritabanında, kitap kaydı genellikle bir JSON belgesi olarak saklanır. Her kitap için öğe, ISBN, Book Title (Kitap Başlığı), Edition Number (Baskı Sayısı), Author Name (Yazar Adı) ve AuthorID (Yazar Kimliği) bilgileri tek bir belgede öznitelikler olarak depolanır. Bu modelde, veriler sezgisel yazılım geliştirme ve yatay ölçeklenebilirlik için optimize edilir.

Neden NoSQL veritabanı kullanmalısınız?
NoSQL veritabanları, harika kullanıcı deneyimleri sunulması amacıyla esnek, ölçeklenebilir, yüksek performanslı ve yüksek oranda işlevsel veritabanları gerektiren mobil, web ve oyun gibi birçok modern uygulama için idealdir.
•	Esneklik: NoSQL genellikle daha hızlı ve daha fazla yinelemeli yazılım geliştirmeyi mümkün kılan esnek şemalar sağlar. Esnek veri modeli sayesinde NoSQL veritabanları yarı yapılandırılmış ve yapılandırılmamış veriler için idealdir.
•	Ölçeklenebilirlik: NoSQL veritabanları genellikle pahalı ve kalıcı sunucular eklenerek ölçeği artırılabilecek şekilde değil, dağıtılmış donanım kümeleri kullanılarak ölçeği genişletilebilecek şekilde tasarlanır. Bazı bulut sağlayıcıları bu işlemleri arka planda, tam olarak yönetilen bir hizmet olarak gerçekleştirir.
•	Yüksek performans: NoSQL veritabanları, benzer işlevlerin ilişkisel veritabanlarıyla gerçekleştirilmesi ile karşılaştırıldığında daha yüksek performansı mümkün kılan belirli veri modelleri (belge, anahtar-değer, grafik gibi) ve erişim desenleri için optimize edilmiştir.
•	Yüksek oranda işlevsel: NoSQL veritabanları, her biri ilgili veri modeli için özel olarak tasarlanmış yüksek oranda işlevsel API'ler ve veri türleri sağlar.
-
-
-
-
-
-
MongoDb		(GITHUB)
Mongodb nedir

MongoDB is the most well known among NoSQL Databases. It is an Open-Source database which is Document-oriented. MongoDB is a scalable and accessible database. It is in C++. MongoDB can likewise be utilized as the file system. In MongoDB, JavaScript can be utilized as the query language. By utilizing sharding MongoDB scales horizontally. It is very useful in Popular JavaScript Frameworks. People really enjoying sharding, advanced text searching, gridFS, map-reduce features for the 2019 year. Amazing performance and new features promoted this NoSQL database to 1st place in our list.
•	
Latest version: 4.0.8
•	Blog: MongoDB
•	Developed by: MongoDB Inc. in 2007
•	Download: MongoDB
FEATURES
•	Provides high performance
•	Auto-sharding
•	Run over multiple servers
•	Supports Master-Slave replication
•	Data is stored in the form of JSON style documents
•	index any field in a document
•	It has an automatic load balancing configuration because of data placed in shards
•	Supports regular expression searches
•	Easy to administer in the case of failures
PROS OF MONGODB
•	Easy to setup MongoDB
•	MongoDB Inc. provides professional support to its clients
•	Support ad-hoc query
•	High-Speed Database
•	Schema-less database
•	Horizontally scalable database
•	Performance is very high
CONS OF MONGODB
•	Doesn’t support joins
•	Data Size is High
•	Nesting of documents is limited
•	Increase unnecessary usage of memory

Bir veritabanıdır, ilişkisiz veritabanıdır -> MongoDB is a general purpose, document-based, distributed database built for modern application developers and for the cloud era. No database makes you more productive.

(Distributed database'yi bi sonraki çalışmada inceleyelim..)

MongoDB (“humongous”); MongoDB Inc. tarafından ölçeklenebilir, doküman tabanlı, C++ ile geliştirilmiş açık kaynak, NoSQL (ilişkisiz veritabanı) veritabanı uygulamasıdır. MongoDB, verileri JSON tipinde dokümanlarda saklamaktadır, anlamsal alanları dokümandan dokümana değişir ve veri yapısı zaman içinde değiştirilebilir. Belge modeli, uygulamanızın kodundaki nesnelerle eşleştirilir, böylece verilerin kullanımı kolaylaşır. Geçici sorgular, dizin oluşturmak için ve gerçek zamanlı verilerinize erişmek ve analiz etmek için güçlü yollar sağlar. MongoDB, özellikle hız gerektiren ve geleneksel ilişkisel veritabanlarının (RDBMS) hantal ve yavaş kaldığı yapılarda kullanılmaktadır.MongoDB, dağıtılmış bir veritabanı yapısına sahiptir, bu nedenle yüksek erişilebilirlik, yatayda ve dikeyde ölçeklendirme yapılabilmektedir. MongoDB, GNU Affero Genel Kamu Lisansı uyarınca yayınlanan ücretsiz ve açık kaynaktır.
Örnek kullanım alanları arasında:
•	Yüksek hacim/içerikli problemler
•	Analiz için veri saklanması
•	MMORPG uygulamaları
•	Caching sistemleri
•	Web içerik yönetim sistemleri
•	Web yorum/etiket saklama ve yönetme
İkililer, Windows, Mac OS X, Linux ve Solaris için mevcuttur.
-
-
-
-
-
-
Redis (Remote Dictionary Server)	   (GITHUB)
Redis nedir
Redis, bir milisaniyenin altında yanıt süreleri sunan, açık kaynak kodlu bir bellek içi veri deposudur. 
Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes with radius queries and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.

Redis (/ˈrɛdɪs/; Remote Dictionary Server) is an in-memory data structure project implementing a distributed, in-memory key-value database with optional durability. Redis supports different kinds of abstract data structures, such as strings, lists, maps, sets, sorted sets, HyperLogLogs, bitmaps, streams, and spatial indexes. The project is mainly developed by Salvatore Sanfilippo and as of 2019, is sponsored by Redis Labs.[8] It is open-source software released under a BSD 3-clause license.

History
The name Redis means REmote DIctionary Server.[6] The Redis project began when Salvatore Sanfilippo, nicknamed antirez, the original developer of Redis, was trying to improve the scalability of his Italian startup, developing a real-time web log analyzer. After encountering significant problems in scaling some types of workloads using traditional database systems, Sanfilippo began to prototype a first proof of concept version of Redis in Tcl.[9] Later Sanfilippo translated that prototype to the C language and implemented the first data type, the list. After a few weeks of using the project internally with success, Sanfilippo decided to open source it, announcing the project on Hacker News. The project began to get traction, more so among the Ruby community, with GitHub and Instagram being among the first companies adopting it. 

-
-
-
-
-
-
Difference between scaling horizontally and vertically for databases		(GITHUB)

Horizontal scaling nedir, vertical scaling nedir

Horizontal scaling means that you scale by adding more machines into your pool of resources whereas Vertical scaling means that you scale by adding more power (CPU, RAM) to an existing machine.
An easy way to remember this is to think of a machine on a server rack, we add more machines across the horizontal direction and add more resources to a machine in the vertical direction.
                   
In a database world horizontal-scaling is often based on the partitioning of the data i.e. each node contains only part of the data, in vertical-scaling the data resides on a single node and scaling is done through multi-core i.e. spreading the load between the CPU and RAM resources of that machine.
With horizontal-scaling it is often easier to scale dynamically by adding more machines into the existing pool - Vertical-scaling is often limited to the capacity of a single machine, scaling beyond that capacity often involves downtime and comes with an upper limit.
Good examples of horizontal scaling are Cassandra, MongoDB, Google Cloud Spanner .. and a good example of vertical scaling is MySQL - Amazon RDS (The cloud version of MySQL). It provides an easy way to scale vertically by switching from small to bigger machines. This process often involves downtime.
In-Memory Data Grids such as GigaSpaces XAP, Coherence etc.. are often optimized for both horizontal and vertical scaling simply because they're not bound to disk. Horizontal-scaling through partitioning and vertical-scaling through multi-core support.
-
-
-
-
-
-
Distributed database / DDBMS
Distributed database nedir? DDBMS nedir (distributed database management system)
A distributed database is a database that consists of two or more files located in different sites either on the same network or on entirely different networks. Portions of the database are stored in multiple physical locations and processing is distributed among multiple database nodes.
Önemli notlar: 
Distributed databases are capable of modular development, meaning that systems can be expanded by adding new computers and local data to the new site and connecting them to the distributed system without interruption.
When failures occur in centralized databases, the system comes to a complete stop. When a component fails in distributed database systems, however, the system will continue to function at reduced performance until the error is fixed.
Admins can achieve lower communication costs for distributed database systems if the data is located close to where it is used the most. This is not possible in centralized systems.
-not bitiş
Kısa açıklama:
A distributed database is a database in which not all storage devices are attached to a common processor.[1] It may be stored in multiple computers, located in the same physical location; or may be dispersed over a network of interconnected computers. Unlike parallel systems, in which the processors are tightly coupled and constitute a single database system, a distributed database system consists of loosely coupled sites that share no physical components.

A centralized distributed database management system (DDBMS) integrates data logically so it can be managed as if it were all stored in the same location. The DDBMS synchronizes all the data periodically and ensures that data updates and deletes performed at one location will be automatically reflected in the data stored elsewhere.
By contrast, a centralized database consists of a single database file located at one site using a single network.
When in a collection, distributed databases are logically interrelated with each other, and they often represent a single logical database. With distributed databases, data is physically stored across multiple sites and independently managed. The processors on each site are connected by a network, and they don't have any multiprocessing configuration.
A common misconception is that a distributed database is a loosely connected file system. In reality, it's much more complicated than that. Distributed databases incorporate transaction processing, but are not synonymous with transaction processing systems.
In general, distributed databases include the following features:
•	Location independent
•	Distributed query processing
•	Distributed transaction management
•	Hardware independent
•	Operating system independent
•	Network independent
•	Transaction transparency
•	DBMS independent
Distributed database architecture
(homogenous distributed database system nedir, heterogeneous distributed database nedir)
Distributed databases can be homogenous or heterogeneous.
In a homogenous distributed database system, all the physical locations have the same underlying hardware and run the same operating systems and database applications. Homogenous distributed database systems appear to the user as a single system, and they can be much easier to design and manage. For a distributed database system to be homogenous, the data structures at each location must be either identical or compatible. The database application used at each location must also be either identical or compatible.

Features of a distributed database
In a heterogeneous distributed database, the hardware, operating systems or database applications may be different at each location. Different sites may use different schemas and software, although a difference in schema can make query and transaction processing difficult.
Different nodes may have different hardware, software and data structure, or they may be in locations that are not compatible. Users at one location may be able to read data at another location but not upload or alter it. Heterogeneous distributed databases are often difficult to use, making them economically infeasible for many businesses.
Types of distributed databases
Replicated data is used to create instances of data in different parts of the database. By using replicated data, distributed databases can access identical data locally, thus avoiding traffic. Replicated data can be divided into two categories: read-only and writable data.
Read-only versions of replicated data allow revisions only to the first instance; subsequent enterprise data replications are then adjusted. Writable data can be altered, but the first instance is immediately changed.
Horizontally fragmented data involves the use of primary keys that refer to one record in the database. Horizontal fragmentation is usually reserved for situations in which business locations only need to access the database pertaining to their specific branch.
Vertically fragmented data involves using copies of primary keys that are available within each section of the database and are accessible to each branch. Vertically fragmented data is utilized when the branch of a business and the central location interact with the same accounts in different ways.
-
-
-
-
-
-
F10 vs F11	(GITHUB)
Yeni başlayanlar için güzel bir not
https://stackoverflow.com/questions/15584132/what-is-the-difference-between-f10-and-f11-keys-in-visual-studio/39843982
F10 ("step over") does not descend any further into the call stack. It moves to the next line of the current function.
F11 ("step into") drills down into the function being called.
void function1()
{
    function2();
    function3();
}
If you hit a breakpoint on function2(), F10 will advance to the line function3(). F11 will advance to the first line inside function2.
-
-
-
-
-
-
CTRL+F5	(GITHUB)
Yeni başlayanlar için güzel bir not:
Press Ctrl+F5 to run without the debugger.
Ctrl f5 yapınca proje debug olmadığı halde chrome'da kullanılmaya devam ediyor.
https://stackoverflow.com/questions/4118073/how-to-stop-console-from-closing-on-exit
-
-
-
-
-
-
Database Management System - DBMS
Dbms nedir
DBMS: The software which is used to manage database is called Database Management System (DBMS). For Example, MySQL, Oracle etc. are popular commercial DBMS used in different applications. DBMS allows users the following tasks:
Data Definition: It helps in creation, modification and removal of definitions that define the organization of data in database.
Data Updation: It helps in insertion, modification and deletion of the actual data in the database.
Data Retrieval: It helps in retrieval of data from the database which can be used by applications for various purposes.
User Administration: It helps in registering and monitoring users, enforcing data security, monitoring performance, maintaining data integrity, dealing with concurrency control and recovering information corrupted by unexpected failure.
Introduction of DBMS (Database Management System) | Set 1
Important Terminology

Database: Database is a collection of inter-related data which helps in efficient retrieval, insertion and deletion of data from database and organizes the data in the form of tables, views, schemas, reports etc. For Example, university database organizes the data about students, faculty, and admin staff etc. which helps in efficient retrieval, insertion and deletion of data from it.

DDL is short name of Data Definition Language, which deals with database schemas and descriptions, of how the data should reside in the database.

CREATE: to create a database and its objects like (table, index, views, store procedure, function, and triggers)
ALTER: alters the structure of the existing database
DROP: delete objects from the database
(truncate nedir)
TRUNCATE: remove all records from a table, including all spaces allocated for the records are removed
COMMENT: add comments to the data dictionary
RENAME: rename an object
DML is short name of Data Manipulation Language which deals with data manipulation and includes most common SQL statements such SELECT, INSERT, UPDATE, DELETE, etc., and it is used to store, modify, retrieve, delete and update data in a database.

SELECT: retrieve data from a database
INSERT: insert data into a table
UPDATE: updates existing data within a table
DELETE: Delete all records from a database table
MERGE: UPSERT operation (insert or update)
CALL: call a PL/SQL or Java subprogram
EXPLAIN PLAN: interpretation of the data access path
LOCK TABLE: concurrency Control
Database Management System: The software which is used to manage database is called Database Management System (DBMS). For Example, MySQL, Oracle etc. are popular commercial DBMS used in different applications. DBMS allows users the following tasks:

Data Definition: It helps in creation, modification and removal of definitions that define the organization of data in database.

Data Updation: It helps in insertion, modification and deletion of the actual data in the database.

Data Retrieval: It helps in retrieval of data from the database which can be used by applications for various purposes.

User Administration: It helps in registering and monitoring users, enforcing data security, monitoring performance, maintaining data integrity, dealing with concurrency control and recovering information corrupted by unexpected failure.

Paradigm Shift from File System to DBMS

 File System manages data using files in hard disk. Users are allowed to create, delete, and update the files according to their requirement. Let us consider the example of file based University Management System. Data of students is available to their respective Departments, Academics Section, Result Section, Accounts Section, Hostel Office etc. Some of the data is common for all sections like Roll No, Name, Father Name, Address and Phone number of students but some data is available to a particular section only like Hostel allotment number which is a part of hostel office. Let us discuss the issues with this system:

Redundancy of data: Data is said to be redundant if same data is copied at many places. If a student wants to change Phone number, he has to get it updated at various sections. Similarly, old records must be deleted from all sections representing that student.
Inconsistency of Data: Data is said to be inconsistent if multiple copies of same data does not match with each other. If Phone number is different in Accounts Section and Academics Section, it will be inconsistent. Inconsistency may be because of typing errors or not updating all copies of same data.
Difficult Data Access: A user should know the exact location of file to access data, so the process is very cumbersome and tedious. If user wants to search student hostel allotment number of a student from 10000 unsorted students’ records, how difficult it can be.
Unauthorized Access: File System may lead to unauthorized access to data. If a student gets access to file having his marks, he can change it in unauthorized way.
No Concurrent Access: The access of same data by multiple users at same time is known as concurrency. File system does not allow concurrency as data can be accessed by only one user at a time.
No Backup and Recovery: File system does not incorporate any backup and recovery of data if a file is lost or corrupted.
These are the main reasons which made a shift from file system to DBMS.
-
-
-
-
-
-
Access Modifier = Access Specifier = Erişim Modifiyeri)                               	 (GITHUB)
Access modifier nedir, public nedir, private nedir, protected nedir, internal nedir, access specifier nedir, access modifier nedir
Access specifier de denir, access modifier de denir. Kaynaklar incelendi: https://www.tutorialspoint.com/What-are-the-different-access-specifiers-in-Chash-NET
All types and type members have an accessibility level, which controls whether they can be used from other code in your assembly or other assemblies. You can use the following access modifiers to specify the accessibility of a type or member when you declare it:
public

The type or member can be accessed by any other code in the same assembly or another assembly that references it.
private

The type or member can be accessed only by code in the same class or struct.
protected

The type or member can be accessed only by code in the same class, or in a class that is derived from that class. (class dışından erişemezsin)

internal

The type or member can be accessed by any code in the same assembly, but not from another assembly.
protected internal 

The type or member can be accessed by any code in the assembly in which it is declared, or from within a derived class in another assembly.
private protected 

The type or member can be accessed only within its declaring assembly, by code in the same class or in a type that is derived from that class.
The following examples demonstrate how to specify access modifiers on a type and member:
public class Bicycle
{
    public void Pedal() { }
}
Not all access modifiers can be used by all types or members in all contexts, and in some cases the accessibility of a type member is constrained by the accessibility of its containing type. The following sections provide more details about accessibility.
Class and Struct Accessibility
Classes and structs that are declared directly within a namespace (in other words, that are not nested within other classes or structs) can be either public or internal. Internal is the default if no access modifier is specified.
Struct members, including nested classes and structs, can be declared as public, internal, or private. Class members, including nested classes and structs, can be public, protected internal, protected, internal, private protected or private. The access level for class members and struct members, including nested classes and structs, is private by default. Private nested types are not accessible from outside the containing type.
Derived classes cannot have greater accessibility than their base types. In other words, you cannot have a public class B that derives from an internal class A. If this were allowed, it would have the effect of making A public, because all protected or internal members of A are accessible from the derived class.
You can enable specific other assemblies to access your internal types by using the InternalsVisibleToAttribute. For more information, see Friend Assemblies.
-
-
-
-
-
-
Nested Classes
Nested class nedir, nested classes nedir
When one class is entirely dependent upon another, you may decide to implement it using a nested class. Nested classes are declared within the scope of an existing class and receive special benefits when they access their parent class's members.


What are Nested Classes?
A nested class is a special type of class that can be created using C#. Normally classes are declared within a namespace, or in the default namespace if one is not specified. A nested class is defined within the code block of another class, which itself may be a nested class to permit multiple nesting levels.


A nested class generally behaves is the same way as any other class. It can be instantiated separately to its parent class and is not instantiated automatically by its parent. However, there are some important differences. One key difference concerns the scope of the class. Normally classes can be either public or internal. A nested class may be declared as private, meaning that the class can only be seen by its parent class and other nested classes within that parent. A nested class may also be declared as protected, allowing it to also be accessed by classes that derive from its parent type. This may be extended to protected internal to allow other classes in the same assembly to access it.

Nested classes are given special access to instances of their parent classes. When an object of a parent class is passed to a method of a nested class, the method is permitted to access the private and protected members of the object. This makes nested classes ideal where a special relationship exists with the parent class that requires access to private members, particularly when the nested class is not required anywhere else and is never used in a standalone capability.

Example Nested Classes
We will start with a simple example of a nested class. In this case, the outer class will describe a sales order in an order-processing system. In this rather contrived design, there is no requirement for an order line to ever be created without an order. Furthermore, there is no need for an order line to be used externally to an order. In this case, it is useful to create an Order class with a nested, private OrderLine class.
NB: The following code uses .NET 3.0 syntax for brevity. For earlier versions of the .NET framework, you will need to expand the property declarations and possibly remove the use of generics.


class Order
{
    private List<OrderLine> _orderLines = new List<OrderLine>();
 
    public void AddOrderLine(string product, int quantity, double price)
    {
        OrderLine line = new OrderLine();
        line.ProductName = product;
        line.Quantity = quantity;
        line.Price = price;
        _orderLines.Add(line);
    }
 
    public double OrderTotal()
    {
        double total = 0;
        foreach (OrderLine line in _orderLines)
        {
            total += line.OrderLineTotal();
        }
        return total;
    }
 
    // Nested class
    private class OrderLine
    {
        public string ProductName { get; set; }
        public int Quantity { get; set; }
        public double Price { get; set; }
 
        public double OrderLineTotal()
        {
            return Price * Quantity;
        }
    }
}
The code above shows the simplified Order and nested OrderLine classes. The Order class has two public members. The first allows an item to be added to a private collection of order lines. The product name, price and quantity are passed to this method, which builds an OrderLine object and adds it to the list. The second method loops through each item in the collection and calculates the total value for the order.
The nested OrderLine class is used to represent order lines. It includes properties for the product name, quantity and price and a single method that calculates the total price for the order line. As the class is marked as private, it is invisible to all classes except its parent and any other nested classes that we may later create within Order. We could change the access modifier for the nested class to protected if we wished it to be visible to classes that inherit from Order.
We can test the order mechanism with the following code. This creates an order with two order lines and outputs the total value to the console:
Order order = new Order();
order.AddOrderLine("Cheese", 5, 1.99);
order.AddOrderLine("Oranges", 12, 0.35);
Console.WriteLine(order.OrderTotal());  // Outputs "14.15"
Increasing Nested Class Visibility
As our ordering system evolves, we may decide that it would be useful to permit other classes access to the nested OrderLine class. We could then modify the AddOrderLine method to accept an OrderLine object rather than its constituent parts. We can do this by changing the access modifier of the nested class to internal, protected internal or public, depending upon the requirements. The following code shows a new version of the code:

class Order
{
    private List<OrderLine> _orderLines = new List<OrderLine>();
 
    public void AddOrderLine(OrderLine line)
    {
        _orderLines.Add(line);
    }
 
    public double OrderTotal()
    {
        double total = 0;
        foreach (OrderLine line in _orderLines)
        {
            total += line.OrderLineTotal();
        }
        return total;
    }
 
    // Nested class
    internal class OrderLine
    {
        public string ProductName { get; set; }
        public int Quantity { get; set; }
        public double Price { get; set; }
 
        public double OrderLineTotal()
        {
            return Price * Quantity;
        }
    }
}


With the new versions of the classes, the code that creates an order will also be different. Rather than passing the product details as separate variables, the calling class will instantiate order lines and pass these to the AddOrderLine method. When instantiating a nested class, the name of the class must be qualified by prefixing it with the parent class's name, as in the following, updated example. Note that the order lines are created as Order.OrderLine objects.

Order order = new Order();
 
Order.OrderLine line1 = new Order.OrderLine(); //vaaay olaya gel

line1.ProductName = "Cheese";
line1.Quantity = 5;
line1.Price = 1.99;
order.AddOrderLine(line1);
 
Order.OrderLine line2 = new Order.OrderLine();
line2.ProductName = "Oranges";
line2.Quantity = 12;
line2.Price = 0.35;
order.AddOrderLine(line2);
 
Console.WriteLine(order.OrderTotal());


Accessing Private Members of the Parent Class
The final example will demonstrate the ability for nested classes to access private members of their parent classes. In this example, we have modified the order to include a discount multiplier. The multiplier is held as a private variable that may have been initialised using a constructor or a property. In this case the value is fixed at 0.85. Every order line value will be multiplied by this amount to give a 15% discount.
To allow the order lines to access the discount multiplier, the OrderLineTotal method has been updated to include a parameter. This parameter accepts an Order object. The method retrieves the private discount multiplier from the Order and includes it in the calculation, rounding the result to two decimal places on a line-by-line basis. If the OrderLine class was not nested within Order, this would not be possible.

class Order
{
    private List<OrderLine> _orderLines = new List<OrderLine>();
    private double DiscountMultiplier = 0.85;
 
    public void AddOrderLine(OrderLine line)
    {
        _orderLines.Add(line);
    }
 
    public double OrderTotal()
    {
        double total = 0;
        foreach (OrderLine line in _orderLines)
        {
            total += line.OrderLineTotal(this);
        }
        return total;
    }
 
    // Nested class
    internal class OrderLine
    {
        public string ProductName { get; set; }
        public int Quantity { get; set; }
        public double Price { get; set; }
 
        public double OrderLineTotal(Order order)
        {
            return Math.Round(Price * Quantity * order.DiscountMultiplier, 2);
        }
    }
}

NB: Although nested classes can access the private members of their parent class, the reverse is not true. Private members of nested classes are invisible to their parent class.
-
-
-
-
-
-
Class		(GITHUB)

Class nedir
Class'lar ile ilgili önemli bilgiler:

namespace ConsoleApp6
{
    public class PublicClass
    {
    }
 
    internal class InternalClass
    {
    }
 
    // access modifier'siz class'lar otomaitik olarak internal olurlar.
 
    class AccessModifiersizClass
    {
    }
 
 
    // Aşağıdaki hata verir. Direkt olarak namespace içine yazılmış olan class'lar sadece public veya internal olabilir!
    // Classes and structs that are declared directly within a namespace (in other words, that are not nested within other classes or structs) can be either public or internal. Internal is the default if no access modifier is specified.
    /*
    private class PrivateClass
    {
    }
    */
 
    // namespace scope'unda direkt olarak tutulamayacağını söyledik private class vb'nin. Aşağıya bakınız:
    public class BigClass
    {
        private class PrivateClass
        {
        }
 
        protected class ProtectedClass
        {
        }
 
        private protected class PrivProtClass
        {
        }
 
        internal class InternalClass
        {
        }
    }
 
// görüldüğü gibi, eğer bir class'ın içindeyken bir class oluşturuyorsak, bu class'ları access modifier'ları kullanarak oluşturabiliriz
//SQL sorguları, stored procedure'ler burada bulunacak
-
-
-
-
-
-
SQL
SQL nedir
In 1970's the product called 'SEQUEL', structured English query language, developed by IBM and later SEQUEL was renamed to 'SQL' which stands for Structured Query Language.
In 1986, SQL was approved by ANSI (American national Standards Institute) and in 1987, it was approved by ISO (International Standards Organization).
SQL is a structure query language which is a common database language for all RDBMS products. Different RDBMS product vendors have developed their own database language by extending SQL for their own RDBMS products.
T-SQL stands for Transact Structure Query Language which is a Microsoft product and is an extension of SQL Language. Example:
MS SQL Server --> SQL\T-SQL
ORACLE        --> SQL\PL-SQL
Data tiplerini bi incele: https://www.tutorialspoint.com/t_sql/t_sql_data_types.htm
-
-
-
-
-
-
derive, derivation, inherit, inheritance kelimeleri
Derive nedir, derivation nedir, inherit nedir, inheritance nedir, derive from nedir, inherit from nedir
Kelimelerin nasıl kullanılabileceğiyle ilgili bilgi içerir:
	Derive
A class can be derived from more than one class or interface 
(derive meaning: obtain something from (a specified source)).

Definition - What does Derived Class mean?
A derived class is a class created or derived from another existing class. The existing class from which the derived class is created through the process of inheritance is known as a base class or superclass.

class <derived_class> : <base_class> 
{
}
	Inherit
Definition - What does Inherited Class mean?
An inherited class is called a subclass of its parent class or super class.
class B inherits from class A: 
class B : A {}
(inherit meaning: derive (a quality, characteristic, or predisposition) genetically from one's parents or ancestors.)
Örnek cümle: The child classes inherit methods and properties of the parent class
-
-
-
-
-
-
sealed 
Sealed nedir
Sealed bir access modifier değildir! Evet, bir modifier'dir. Ama access modifier değildir. Çünkü access'i yani erişimi değiştirmez, yani erişimi modifiye etmez.
Peki sealed tanımda ne olarak geçer?
Sealed bir modifier'dir.
Sealed daha genel anlamda bakıldığında bir keyword'dür tabi ki: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/
Sealed'in neden bir access modifier olmadığına dair güzel bir cevap: Cause if you cannot derive from a class it doesn't mean you cannot access it.
When applied to a class, the sealed modifier prevents other classes from inheriting from it. In the following example, class B inherits from class A, but no class can inherit from class B.
class A {}
sealed class B : A {}
Önemli: You can also use the sealed modifier on a method or property that overrides a virtual method or property in a base class. This enables you to allow classes to derive from your class and prevent them from overriding specific virtual methods or properties.
Example (gayet açık)
In the following example, Z inherits from Y but Z cannot override the virtual function F that is declared in X and sealed in Y.
C#Copy
class X
{
    protected virtual void F() { Console.WriteLine("X.F"); }
    protected virtual void F2() { Console.WriteLine("X.F2"); }
}

class Y : X
{
    sealed protected override void F() { Console.WriteLine("Y.F"); }
    protected override void F2() { Console.WriteLine("Y.F2"); }
}

class Z : Y
{
    // Attempting to override F causes compiler error CS0239.
    // protected override void F() { Console.WriteLine("Z.F"); }

    // Overriding F2 is allowed.
    protected override void F2() { Console.WriteLine("Z.F2"); }
}
When you define new methods or properties in a class, you can prevent deriving classes from overriding them by not declaring them as virtual.
It is an error to use the abstract modifier with a sealed class, because an abstract class must be inherited by a class that provides an implementation of the abstract methods or properties.
When applied to a method or property, the sealed modifier must always be used with override.
Because structs are implicitly sealed, they cannot be inherited.
For more information, see Inheritance.
For more examples, see Abstract and Sealed Classes and Class Members.
Example
sealed class SealedClass
{
    public int x;
    public int y;
}

class SealedTest2
{
    static void Main()
    {
        var sc = new SealedClass();
        sc.x = 110;
        sc.y = 150;
        Console.WriteLine($"x = {sc.x}, y = {sc.y}");
    }
}
// Output: x = 110, y = 150
In the previous example, you might try to inherit from the sealed class by using the following statement:
class MyDerivedC: SealedClass{} // Error
The result is an error message:
'MyDerivedC': cannot derive from sealed type 'SealedClass'
Remarks
To determine whether to seal a class, method, or property, you should generally consider the following two points:
•	The potential benefits that deriving classes might gain through the ability to customize your class.
•	The potential that deriving classes could modify your classes in such a way that they would no longer work correctly or as expected.
-
-
-
-
-
-
Type, member
Type nedir, member nedir
The following examples demonstrate how to specify access modifiers on a type and member:
public class Bicycle
{
    public void Pedal() { }
}
-
-
-
-
-
-
Dataset
DataSet: This is a collection of DataTables. We use the DataSet type to store many DataTables in a single collection. Conceptually, the DataSet acts as a set of DataTable instances. 
Usage: DataSet simplifies programs that use many DataTables. To effectively use the DataSet, you will need to have some DataTables handy. We begin by creating some. 
Create: In this program, we create two DataTables. One stores two rows of patient information. And the second stores two rows of medication information. 
Next: We create a DataSet with the DataSet constructor. Then we add the two DataTables to the DataSet instance. Finally we print the XML. 
DataSetName: Every DataSet can have a name specified. Usually, it is easiest to specify this inside the DataSet constructor. But you don't always know the name at this time. 
However: You can also change the name by assigning to the DataSetName property. You can also read the DataSetName property. 
Copy, Clear: DataSet has a Clear method that clears all the DataTables in the set. It also provides a Copy method that will make a deep copy of all the DataTables in the set. 
Tip: If you call Copy and the Clear the original, your copied data will still exist unchanged.
	public ActionResult Index()
	{
            // Önce DataSet oluşturuldu
            // Sonra DataTable oluşturuldu (tablo)
            // Sonra oluşturulan tabloya kolonlar eklendi
            // Sonra bu kolonlara örnek veriler eklendi (datarow)
            // Sonra ilk başta oluşturduğumuz Dataset'in içine, DataTable'ımızı yerleştirdik ve View'a yolladık.
 
            DataSet ds = new DataSet();
            DataTable dt = new DataTable("YeniTablo");
 
            dt.Clear();
 
            dt.Columns.Add("Isim");
            dt.Columns.Add("SoyIsim");
 
            DataRow dr = dt.NewRow();
 
            // Row'lar farklı şekilde de eklenebilir. 2. örneğe bakılabilir.
            dr["Isim"] = "Eren";
            dr["SoyIsim"] = "OZTEN";
            dt.Rows.Add(dr);
 
            ds.Tables.Add(dt);
 
            return View(ds);

View:

 
@model System.Data.DataSet
 
@using System.Data
 
@foreach (DataRow row in Model.Tables["YeniTablo"].Rows)
{
    @(row["Isim"] + " " + row["SoyIsim"])
}
 
@{
    ViewBag.Title = "Home Page";
}

Bir örnek daha:
// GET: DataSet2
        public ActionResult Index()
        {
            // Create two DataTable instances.
            DataTable dataTable1 = new DataTable("Books");
            //dataTable1.Clear();
            dataTable1.Columns.Add("Name");
            dataTable1.Columns.Add("Id");
            dataTable1.Rows.Add("Monte Cristo", 1);
            dataTable1.Rows.Add("Jane Eyre", 2);
 
            DataTable dataTable2 = new DataTable("Medications");
            dataTable2.Columns.Add("Id");
            dataTable2.Columns.Add("Medication");
            dataTable2.Rows.Add(1, "Atenolol");
            dataTable2.Rows.Add(2, "Amoxicillin");
 
            // Oluşturduğumuz dataTable'ları dataSet içine koyalım.
 
            DataSet dataSet = new DataSet("dataSetNam");
            dataSet.Tables.Add(dataTable1);
            dataSet.Tables.Add(dataTable2);
 
            // Visualize DataSet.
            return View(dataSet);
 
View kısmı:

 <h2>DataSet2 Index 414322</h2>
<br />
<br />
 
 
@model System.Data.DataSet
 
@using System.Data
 
@foreach (DataRow row in Model.Tables["Books"].Rows)
{
    @(row["Name"] + " - " + row["Id"])
    <br/>
}

 
            //// Aşağıdaki örnek çalışıyor:
 
            //DataSet dataSet = new DataSet();
            //DataTable dataTable1 = new DataTable("Books");
 
            //dataTable1.Columns.Add("Name");
            //dataTable1.Columns.Add("Id");
 
            //DataRow dataRow1 = dataTable1.NewRow();
 
            //dataRow1["Name"] = "Monte Kristo";
            //dataRow1["Id"] = "1";
            //dataTable1.Rows.Add(dataRow1);
            //dataSet.Tables.Add(dataTable1);
 
            //return View(dataSet);
        }
-
-
-
-
-
-
metadata
metadata nedir
Metadata is simply data about data. It means it is a description and context of the data. It helps to organize, find and understand data. Here are a few real world examples of metadata:
Those are some typical metadata elements:
1.	Title and description,
2.	Tags and categories,
3.	Who created and when,
4.	Who last modified and when,
5.	Who can access or update.
Every time you take a photo with today's cameras a bunch of metadata is gathered and saved with it:
•	date and time,
•	filename,
•	camera settings,
•	geolocation.
-
-
-
-
-
-
HTTPGet vs HTTPPost
Httpget nedir httppost nedir
https://www.youtube.com/watch?v=Un2JTC7tFPI
Videoyu izle…
Get yapınca veriler url ye yazılır. Post ta ise form yollanır… Url ile yollanmaz veri. Message body içinde yollanır.
Get metotlara url'ye yazıp enter yaparak ulaşılır. O yüzden tehlikeli olabilir…
DB'deki değerleri hem Get hem Post ile değiştirebiliriz tabi ki. Ama dediğimiz gibi get ile bunu yapmak tehlikelidir.
-
The GET Method
GET is used to request data from a specified resource. 
GET is one of the most common HTTP methods. 
Note that the query string (name/value pairs) is sent in the URL of a GET request: 
/test/demo_form.php?name1=value1&name2=value2
Some other notes on GET requests: 
GET requests can be cached
GET requests remain in the browser history
GET requests can be bookmarked
GET requests should never be used when dealing with sensitive data
GET requests have length restrictions
GET requests are only used to request data (not modify)
The POST Method
POST is used to send data to a server to create/update a resource. 
The data sent to the server with POST is stored in the request body of the HTTP request: 
POST /test/demo_form.php HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
(yukarıda request body'nin neye benzediğini görmüş olduk. Get request'lerde request body yoktur. Veri url'den gönderilir)
Some other notes on POST requests:
POST requests are never cached
POST requests do not remain in the browser history
POST requests cannot be bookmarked
POST requests have no restrictions on data length
-
GET methodu HTTP istekleri arasındaki varsayılan yöntemdir.  GET metodu ile yapılan istekler tarayıcının adres satırında görünür. Sadece belirli boyutta veri gönderileceği zaman kullanılır.
POST metodu ise URL’ de görünmesini istemediğimiz veriler olduğunda kullanılabilir. POST yönteminde gönderebileceğimiz verinin boyutu ile ilgili bir sınır yoktur. Ayrıca gönderdiğimiz parametrelerin adres satırında görünmemesi dolayısıyla GET yöntemine göre daha güvenlidir. HTML form gönderileceği zaman neredeyse her zaman POST yöntemi tercih edilir.
Örnek vermek gerekirse Kisilers tablomuzun olduğu bir proje üzerinde kişi bilgilerini düzenlemek isteyebiliriz. Bunun için genellikle iki Action oluştururuz. Bunlardan biri kişinin ID sini parametre olarak alan gelen ID ye göre kişinin bilgilerini Edit formunda açan Action iken diğeri POST olduğunda yani Kaydet butonuna tıklandığında kullanılacak Actiondur.
 
public ActionResult Edit(int? id)
{
if (id == null)
 
{  return new HttpStatusCodeResult(HttpStatusCode.BadRequest);  }
 
Kisiler kisiler = db.Kisilers.Find(id);
 
if (kisiler == null) 
{
return HttpNotFound();
}
 
return View(kisiler);
}
 
Yukarıda ki Action’ da querystring’imiz kisa iken aşağıdakinde Kisilers tablosundaki kolon sayısına göre uzunluğu değişecek bir querystring söz konusu. Ayrıca buradan dönen bilgilerinde adres çubuğunda görünmesini istemediğimiz için POST methodunu kullanırız.
Önemli:
Browsers can cache GET requests, generally on static data, like images or scripts. But you can also allow browsers to cache GET requests to controller actions as well, using [OutputCache] or other similar ways, so if caching is turned on for a GET controller action, it's possible that clicking on a link leading to /Home/Index doesn't actually run the Index method on the server, but rather allows the browser to serve up the page from its own cache.
With this line of thinking, you can safely turn on caching on GET actions in which the data you're serving up doesn't change (or doesn't change often), with the knowledge that your server action won't fire every time.
POSTs won't be cached by the browser, so any POST is guaranteed to make it to the server.
-
Güzel bir açıklama:
Ignore caching for a moment. Another way of thinking about this is that search engines will store HTTP GET links during their indexing/crawling process, therefore they will show up in search results.
Suppose if your /Home/Index is implemented as GET but it lets say deletes a row in your Database, every time this link shows up on a search engine and somebody clicks it, you will have a delete row, and soon you have a lot deleted rows.
-
-
-
-
-
-
Bundling in MVC / Bundle in MVC 
Bundling  nedir, bundle nedir
Detaylı bilgil için link kesinlikle incelenmeli: https://www.tutorialsteacher.com/mvc/bundling-and-minification-in-asp.net-mvc
Bundle ingilizcede "demet" demektir... Bundling request'lerin daha hızlı gerçekleşmesi için yapılır. (Request load time'ı azaltmak için yapılır). İstenen statik dosyaları farklı farklı http request'lerle yollamaktansa hepsini bir bundle içinde (demette) toplayıp tek bir http request'iyle yollayabiliriz. Dolayısıyla bundling zaman yönünden verimlilik sağlayan bir tekniktir. Aklımıza şunu getirebiliriz: Çiçekleri tek tek vermektense bir demet halinde tek bir hamleyle veriyoruz. Bundling'in faydası sadece bununla sınırlı değildir.
Bundling, script/style dosyalarımızın gereksiz kısımlarını (gereksiz boşluklar vb) siler. Böylelikle dosyayı minimize etmiş olur (yani boyutunu düşürmüş olur). Bu da sunucu üzerine bindirilen yükü azaltır. Örneğin aşağıdaki kod parçacığını;
sayHello = function(name){
    //this is comment
    var msg = "Hello" + name;
    alert(msg);
}

Şu hale getirir:
sayHello=function(n){var t="Hello"+n;alert(t)}

Görüldüğü gibi comment satırını bile silmiş..
Not: Bahsedilen statik dosyalar hem script dosyaları, hem de style dosyaları olabilir. Script dosyalarımızı ScriptBundle kullanarak, style dosyalarımızı da StyleBundle kullanılarak gönderiyoruz.
Bundle'ları nasıl oluşturduğumuz ve View'da nasıl render ettiğimiz yukarıdaki linkte anlatılıyor. 

Script bundle:
https://www.tutorialsteacher.com/mvc/scriptbundle-mvc
bundles.Add(new ScriptBundle("~/bundles/myScriptsBundle").Include(
                "~/Scripts/myScript.js"));
buradaki  ScriptBundle'yi unutma. Bundle ye script koyacaksak; bunun adı ScriptBundle olmalı, yok eğer style dosyaları koyacaksak (CSS) o zaman adı StyleBundle olur.
~/bundles
bu kısmı yazmazsak çalışmıyor.
myScriptsBundle
bizim vereceğimiz özel isim, kafaya göre.
Scripts
bu ise script'in hangi file içinde olduğunu gösteriyor
myScript.js
çalıştırmak istediğimiz script dosyası..
sonra bu bundle'ı RENDER etmemiz gerekiyor. Yoksa çalışmaz. 
Scriptleri layoutta render edelim ki her sayfada geçerli olsun:
    @Scripts.Render("~/bundles/myScriptsBundle")

Not: render ederken diğer jquery vb dosyalarından sonra render et çünkü script'inde kesin jquery falan kullanmışsındır. o yüzden önce JQuery bundle render edilsin, sonra senin scriptin.

Style bundle:
STYLE'LAR BÖYLE YAPILMALI:
     bundles.Add(new StyleBundle("~/bundles/VereceginİsimKafayaGöre").Include(
                "~/Content/site2.css"));
    @Styles.Render("~/bundles/ VereceginİsimKafayaGöre")
-
-
-
-
-
-
Library	   (GITHUB) 		(read)
Library nedir
(Dapper,  Automapper vb birer library'dir, client side validation için kullandığımız  jQuery Unobtrusive Validation Library de bir library'dir)
Yazılım kütüphanesi (Software Library), yazılım geliştiricilerinin program geliştirirken kullandıkları bir tür program kodları ve veriler takımıdır. Yazılım kütüphaneleri, yazılımcılar ve programlama dilinin derleyicilerine çalıştırılabilir programlar geliştirme konusunda yardımcı olurlar. Yazılım kütüphaneleri içinde genellikle önceden hazırlanmış kodlar, sınıflar, prosedürler, betikler, konfigürasyon verilerini içerir.
Bir geliştirici yazılım geliştirirken yazılımını daha işlevsel hale getirmek veya çeşitli fonksiyonlar kazandırmak için yazılım kütüphanelerinden faydalanır. Yazılım kütüphaneleri yazılımcıların iş yükünü hafifletir ve aynı kodu tekrar yazmalarına gerek kalmadan onlara hazır bir kalıp sunar. Basit bir örnekle açıklamamız gerekirse; bir geliştirici matematikle ilgili bir yazılım geliştirdiğinde bu yazılıma karmaşık matematik işlemlerini yaptırması için ayrı ayrı modüller yazmak zorunda kalacaktır. Bu kodları yazmaya uğraşmak yerine yazılım kütüphanesindeki bir matematik modülünü alıp bu modülü doğrudan kendi yazılımına ilave edebilir.
In computer science, a library is a collection of non-volatile resources used by computer programs, often for software development. These may include configuration data, documentation, help data, message templates, pre-written code and subroutines, classes, values or type specifications. In IBM's OS/360 and its successors they are referred to as partitioned data sets.
A library is also a collection of implementations of behavior, written in terms of a language, that has a well-defined interface by which the behavior is invoked. For instance, people who want to write a higher level program can use a library to make system calls instead of implementing those system calls over and over again. In addition, the behavior is provided for reuse by multiple independent programs. A program invokes the library-provided behavior via a mechanism of the language. For example, in a simple imperative language such as C, the behavior in a library is invoked by using C's normal function-call. What distinguishes the call as being to a library function, versus being to another function in the same program, is the way that the code is organized in the system.
Library code is organized in such a way that it can be used by multiple programs that have no connection to each other, while code that is part of a program is organized to be used only within that one program. 
The value of a library lies in the reuse of the behavior. When a program invokes a library, it gains the behavior implemented inside that library without having to implement that behavior itself. Libraries encourage the sharing of code in a modular fashion, and ease the distribution of the code.
The behavior implemented by a library can be connected to the invoking program at different program lifecycle phases. If the code of the library is accessed during the build of the invoking program, then the library is called a static library.[1] An alternative is to build the executable of the invoking program and distribute that, independently of the library implementation. The library behavior is connected after the executable has been invoked to be executed, either as part of the process of starting the execution, or in the middle of execution. In this case the library is called a dynamic library (loaded at runtime). A dynamic library can be loaded and linked when preparing a program for execution, by the linker. Alternatively, in the middle of execution, an application may explicitly request that a module be loaded.
Most compiled languages have a standard library although programmers can also create their own custom libraries. Most modern software systems provide libraries that implement the majority of the system services. Such libraries have commoditized the services which a modern application requires. As such, most code used by modern applications is provided in these system libraries. 

Top 10 .NET Core Libraries Every Web Developer Should Know

Open-source libraries significantly reduce developers’ work and allow them to create and manage their applications easily.
In this article, I’ll describe some of the most useful .NET Core libraries that every developer needs to know:
•	Swashbuckle
•	Polly
•	AutoMapper
•	SaasKit
•	Diagnostics.HealthChecks
•	MailKit
•	CacheManager
•	Dapper
•	Ocelot
•	NLog
Swashbuckle
Swashbuckle is a library that generates beautiful API documentation, including the Swagger UI, to explore and test API operations. This can be configured in your project and it will take only a few minutes to get started. 
License: MIT
Stars: 2.8k
Polly
Polly , according to its website, “allows developers to express resilience and transient fault-handling policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner.” 
License: BSD-3-Clause
Stars: 6.9k
AutoMapper
AutoMapper is a popular object-to-object mapper library used to map the properties of two different objects. This will reduce developer work and help us avoid unwanted code when mapping values.
GitHub: https://github.com/AutoMapper/AutoMapper
License: MIT
Stars: 6.9k
SaasKit
Building multitenant applications is quite difficult. But this library makes adding multitenancy as simple as possible. This library uses the concept of adding middleware using the OWIN interface. The author of this library has written many blog posts on how to configure SaasKit. Check the blog out for more details.
GitHub: https://github.com/saaskit/saaskit
License: Apache License 2.0
Stars: 5.6k
AspNetCore.Diagnostics.HealthChecks
This project is a BeatPulse liveness checker and UI port for the new feature included in the ASP.NET Core 2.2 version of Microsoft Health Checks. Using this library, we can monitor health checks for all apps, databases, APIs, Azure services, etc. This library can create beautiful UIs to display health checks. 
GitHub: https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks
License: Apache License 2.0
Stars: 1.1k
MailKit
MailKit is a cross-platform mail client library built on top of MimeKit. The goal of this project is to provide the .NET world with robust, fully featured, and RFC-compliant SMTP, POP3, and IMAP client implementations.
GitHub: https://github.com/jstedfast/MailKit
License: MIT
Stars: 3k
CacheManager
CacheManager is an open-source abstraction layer written in C# for. NET. It supports different providers of caches and incorporates other advanced features.
The CacheManager package’s main objective is to make life easier for developers to handle even very complex caching scenarios.
GitHub: https://github.com/MichaCo/CacheManager
License: Apache-2.0
Stars: 1.6k
Dapper
Dapper is a simple object mapper for .NET. This high-performance micro-ORM supports SQL Server, MySQL, Sqlite, SqlCE, Firebird, and so on. It can be used by simply installing the NuGet package, which extends the IDbConnection interface functionality. The familiar Stack Overflow site is using this library.
GitHub: https://github.com/StackExchange/Dapper
License: Apache-2.0
Stars: 11.8k
Ocelot
Ocelot is a. NET platform API gateway. This project is intended for people who use .NET or Core to run a microservice or service-oriented architecture that requires a unified system entry point. It will work with anything that uses HTTP. It runs on any ASP.NET Core-supported platform.
GitHub: https://github.com/ThreeMammals/Ocelot
License: MIT
Stars: 4.5k
NLog
NLog is an open-source logging tool for use in applications for .NET and Xamarin. It’s free, cross-platform, and easy to set up and expand. NLog is a great easy-to-use logging application with excellent log routing and management features, making it a good choice when selecting a high-performance logging system.
GitHub: https://github.com/NLog/NLog
License: BSD 3-Clause
Stars: 4.2k
-
-
-
-
-
-
Framework	   (GITHUB)
framework nedir
Önceden hazırlanmış belirli standartlar halinde kütüphanelerin bulunduğu bir iskelettir. İhtiyaca göre projemizi o iskelete dahil edip inşa ederiz.
Framework, yazılım geliştiricilerin kullandığı önceden hazırlanmış kütüphanelerin bunluduğu ve bunlara yenilerini ekleyebileceği yapıların adıdır. Gelişmiş frameworklerde form kontrolü, veri tabanı bağlantısı, kullanıcı giriş çıkış, mail atma, tema motoru gibi kütüphaneler mevcuttur.
Frameworkler ayrıca MVC (Model, View, Controller) gibi bölümlerden oluşarak projenizin daha okunabilir düzenlenebilir olmasını sağlamaktadır.
Yapılan projelerin çoğunda aradan belirli bir zaman geçtikten sonra düzenlemek zorlaşır. Hem kodların artması hem de yazılan kodun unutulması revize sürecini uzatmakta. Bu yapılar Modelde veritabanı işlemlerini, Controllerda genel mekaniği, Viewda ise görünüm kodu içerdiği için müdahale edilmesi gereken yer tam olarak bulanabilmektedir. 

A framework, or software framework, is a platform for developing software applications. It provides a foundation on which software developers can build programs for a specific platform. For example, a framework may include predefined classes and functions that can be used to process input, manage hardware devices, and interact with system software. This streamlines the development process since programmers don't need to reinvent the wheel each time they develop a new application.
A framework is similar to an application programming interface (API), though technically a framework includes an API. As the name suggests, a framework serves as a foundation for programming, while an API provides access to the elements supported by the framework. A framework may also include code libraries, a compiler, and other programs used in the software development process.
Several different types of software frameworks exist. Popular examples include ActiveX and .NET for Windows development, Cocoa for Mac OS X, Cocoa Touch for iOS, and the Android Application Framework for Android. Software development kits (SDKs) are available for each of these frameworks and include programming tools designed specifically for the corresponding framework. For example, Apple's Xcode development software includes a Mac OS X SDK designed for writing and compiling applications for the Cocoa framework.
-
-
-
-
-
-
Cassandra	(GITHUB)
cassandra nedir
 
Cassandra NoSQL database in top 10
Cassandra was developed at Facebook for inbox search. Cassandra is a distributed data storage system for handling very large amounts of structured data. Generally, these data are spread out across many commodity servers. You can also add storage capacity of your data keeping your service online and you can do this task easily. As all the nodes in a cluster are same, there is no complex configuration to deal with. Cassandra is written in Java. (CQL nedir) Cassandra Query Language (CQL) is a SQL-like language for querying Cassandra Database. As a result, Cassandra stands 2nd in best open source databases. Cassandra is being used by some of the biggest companies such as Facebook, Twitter, Cisco, Rackspace, eBay, Twitter, Netflix, and more.
•	Developed by: Apache Software Foundation
FEATURES
•	Linearly scalable
•	Maintains a quick response time
•	Supports properties like Atomicity, Consistency, Isolation, and Durability (ACID)
•	Supports MapReduce with Apache Hadoop
•	Maximal flexibility to distribute the data
•	Highly scalable
•	Peer-to-peer architecture
PROS OF CASSANDRA
•	Highly scalable
•	No single point of failure
•	Multi-DC Replication
•	Integrate tightly with other JVM based applications
•	More suitable for multiple data-center deployments, redundancy, failover and disaster recovery
CONS OF CASSANDRA
•	Limited support for aggregations
•	Unpredictable Performance
•	Doesn’t Support ad-hoc query
-
-
-
-
-
-
Ad Hoc Query
Ad hoc nedir, ad hoc query nedir, ad-hoc query nedir
Definition - What does Ad Hoc Query mean?
In SQL, an ad hoc query is a loosely typed command/query whose value depends upon some variable. Each time the command is executed, the result is different, depending on the value of the variable. It cannot be predetermined and usually comes under dynamic programming SQL query. An ad hoc query is short lived and is created at runtime.
Techopedia explains Ad Hoc Query
As the word "ad hoc" suggests, this type of query is designed for a "particular purpose,"which is in contrast to a predefined query, which has the same output value on every execution. An ad hoc query does not reside in the system for a long time and is created dynamically on demand by the user. It is more efficient to use an ad hoc query in programming as it saves system resources, but, at the same time complex, ad hoc queries (have multiple variables) also challenge the processing speed and runtime memory of the system. 
-
-
-
-
-
-
Oracle Database (GITHUB)
Oracle nedir
Oracle Database (commonly referred to as Oracle RDBMS or simply as Oracle) is a proprietary multi-model database[4] management system produced and marketed by Oracle Corporation.
It is a database commonly used for running online transaction processing (OLTP), data warehousing (DW) and mixed (OLTP & DW) database workloads. The latest generation, Oracle Database 19c, is available on-prem, on-cloud, or in a hybrid-Cloud environment. 19c may also be deployed on Oracle Engineered Systems (e.g. Exadata) on-prem, on Oracle (public) cloud or (private) cloud at customer.[5] At Openworld 2017 in San Francisco, Executive Chairman of the Board and CTO, Larry Ellison announced the next database generation, Oracle Autonomous Database.[6]

Oracle Database, Oracle firması tarafından geliştirilen ve pazarlaması yapılan,zaman zaman Oracle RDBMS (relational database management system), Oracle ilişkisel veritabanı yönetim sistemi (Oracle İVTYS) veya sadece Oracle olarak anılan, gelişmiş bir ilişkisel veritabanı yönetim sistemidir. Tüm ilişkisel veritabanı sistemleri gibi büyük miktarda verinin çok kullanıcılı ortamda depolanmasını ve güvenli bir şekilde erişimini yönetir.

Oracle veritabanı yazılımları özellikle kurumsal alanda kullanılan yaygın bir veritabanı sistemidir. Oracle çok sayıda araçtan oluşur ve uygulama geliştiricilerinin kolay ve esnek uygulamalar geliştirmesini sağlar. Oracle’de diğer veritabanı yönetim sistemlerinde olduğu gibi, stored procedure’lar, paketler, trigger’ler gibi bileşenler yer alır.
-
-
-
-
-
-
ORM   (Object Relational Mapping) / (Object-relational Mapper)
(GITHUB)
Orm nedir?
 Sql sorgularını yazmıyoruz da csharp tarafında metotlar kullanıyoruz, örneğin: Id si 12 olan datayı çekmek için entity framework'de Find metodunu kullanıyoruz değil mi, ama bu veriyi çekerken hiç sql sorgusu yazmadık. İşte bunu yapmamızı sağlayan şeyler ORM'dir. Bizim örneğimizde ise ORM miz Entity Framework'tür. 
Entity Framework'ün tanımı şudur: Entity Framework is an Object Relational Mapper (ORM) which is a type of tool that simplifies mapping between objects in your software to the tables and columns of a relational database. Entity Framework (EF) is an open source ORM framework for ADO.NET which is a part of .NET Framework.
ORM, veritabanında oluşturulan her bir nesneye (tabloya) karşılık uygulama tarafında bir nesne oluşturma işidir. Bu işlem bazı Frameworklerde ara yazılımlar sayesinde (ORM Tools), bazı frameworklerde ise elle gerçekleştirilmektedir.
-
-
-
-
-
-
ASP.NET   (Active Server Pages)  (GITHUB)
Asp.net nedir, asp nedir
ASP.NET is an open source web framework, created by Microsoft, for building modern web apps and services with .NET. 

ASP.NET is cross platform and runs on Windows, Linux, macOS, and Docker.
-
-
-
-
-
-
.NET Framework    (GITHUB)
.NET nedir?
.NET Framework (pronounced as "dot net") is a software framework developed by Microsoft that runs primarily on Microsoft Windows. It includes a large class library named as Framework Class Library (FCL) and provides language interoperability (each language can use code written in other languages) across several programming languages. Programs written for .NET Framework execute in a software environment (in contrast to a hardware environment) named the Common Language Runtime (CLR). The CLR is an application virtual machine that provides services such as security, memory management, and exception handling. As such, computer code written using .NET Framework is called "managed code". FCL and CLR together constitute the .NET Framework.

The .NET platform
.NET is a developer platform made up of tools, programming languages, and libraries for building many different types of applications.
The base platform provides components that apply to all different types of apps. Additional frameworks, such as ASP.NET, extend .NET with components for building specific types of apps.
Here are some things included in the .NET platform:
•	The C# programming language and its compilers
•	Base libraries for working with strings, dates, files/IO, and more
•	Editors and tools for Windows, Linux, macOS, and Docker
-
-
-
-
-
-
ADO   (ActiveX Data Objects)     (GITHUB)
Ado nedir?
What is ADO?
ADO is a Microsoft technology
ADO stands for ActiveX Data Objects
ADO is a Microsoft Active-X component
ADO is automatically installed with Microsoft IIS
ADO is a programming interface to access data in a database
Accessing a Database from an ASP Page
The common way to access a database from inside an ASP page is to:

Create an ADO connection to a database
Open the database connection
Create an ADO recordset
Open the recordset
Extract the data you need from the recordset
Close the recordset
Close the connection
-
-
-
-
-
-
UI (User Interface)   (GITHUB)
The user interface (UI) is the point of human-computer interaction and communication in a device. This can include display screens, keyboards, a mouse and the appearance of a desktop. It is also the way through which a user interacts with an application or a website. The growing dependence of many businesses on web applications and mobile applications has led many companies to place increased priority on UI in an effort to improve the user's overall experience.
Types of user interfaces
The various types of user interfaces include:
•	graphical user interface (GUI)
•	command line interface (CLI)
•	menu-driven user interface
•	touch user interface
•	voice user interface (VUI)
•	form-based user interface
•	natural language user interface
Examples of user interfaces
Some examples of user interfaces include:
•	computer mouse
•	remote control
•	virtual reality
•	ATMs
•	speedometer
•	the old iPod click wheel
Websites such as Airbnb, Dropbox and Virgin America display strong user interface design. Sites like these have created pleasant, easily operable, user-centered designs (UCD) that focus on the user and their needs.

In early computers, there was very little user interface except for a few buttons at an operator's console. Many of these early computers used punched cards, prepared using keypunch machines, as the primary method of input for computer programs and data. While punched cards have been essentially obsolete in computing since 2012, some voting machines still use a punched card system.
The user interface evolved with the introduction of the command line interface, which first appeared as a nearly blank display screen with a line for user input. Users relied on a keyboard and a set of commands to navigate exchanges of information with the computer. This command line interface led to one in which menus (lists of choices written in text) predominated.
Finally, the GUI arrived, originating mainly in Xerox's Palo Alto Research Center (PARC), adopted and enhanced by Apple and effectively standardized by Microsoft in its Windows operating systems. Elements of a GUI include such things as windows, pull-down menus, buttons, scroll bars and icons. With the increasing use of multimedia as part of the GUI, sound, voice, motion video and virtual reality are increasingly becoming the GUI for many applications.

UI ve UX çoğu kez beraber kullanılmalarına rağmen aslında çok farklı iki alandır. UI konusunda olmasa bile UX konusunda çok geride olan ülkemizde, maalesef bu işi profesyonel olarak yapan insanlar bile aralarındaki farkı çok bilmiyorlar. Ülkemizde bir UXD (User Interface Designer) ile tanışmanız çok zor. Türkiye’de bu işle ilgili çoğu insanın özgeçmişinde “UI/UX” yazar. Bunun bir sebebi aralarındaki farkın bilinmemesi, diğer sebebi ise internet sektörünü geriden takip etmemizden dolayı bu işi iki parçaya bölmenin bir lüks olarak görünmesidir.

Kısaca bahsetmek gerekirse; UI, aslında arayüz tasarımıdır. Televizyon kumandasının üstündeki tuşlar, bir arayüz tasarımı örneğidir. Tuşların yerleri, büyüklüğü, renkleri tasarımcının verdiği kararlar sonucu uygulanır. Arayüz tasarımının internet sitelerindeki karşılığı ise butonlar, grid yapısı, mizanpaj, renkler, boşluklar gibi tüm grafik elemanlardan oluşan görsel tasarımdır. Zamanla internet sitelerindeki interaksiyon arttıkça, önceleri çok da önemsenmeyen arayüz tasarımı da gittikçe önemli bir hal aldı. Kullanıcıların sitede rahatça dolaşmaları ve hatta kalmalarını sağlamak için basit ve kullanılabilir bir arayüz artık şart. Kullanıcılar bir sitede dolaşmaya veya terk etmeye saniyeler içerisinde karar veriyorlar. Yoğun uğraşlarla sitenize yönlendirdiğiniz kullanıcıları sitenizde tutamadığınız zaman da maalesef tüm uğraşlarınız boşa gidiyor.
The emerging popularity of mobile applications has also affected UI, leading to something called mobile UI. Mobile UI is specifically concerned with creating usable, interactive interfaces on the smaller screens of smartphones and tablets and improving special features, like touch controls.
-
-
-
-
-
-
Implicit
Implicit nedir, implicit nedir
dolaylı yoldan, yani direkt olarak DEĞİL / suggested though not directly expressed.
-
-
-
-
-
-
Explicit
Explicit nedir
stated clearly and in detail, leaving no room for confusion or doubt.
-
-
-
-
-
-
Declaration	(GITHUB) 

Declaration nedir
This is when you state to the program that there will be an object of a certain type existing and what the name of that object will be.
-
-
-
-
-
-
Instantiation	 	(GITHUB)
Instantiation nedir, instantiation nedir
This is when memory is allocated for an object. This is what the new keyword is doing. A reference to the object that was created is returned from the new keyword.
-
-
-
-
-
-
Initialization	 	(GITHUB)

This is when values are put into the memory that was allocated. This is what the Constructor of a class does when using the new keyword.

A variable must also be initialized by having the reference to some object in memory passed to it.
-
-
-
-
-
-
-
Aşağıda örnekli olarak bu üçlünün tanımı yapılmış

Declaration - Declaring a variable means to introduce a new variable to the program. You define its type and its name.

int a; //a is declared
Instantiate - Instantiating a class means to create a new instance of the class.
MyObject x = new MyObject(); //we are making a new instance of the class MyObject
Açıklama 2:
Instantiate literally means "to create an instance of". In programming, this generally means to create an instance of an object (generally on "the heap"). This is done via the new keyword in most languages. ie: new object();. Most of the time you will also save a reference to the object. ie: object myObject = new object();.


Initialize - To initialize a variable means to assign it an initial value.
Açıklama 2: 
Initialize means to give an initial value to. In some languages, if you don't initialize a variable it will have arbitrary (dirty/garbage) data in it. In C# it is actually a compile-time error to read from an uninitialized variable.

int a; //a is declared
int a = 0; //a is declared AND initialized to 0
MyObject x = new MyObject(); //x is declared and initialized with an instance of MyObject
Assigning - Assigning to a variable means to provide the variable with a value.

int a = 0; //we are assigning to a; yes, initializing a variable means you assign it a value, so they do overlap!
a = 1; //we are assigning to a

Assigning:
Assigning is simply the storing of one value to a variable. x = 5 assigns the value 5 to the variable  x. In some languages, assignment cannot be combined with declaration, but in C# it can be: int x = 5;.

Note that the statement object myObject = new object(); combines all four of these.

new object() instantiates a new object object, returning a reference to it.
object myObject declares a new object reference.
= initializes the reference variable by assigning the value of the reference to it.
-
-
-
-
-
-
-
Assigning
Assign nedir, assigning nedir
Assigning is simply the storing of one value to a variable. x = 5 assigns the value 5 to the variable  x. In some languages, assignment cannot be combined with declaration, but in C# it can be: int x = 5;.

Note that the statement object myObject = new object(); combines all four of these.

new object() instantiates a new object object, returning a reference to it.
object myObject declares a new object reference.
= initializes the reference variable by assigning the value of the reference to it.
-
-
-
-
-
-
Int vs int32		(GITHUB)

It means that whether you define a variable of int or Int32, both are same.
int i = 345;
Int32 i = 345;// same as above 
-
-
SOLID Principles 	(GITHUB)
SOLID Principles nedir, solid nedir, SOLID nedir, single responsibility nedir, srp nedir, open closed nedir, open-closed nedir, open/closed nedir, open-closed principle nedir, open/closed principle nedir

S: Single Responsibility Principle (SRP)
Bir programdaki her class veya modül sadece tek bir görevi yerine getirmelidir, birden fazla görev bir class'a veya modüle atanmamalıdır. SRP bununla da sınırlı değildir olay. Yapılan bu tek görev, ilgili class tarafından enkapsüle edilmelidir, yani yapılan görev, işlemle ilgisi olmayan diğer class'lardan gizlenmelidir.
The single responsibility principle (SRP) states that every class or module in a program should have responsibility for just a single piece of that program's functionality. Further, the elements of that responsibility should be encapsulated by the responsible class rather than spread out in unrelated classes.
O: Open/Closed Principle (OCP)
Nesne genişlemeye (extension'a) açık, değişikliklere kapalı olmalıdır (modification).

L: Liskov ‘s Substitution Principle (LSP) 
Alt sınıflar, üst sınıflar ile yer değiştirdiğinde herhangi bir problem ortaya çıkmamalıdır, alt sınıf üst sınıf yerine kullanılabilmelidir. Gökhan gökalp açıklaması: Alt sınıftan türetilmiş nesneler, üst sınıftan türetilen nesnelerle yer değiştirdiklerinde yine aynı davranışı -herhangi bir problem çıkmadan- sergilemesi gerektiğini savunur.
“Aynı temel sınıftan türeyen tüm sınıflar, birbirlerinin yerine kullanılabilir olmalıdır. Bu yer değiştirme durumunda, sınıfa özel bir istisna kesinlikle oluşmamalıdır.”
I: Interface Segregation Principle (ISP)
Bir client, kullanmadığı metoda bağlı olmamalıdır. Bu, büyük bir interface'in küçük parçalara ayrılmasıyla ve bu yeni küçük interface'lerin implement edilmesiyle gerçekleştirilir.
D: Dependency Inversion Principle (DIP)
Üst sınıflar, alt sınıflara bağlı olmamalıdır. Hem üst, hem alt sınıflar abstraction'lara bağlı olmalıdır.
-
-
Virtual Keyword	(GITHUB)
virtual keyword nedir, virtual nedir
Önemli: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/virtual
Sınıf içerisinde sanallaştırmak istediğimiz yani çakışma durumunda ezilmesini istediğimiz metot türleridir. Metotlar varsayılan olarak non-virtual'dır. Non-virtual metotlar override edilemez. 
You cannot use the virtual modifier with the static, abstract, private, or override modifiers.
The virtual keyword is used to modify a method, property, indexer, or event declaration and allow for it to be overridden in a derived class. Derived class override keyword'ünü kullanarak override işlemi yapar.
-
-
Abstract Class ve Interface Arasındaki Farklar Nelerdir?     (GITHUB)  (örnek)
Interface nedir, absctract class nedir, abstract nedir, abstraction nedir, abstract keyword nedir
https://medium.com/software-development-turkey/abstract-class-ve-interface-aras%C4%B1ndaki-farklar-nelerdir-3c0a4f956eba
https://www.geeksforgeeks.org/difference-between-abstract-class-and-interface-in-c-sharp/
 
Yazılıma yeni başlayan hemen herkesin zaman zaman karıştırdığı, hangisini ne zaman kullanacağına karar veremediği Abstract Class ve Interface ikilisini ele almak istedim. İlk bakışta yazdığımız koda oldukça benzer yetenekler kazandırdıkları görünse de aralarındaki farkların üzerinde durarak hangi senaryolarda hangisine karar vermemiz gerektiğini iyice açığa çıkartacağız 🙂
 
 
© agile-code.com
Abstract sınıflara geçmeden önce C# ve tüm Object Oriented dillerin bize sunduğu bir özellik olan abstraction(soyutlama) kavramını ele alalım. Böylece Abstract sınıflara ve Interface’lere neden ihtiyaç duyduğumuzu daha net bir şekilde anlayabiliriz.
Abstraction (Soyutlama) Nedir?
Abstraction, OOP (Object Oriented Programming-Nesne Tabanlı Programlama) içerisindeki önemli kavramlardan birisidir. C#’taki soyutlama; diğer Object Oriented dillerde olduğu gibi iç detayları gizleyerek sadece işlevleri göstermeye denir. Bu durumu gerçek hayatın içerisinden bir senaryo ile örneklendirelim.
Senaryo: Bir gün canınız sıkıldı ve çocukluğunuzda kalmış tatlı bir aktivite olan lunaparka gidip çarpışan arabaya binmek istediniz. Biletinizi aldınız ve seçtiğiniz arabaya oturup size gelen görevliye bileti teslim ettiniz. Görevli alana baktı ve araçları hareket ettirecek olan elektriği vermek için yeterli sayıda kişinin olduğuna karar verip bir düğmeye bastı. Görevlinin düğmeye basmasıyla çarpışan arabaların hareket etmesi için gerekli olan elektrik akımı verildi ve arabanız çalışır hale geldi. Direksiyonu, gaz pedalını ve freni kullanarak dilediğiniz şekilde aracı kullanmaya başladınız.
Şimdi gelin bu gerçek hayatın birebir içinden olan senaryodaki soyutlamaları (abstractions) inceleyelim. Böylece yazılım alanında da aslında aynı mantığın kullanıldığını ve soyutlamanın hayatımızı nasıl kolaylaştırdığını daha iyi anlamış olacağız.
Senaryoda Yer Alan Soyutlamalar(Abstractions): İlk soyutlama örneğimiz biletinizi teslim ettiğiniz görevlinin eğlenceyi başlatmak için bastığı küçük kırmızı düğme 🙂 Görevli o kırmızı düğmeye bastığında bizler sadece eğlencenin başlayacağını biliyoruz, görevli de on dakikalık bir seansa daha start vereceğini biliyor yalnızca. Düğmeye basıldığı anda elektrik devresindeki anahtarın kapanıp akımın başlayacağını ne biz ne de görevli aklının ucundan dahi geçirmiyor. İşte bu tam bir soyutlama örneği. Yalnızca input(düğmeye basmak) ve output(eğlencenin başlaması) değerleriyle ilgileniyoruz. Arka tarafta dönen teknik hadiseleri hiç düşünmeden bize sunulmuş bir düğmeyi kullanarak işimizi görüyoruz.
Eğer hala bir şeyler oturmadıysa kafanızda bir de çarpışan arabamızdaki soyutlamaya bakalım. Siz arabayı kullanırken direksiyonu gitmek istediğiniz yöne çeviriyor, gaz pedalına basarak ilerliyorsunuz. Gaz pedalına bastığınızdaki motorda oluşan tetiklenmeleri, direksiyonu çevirdiğinizde lastiklerin dönmesini sağlayan mekanizmayı hiç düşünmeden yalnızca iki pedal bir direksiyonla aslında arka planında onlarca aksiyon yatan bir işlevi gerçekleştirmiş oluyorsunuz. Input (gaz/fren pedalları, direksiyon) ve output (arabanın gitmesi) değerlerini bilmek size yetiyor.
Object Oriented programlamada sınıfların soyutlanmasını ise Abstract Class ve Interface ikilisi sağlamaktadır. Abstraction kavramı kafamızda biraz olsun şekillendiğine göre şimdi Abstract Class’ları inceleyebiliriz.
Abstract Class
Abstract sınıflar sınıf hiyerarşisinde genellikle base class (temel sınıf) tanımlamak için kullanılan ve soyutlama yeteneği kazandıran sınıflardır. Bir sınıfı abstract yapmak için abstract keywordünü kullanırız. Abstract sınıflar en az bir tane abstract metod bulundurması bir best practice’tir.

abstract class Yazdir{     public abstract void KonsolaYazdir();}
Yukarıda Yazdir isimli basitçe bir abstract sınıfı tanımladık ve kendisinden türeyecek metodların override edeceği KonsolaYazdir() abstract metodunu oluşturduk.
Genel olarak abstract sınıfların özelliklerini bir araya toplarsak;
•	Abstract sınıfları genel olarak inheritance (kalıtım) uygularken kullanırız.
•	new anahtar sözcüğü ile nesneleri oluşturulamaz.
•	İçerisinde değişken ve metod bulundurabilir.
•	Abstract sınıflardan türetilen sınıfların abstract metodları implement etmesi zorunludur. Diğer metodları override etmeden de kullanabilir.
•	Constructors (yapıcı metodlar) ve destructors (yıkıcı metodlar) bulundurabilirler.
•	Static tanımlanamazlar. ( Tanımlanmaya çalışılırsa compiler “an abstract class cannot be sealed or static” hatası verir)
•	Bir sınıf yalnızca bir abstract sınıfı inheritance yoluyla implement edebilir. Çoklu kalıtım (multiple inheritance) desteklenmez.
•	Abstract olmayan metodları da bulundurabilir.
•	Kendisinden inherit alacak sınıflar ile arasında “is-a” ilişkisi vardır. (Burası ilk başlarda çok önemsenmeyen ancak hangi senaryoda Abstract hangi senaryoda Interface kullanacağımızı netleştirmede bize oldukça yardımcı olan bir detaydır, hemen aşağıda açıklamasını bulabilirsiniz)
Is-a İlişkisi Nedir?
Senaryomuzdan bir örnekle bunun daha iyi anlaşılabileceğini düşünüyorum. (Şimdiye kadar Türkçe kelimeler üzerinden gittiğim için örneğimde de is-a ilişkisi hariç cümlemi Türkçe kuruyorum)

Çarpışan araba is-a araba.
Yani en nihayetinde çarpışan araba da bir arabadır ve arabanın sahip olduğu özellikleri bünyesinde barındırır.
Şimdi Araba için abstract bir sınıf oluşturup çarpışan arabayı da bu sınıftan inherit alarak oluşturalım.

abstract class Araba{    
//Arabalarin ortak ozelliklerini burada tanimliyoruz    
public string Marka { get; set; }    
public int MaksimumHiz { get; set; }    
public string Tur { get; set; }
//Her araba icin yolculuga baslandi bilgisini farkli bir sekilde
//ekrana yazdirmak icin override  dilecek abstract metodumuzu yaziyoruz
public abstract void YolculugaBasla();
}

class CarpisanAraba : Araba{    
//Abstract metodumuzu carpisan arabaya ozel bir sekilde override      ediyoruz.    
public override void YolculugaBasla(){        Console.WriteLine("Carpisan araba ile yolculuga baslandi");    }
}
Araba isminde bir abstract sınıf tanımlayarak CarpisanAraba sınıfını bu abstract base sınıftan türettik. 
Böylece Araba sınıfında yer alan tüm özellikleri tekrardan yazmak zorunda kalmadan kolayca sahip olurken, YolculugaBasla() metodunu sınıfımıza özel override ettik. 
Abstract sınıfları inherit alan sınıfların abstract metodları override etmesinin zorunlu olduğunu belirtmiştik. Bu sebeple Visual Studio’da CarpisanAraba sınıfını Araba sınıfından inherit ettiğinizde, YolculugaBasla() metodunu override etmezseniz hata alırsınız.
Abstract sınıfları genel itibariyle mercek altına aldığımıza göre şimdi bir de Interface’leri inceleyelim. Sonrasında ikisi arasındaki farkları tablo halinde gördüğümüzde hangi senaryoda hangi soyutlama mekanizmasını kullanacağımızı çok daha iyi kestirebilir bir hale geleceğiz.
Interface
Interface, içerisinde sadece kendisinden türeyecek olan sınıfların içini dolduracağı metod tanımlarının bulunduğu ve soyutlama yapmamıza olanak sağlayan bir yapıdır. Interface’leri tanımlarken interface keyword'ünü kullanırız. Tanımladığımız yapının interface olduğunu belirtmek için isminin önüne I harfini getirmek bir best-practice olacaktır. Böylece kodlama yaparken inherit aldığımız yapının bir class mı yoksa interface mi olduğunu kolaylıkla ayırt edebiliriz. Bu kadar teorik bilgiden sonra basitçe bir interface tanımlayalım.

interface ILog{    void LogEkle(string kayit);}
Bu interface’ten türeyen tüm sınıflar LogEkle(string kayit) metodunu implement etmek zorundadır. Interface hakkında internette bir arama yaptığınızda genellikle kendisini inherit alan sınıflar için bir kontrat olduğundan bahsedilir. Kontrat kelimesiyle anlatılmak istenen tam olarak budur. Türeyen sınıflar, interface’in içerisinde yer alan tüm metodları implement edeceğine dair bir söz vermekte, sözleşme yapmaktadır. Aksi halde derleyici hata verecek, kodunuz çalışmayacaktır.
Genel olarak Interface’lerin özelliklerinden bahsetmemiz gerekirse;
•	new keywordü ile nesneleri oluşturulamaz.
•	Bir sınıfın ne yapması gerektiğini belirtir, nasıl yapması gerektiğini değil.
•	Default olarak tüm Interface üyeleri abstract ve public olarak tanımlanır. Sizin özellikle belirtmeniz gerekmez.
•	Bir sınıf birden fazla interface’i inherit edebilir, çoklu kalıtım (multiple-inheritance) desteklenir.
•	İçerisinde yalnızca metodların imzaları yer alır, içi dolu metod bulunduramazlar.
•	Kendisinden inherit alacak sınıflar ile arasında “can-do” ilişkisi vardır.
Can-do İlişkisi Nedir?
Çarpışan araba senaryosundan bir örnekle açıklamak gerekirse,
Çarpışan araba can-do hızlanmak. 
Açıklamaya gerek var mı bilemedim açıkçası ama abstract sınıflarda açıklamışken burada boş bırakmak içime sinmezdi. Çarpışan araba hızlanabilir diyoruz. Çarpışan arabanın bir davranışından bahsediyoruz.
Interfaceleri tam olarak can-do ilişkileri içeren yapılarda kullanmamız isabetli olacaktır. Senaryomuzdaki çarpışan araba hızlanabilir. Bu çarpışan arabanın yapabileceği bir kabiliyetigöstermektedir. Can-do ilişkisi davranışları, kabiliyetleri belirtir. Bu kabiliyetin interface içerisinde tanımlanması çok daha doğru olacaktır.
 
Tablonun orjinaline blog sayfamdan; cozvelioglu.com adresinden ulaşabilirsiniz
Abstract sınıflar ve Interface’ler arasındaki farkları işlediğimiz bu yazıyla birlikte bir yazının daha sonuna geldik. Dilerim aydınlatıcı olmuştur, anlayamadığınız veya gözümden kaçan herhangi bir şey varsa yorumlarda belirtmeniz beni memnun edecektir. Bir sonraki yazıda görüşmek dileğiyle; keyifli kodlamalar, mutlu günler :)!

-
BU da iyi açıklama:
An abstract class is a way to achieve the abstraction in C#. An Abstract class is never intended to be instantiated directly. This class must contain at least one abstract method, which is marked by the keyword or modifier abstract in the class definition. The Abstract classes are typically used to define a base class in the class hierarchy.


Example:

// C# program to illustrate the 
// concept of abstract class 
using System; 
   
public abstract class G { 
    public abstract void gfg1(); 
} 

public class G1 : G { 
  
    // abstract method 'gfg1()' 
    // declare here with 
    // 'override' keyword 
    public override void gfg1() 
    { 
        Console.WriteLine("Class name is G1"); 
    } 
} 
  
// class 'G' inherit in 
// another child class 'G2' 
public class G2 : G { 
  
    // same as the previous class 
    public override void gfg1() 
    { 
        Console.WriteLine("Class name is  G2"); 
    } 
} 
  
// Driver Class 
public class main_method { 
  
    // Main Method 
    public static void Main() 
    { 
  
        // 'obj' is object of class 
        // 'G' class ' 
        // G' cannot 
        // be instantiate 
        G obj; 
  
        // instantiate class 'G1' 
        obj = new G1(); 
  
        // call 'gfg1()' of class 'G1' 
        obj.gfg1(); 
  
        // instantiate class 'G2' 
        obj = new G2(); 
  
        // call 'gfg1()' of class 'G2' 
        obj.gfg1(); 
    } 
} 
Output :



Class name is G1
Class name is  G2

Like a class, Interface can have methods, properties, events, and indexers as its members. But interfaces will contain only the declaration of the members. The implementation of interface’s members will be given by the class who implements the interface implicitly or explicitly.

Example:

// C# program to illustrate the 
// concept of interface 
using System; 
  
// A simple interface 
interface interface1 { 
  
    // method having only declaration 
    // not definition 
    void show(); 
} 
  
// A class that implements the interface. 
class MyClass : interface1 { 
  
    // providing the body part of function 
    public void show() 
    { 
        Console.WriteLine("Welcome to GeeksforGeeks!!!"); 
    } 
  
    // Main Method 
    public static void Main(String[] args) 
    { 
  
        // Creating object 
        MyClass obj1 = new MyClass(); 
  
        // calling method 
        obj1.show(); 
    } 
} 
Output:
Welcome to GeeksforGeeks!!!
Difference between Abstract Class and Interface
ABSTRACT CLASS	INTERFACE
It contains both declaration and definition part.	It contains only a declaration part.
Multiple inheritance is not achieved by abstract class.	Multiple inheritance is achieved by interface.
It contain constructor.
It does not contain constructor.

It can contain static members.	It does not contain static members.
It can contain different types of access modifiers like public, private, protected etc.	It only contains public access modifier because everything in the interface is public.
The performance of an abstract class is fast.	The performance of interface is slow because it requires time to search actual method in the corresponding class.
It is used to implement the core identity of class.	It is used to implement peripheral abilities of class.
A class can only use one abstract class.	A class can use multiple interface.
If many implementations are of the same kind and use common behavior, then it is superior to use abstract class.	If many implementations only share methods, then it is superior to use Interface.
Abstract class can contain methods, fields, constants, etc.	Interface can only contain methods .
It can be fully, partially or not implemented.	It should be fully implemented.
-
-
Web API  (Application Program Interface)
api nedir, web api nedir, Web API nedir
 
ASP.NET Web API is an ideal platform for building RESTful services.

ASP.NET Web API is built on top of ASP.NET and supports ASP.NET request/response pipeline.
ASP.NET Web API maps HTTP verbs to method names.
ASP.NET Web API supports different formats of response data. Built-in support for JSON, XML, BSON format.
ASP.NET Web API can be hosted in IIS, Self-hosted or other web server that supports .NET 4.0+.
ASP.NET Web API framework includes new HttpClient to communicate with Web API server. HttpClient can be used in ASP.MVC server side, Windows Form application, Console application or other apps.
-
-
RESTful API  
(representational state transfer)    (GITHUB)
Restful api nedir?
A RESTful API is an application program interface (API) that uses HTTP requests to GET, PUT, POST and DELETE data.

A RESTful API -- also referred to as a RESTful web service -- is based on representational state transfer (REST) technology, an architectural style and approach to communications often used in web services development.

REST technology is generally preferred to the more robust Simple Object Access Protocol (SOAP) technology because REST leverages less bandwidth, making it more suitable for internet usage. An API for a website is code that allows two software programs to communicate with each another . The API spells out the proper way for a developer to write a program requesting services from an operating system or other application.
-
-
Method Signature 	(GITHUB)
Method Signature nedir

the method signature for your method is:

DoSomething(int, int)

(Yani bir method signature şunlardan oluşur: metod adı, parametrelerin tipi)

Return type is not part of the method signature in C#. Only the method name and its parameters types (but not the parameter names) are part of the signature. You cannot, for example, have these two methods:

int DoSomething(int a, int b);
string DoSomething(int a, int b);

To be clear: Methods cannot be overloaded based on their return type. They must have a unique name, unique parameter types, or pass their arguments differently (e.g. using out or ref).

Edit: To answer your original question, the method signature for your method is:
DoSomething(int, int)
Note that this all applies to normal methods. If you're talking about delegates, then you should see keyboardP's answer. (Short version: return type IS part of the signature for a delegate).

Detay:
Is the return type is a part of signature or not?
It depends on why you are asking the question. Why do you care?
There are two definitions of method signature. The C# language definition does not include the return type, and uses the signature of the method to determine whether two overloads are allowed. Two methods with the same signature are not allowed in a type. Since C# does not consider the return type to be a part of the signature, C# does not allow two methods that differ only in return type to be declared in the same type.
The CLR, however, does include the return type in the signature. The CLR allows for two methods to be in the same type that differ only in return type.
To be more specific: in C# the signature consists of the methods:
•	name
•	number of type parameters
•	number of formal parameters
•	type of each formal parameter
•	out/ref/value-ness of each formal parameter
with the following additional notes:
•	generic type parameter constraints are not part of the signature
•	return type is not part of the signature
•	type parameter and formal parameter names are not part of the signature
•	two methods may not differ only in out/ref
In the CLR the signature consists of:
•	name
•	number of type parameters
•	number of formal parameters
•	type of each formal parameter including modopts and modreqs
•	return type including modopts and modreqs
•	ref/value-ness of each formal parameter
Note that the CLR does not distinguish between "ref int" and "out int" at all when considering signatures. Note that the CLR does distinguish between modopt/modreq types. (The way that the C# compiler deals with modopt/modreq types is too complex to summarize here.)
-
-
Method Overriding (Override) (GITHUB)
method overriding nedir, override nedir

Method Overriding
 
Overriding can be defined as: being able to change or augment the behavior of methods in classes, known as overriding their logic; it is one of the most powerful aspects of Object Oriented Programming.
Explanation
Suppose you have a Phone, no please don’t suppose everyone has a phone today, although some people even have more than one. Okay leave it, so if you have phone:

Then there must be ring facility in it:
 
Now your phone can be of any type, like it can be cellular, satellite or landline, these all types of phones will also have the same or a different functionality (based on their attribute).
 
Now whenever you receive a call, the caller doesn’t know whether you have a cellular phone, landline phone or anything else, he/she just calls you and according to that call operation your phone rings. In the case of method overriding, your phone works as a class and the ring is the functionality.

Keywords in Method Overriding
 
There are the following 3 types of keywords used in C# for method overriding.
 
Override Keyword
In the subclass, it tells the compiler that this method is overriding the same named method in the base class.
1.	public override int myValue()  
2.	{  
3.	     -  
4.	     -  
5.	     -  
6.	}  
Base Keyword
 
In the subclass, it calls the base class method for overriding functionality.
1.	base.myValue();  
Method Overriding Example
1.	using System;  
2.	using System.Collections.Generic;  
3.	using System.Linq;  
4.	using System.Text;  
5.	namespace Hello_Word  
6.	{  
7.	    class baseClass  
8.	    {  
9.	        public virtual void Greetings()  
10.	        {  
11.	            Console.WriteLine("baseClass Saying Hello!");  
12.	        }  
13.	    }  
14.	    class subClass : baseClass  
15.	    {  
16.	        public override void Greetings()  
17.	        {  
18.	            base.Greetings();  
19.	            Console.WriteLine("subClass Saying Hello!");  
20.	        }  
21.	    }  
22.	    class Program  
23.	    {  
24.	        static void Main(string[] args)  
25.	        {  
26.	            baseClass obj1 = new subClass();  
27.	            obj1.Greetings();  
28.	            Console.ReadLine();  
29.	        }  
30.	    }  
31.	}  
  
 
An output window is showing that baseClass will get called first and then subclass. If we make certain changes in this code like:
1.	base.Greetings();  
2.	Console.WriteLine("subClass Saying Hello!"); // current scenario  
After making a few modifications as in the following:
1.	Console.WriteLine("subClass Saying Hello!");  
2.	base.Greetings(); // after modifications  
Now our output will be like this:
 

 

If we remove "base.Greetings();" then the compiler will not call the baseclass as in the following:
1.	using System;  
2.	using System.Collections.Generic;  
3.	using System.Linq;  
4.	using System.Text;  
5.	namespace Hello_Word  
6.	{  
7.	    class baseClass  
8.	    {  
9.	        public virtual void Greetings()  
10.	        {  
11.	            Console.WriteLine("baseClass Saying Hello!");  
12.	        }  
13.	    }  
14.	    class subClass : baseClass  
15.	    {  
16.	        public override void Greetings()  
17.	        {  
18.	            Console.WriteLine("subClass Saying Hello!");  
19.	            // base.Greetings();  
20.	        }  
21.	    }  
22.	    class Program  
23.	    {  
24.	        static void Main(string[] args)  
25.	        {  
26.	            baseClass obj1 = new subClass();  
27.	            obj1.Greetings();  
28.	            Console.ReadLine();  
29.	        }  
30.	    }  
31.	}  
  
 
Now making some other changes, like placing:
1.	baseClass obj1 = new baseClass();  
2.	obj1.Greetings();  
Instead of:
1.	baseClass obj1 = new subClass();  
2.	obj1.Greetings();  

Now let’s check the output window, what’s its showing now:
 
  
 
So as you are seeing that now its calling only the baseClass. So now I guess you will be a little closer to the method overriding functionality.
-


Method Overriding is a technique that allows the invoking of functions from another class (base class) in the derived class. Creating a method in the derived class with the same signature as a method in the base class is called as method overriding.

Bi örnek yaptım. Override'siz metot da çalışıyor hata vermiyor. Benim aşağıdaki kodda incelediğim durum şu linkte de inceleniyor: https://www.geeksforgeeks.org/c-sharp-method-overriding/
    class Program
    {
        class BaseClass
        {
            public virtual void SampleMethod()
            {
                Console.WriteLine("base");
            }

            public void SecondMethod()
            {
                Console.WriteLine("SecondMethod-Base");
            }
        }

        class DerivedClass : BaseClass
        {
            public override void SampleMethod()
            {
                Console.WriteLine("derived");
            }

            public void SecondMethod()
            {
                Console.WriteLine("SecondMethod-DerivedClass");
            }
        }
        class Main_Method
        {
            static void Main()
            {
                DerivedClass d = new DerivedClass();
                d.SampleMethod();

                BaseClass b = new DerivedClass();
                b.SampleMethod();

                BaseClass bc = new BaseClass();
                bc.SampleMethod();

                Console.WriteLine("-");
                d.SecondMethod();
                b.SecondMethod();
                bc.SecondMethod();
            }
        }
    }

-
Başka bir açıklama:
-
Method Overriding in C# is similar to the virtual function in C++. Method Overriding is a technique that allows the invoking of functions from another class (base class) in the derived class. Creating a method in the derived class with the same signature as a method in the base class is called as method overriding.
In simple words, Overriding is a feature that allows a subclass or child class to provide a specific implementation of a method that is already provided by one of its super-classes or parent classes. When a method in a subclass has the same name, same parameters or signature and same return type(or sub-type) as a method in its super-class, then the method in the subclass is said to override the method in the super-class. Method overriding is one of the ways by which C# achieve Run Time Polymorphism(Dynamic Polymorphism).
The method that is overridden by an override declaration is called the overridden base method. An override metho d is a new implementation of a member that is inherited from a base class. The overridden base method must be virtual, abstract, or override.
 
Example:
class base_class
{
    public void gfg();
}

class derived_class : base_class
{
    public void gfg();
}

class Main_Method
{
 static void Main()
 {
    derived_class d = new derived_class();
    d.gfg();
 }
}
Here the base class is inherited in the derived class and the method gfg() which has the same signature in both the classes, is overridden.
-
-
Interface 	(GITHUB)
Interface nedir, interface nedir
An interface defines a contract. Any class or struct that implements that contract must provide an implementation of the members defined in the interface. Beginning with C# 8.0, an interface may define a default implementation for members. It may also define static members in order to provide a single implementation for common functionality.
In the following example, class ImplementationClass must implement a method named SampleMethod that has no parameters and returns void.
For more information and examples, see Interfaces.
Example
interface ISampleInterface
{
    void SampleMethod();
}

class ImplementationClass : ISampleInterface
{
    // Explicit interface member implementation:
    void ISampleInterface.SampleMethod()
    {
        // Method implementation.
    }

    static void Main()
    {
        // Declare an interface instance.
        ISampleInterface obj = new ImplementationClass();

        // Call the member.
        obj.SampleMethod();
    }
}
An interface can be a member of a namespace or a class. An interface declaration can contain declarations (signatures without any implementation) of the following members:
•	Methods
•	Properties
•	Indexers
•	Events
These preceding member declarations typically do not contain a body. Beginning with C# 8.0, an interface member may declare a body. This is called a default implementation. Members with bodies permit the interface to provide a "default" implementation for classes and structs that don't provide an overriding implementation. In addition, beginning with C# 8.0, an interface may include:
•	Constants
•	Operators
•	Static constructor.
•	Nested types
•	Static fields, methods, properties, indexers, and events
•	Member declarations using the explicit interface implementation syntax.
•	Explicit access modifiers (the default access is public).
Interfaces may not contain instance state. While static fields are now permitted, instance fields are not permitted in interfaces. Instance auto-properties are not supported in interfaces, as they would implicitly declare a hidden field. This rule has a subtle effect on property declarations. In an interface declaration, the following code does not declare an auto-implemented property as it does in a class or struct. Instead, it declares a property that doesn't have a default implementation but must be implemented in any type that implements the interface:

public interface INamed
{
  public string Name {get; set;}
}
An interface can inherit from one or more base interfaces. When an interface overrides a method implemented in a base interface, it must use the explicit interface implementation syntax.
When a base type list contains a base class and interfaces, the base class must come first in the list.
A class that implements an interface can explicitly implement members of that interface. An explicitly implemented member cannot be accessed through a class instance, but only through an instance of the interface. In addition, default interface members can only be accessed through an instance of the interface.
For more information about explicit interface implementation, see Explicit Interface Implementation.
Example
The following example demonstrates interface implementation. In this example, the interface contains the property declaration and the class contains the implementation. Any instance of a class that implements IPoint has integer properties x and y.
interface IPoint
{
   // Property signatures:
   int X
   {
      get;
      set;
   }

   int Y
   {
      get;
      set;
   }

   double Distance
   {
       get;
   }
}

class Point : IPoint
{
   // Constructor:
   public Point(int x, int y)
   {
      X = x;
      Y = y;
   }

   // Property implementation:
   public int X { get; set; }

   public int Y { get; set; }

   // Property implementation
   public double Distance =>
      Math.Sqrt(X * X + Y * Y);

}

class MainClass
{
   static void PrintPoint(IPoint p)
   {
      Console.WriteLine("x={0}, y={1}", p.X, p.Y);
   }

   static void Main()
   {
      IPoint p = new Point(2, 3);
      Console.Write("My Point: ");
      PrintPoint(p);
   }
}
// Output: My Point: x=2, y=3

An interface is a completely abstract class, which contains only abstract members.
It is declared using the interface keyword:

        public interface IShape
        {
            void Draw();
        }

All members of the interface are by default abstract, so no need to use the abstract keyword. 
Also, all members of an interface are always public, and no access modifiers can be applied to them.
It is common to use the capital letter I as the starting letter for an interface name.
Interfaces can contain properties, methods, etc. but cannot contain fields (variables).
When a class implements an interface, it must also implement, or define, all of its methods.
The term implementing an interface is used (opposed to the term "inheriting from") to describe the process of creating a class based on an interface. The interface simply describes what a class should do. The class implementing the interface must define how to accomplish the behaviors.
The syntax to implement an interface is the same as that to derive a class: 

        public interface IShape
        {
            void Draw();
        }
        class Circle : IShape
        {
            public void Draw()
            {
                Console.WriteLine("Circle Draw");
            }
        }
        static void Main(string[] args)
        {
            IShape c = new Circle();
            c.Draw();
            //Outputs "Circle Draw"
        }

Note, that the override keyword is not needed when you implement an interface.

But why use interfaces rather than abstract classes? 
A class can inherit from just one base class, but it can implement multiple interfaces!
Therefore, by using interfaces you can include behavior from multiple sources in a class.
To implement multiple interfaces, use a comma separated list of interfaces when creating the class: class A: IShape, IAnimal, etc.
-
-
Liskov Substitution Principle 	(GITHUB) (örnek)
Liskov Substitution Principle nedir, liskov nedir

Interface nedir, interface örnek, liskovv nedir, liskov nedir

Liskov’un Yerine Geçme Prensibi(Liskov Substitution Principle – LSP)
BENİM ÖRNEK:
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
 
class Program
{
    class Student
    {
        public string Name { get; set; }
    }
 
    class Araba: IAraba
    {
        // IAraba'nın metotlarını implement etmesi gerek...
 
        public void Cam() // implement edilen metotlar PUBLIC olmak zorunda.
        {
            Console.WriteLine("");
        }
 
        public void Teker()
        {
 
        }
 
        public string CamaYaziYazdir()
        {
            return "Text";
        }
 
        public Student OgrenciyiArabayaBindir()
        {
            Student student = new Student();
            return student;
        }
    }
 
    //class gibi bir şeydir interface. Parantez açıp kapama yokk. Zaten anlamsız oluyor diğer şekilde.
    interface IAraba
    {
        void Cam(); // köşeli parantez yokk
        void Teker();
        string CamaYaziYazdir();
        Student OgrenciyiArabayaBindir();
    }
 
    
 
}
 



BENİM ÖRNEK:
    class Program
    {
        interface IOyuncakOrdek
        {
            void OrdekSesiCikar();
            void InsanSesiCikar();
            void AyaklariniHareketEttir();
        }

        public class PahaliOrdek : IOyuncakOrdek
        {
            public void OrdekSesiCikar()
            {
                Console.WriteLine("Basarili. Ordek sesi cikarildi!");
            }

            public void InsanSesiCikar()
            {
                Console.WriteLine("Basarili. Insan sesi cikarildi!");
            }

            public void AyaklariniHareketEttir()
            {
                Console.WriteLine("Basarili. Ayaklar hareket ettirildi!");
            }
        }

        public class UcuzOrdek : IOyuncakOrdek
        {
            public void OrdekSesiCikar()
            {
                Console.WriteLine("Basarili. Insan sesi cikarildi!");
            }

            public void InsanSesiCikar()
            {
                throw new NotImplementedException();
                //çünkü ucuz ördek bu özelliğe sahip değil!
            }

            public void AyaklariniHareketEttir()
            {
                throw new NotImplementedException();
                //çünkü ucuz ördek bu özelliğe sahip değil!
            }
        }

        // İşte Liskovv prensibine uymayan bir kod. Çünkü içi boş olan, exception üretecek olan bir metodu implement ediyoruz...
        // Ucuz ördekle pahalı ördek yer değiştirdiğinde sorun oluşmamalı fakat bu örnekte pahalı ordek her metodu başarıyla implement edebilirken ucuz ördek bunu yapamıyor.

        static void Main(string[] args)
        {
            PahaliOrdek pahaliOrdek = new PahaliOrdek();
            pahaliOrdek.OrdekSesiCikar();
            pahaliOrdek.InsanSesiCikar();
            pahaliOrdek.AyaklariniHareketEttir();

            UcuzOrdek ucuzOrdek = new UcuzOrdek();
            ucuzOrdek.OrdekSesiCikar();
            ucuzOrdek.InsanSesiCikar();
            ucuzOrdek.AyaklariniHareketEttir();
        }
    }

 
Merhaba,
Önceki yazılarımda SOLID prensiplerinden S–Tek Sorumluluk Prensibi(Single Responsibility Principle – SRP)‘ni ve O–Açık Kapalı Prensibi(Open Closed Principle – OCP) incelemiştik. Bu yazımızda ise sıradaki L timsaline denk gelen Liskov’un Yerine Geçme Prensibi(Liskov Substitution Principle – LSP) izah edeceğim.
Liskov’un Yerine Geçme Prensibi, diğerlerine göre anlaşılması en zor prensiptir diyebilirim. Barbara Liskov adlı hanımefendi tarafından 1988 yılında ‘Data Abstraction and Hierarchy’ isimli kitabında bu prensip gündeme getirilmiştir.
Her zor konuda olduğu gibi haliyle bu konuda “aslınnda anlaşıldığında çook basitt” diyeceğimiz bir konudur. Lakin bu konuyu zorlaştıran Barbara Liskov’un konuyla alakalı yaptığı açıklamadır. Bunun yanında 2. ve 3. kaynakların konuyu daha basit seviyede anlaşılır bir üslupla ele almalarıdır. Ee son olarakda bizim nam-ı diğer Türkler’in üzerine cila çekmesidir.
Tabi yukarıdaki paragrafta anlattığım durum, kitaplardan ya da makalelerden konuyu okuyarak tek başına öğrenme gayretinde bulunanlar içindir. Eğer alanında uzman bir eğiticiden 1. dereceden eğitim alarak ilgili konuya fakıf olmuşsanız burada yazdıklarıma hak vermemeniz gayet doğal olacaktır.
Velhasıl, bu zorlu ama anlaşılmayı bekleyen konuyu bu makale sonunda net bir şekilde idrak edeceğinizi umuyorum. Tabi öncelikle kitaplarda ve konuyla ilgili makalelerde kafamızı karıştıran tanımlamalara ve yorumlara yer vererek konuya giriş yapıyorum.
Nedir Bu Liskov’un Yerine Geçme Prensibi
LSP’yi orataya atan Barbara Liskov öncülüğünde bir çok kişi ilgili konuyu açıklamaya çalışmış, doğal olarak farklı yaklaşımlardan dolayı farklı izahlar ortaya çıkmıştır. Şimdi bunların bir kısmına göz atalım.
Barbara Liskov’a göre;
Aranan yer değiştirme özelliği şöyle tanımlanabilir: T cinsinden parametre alan tüm programlar (fonksiyonlar) P olacak şekilde, S tipinde o1 nesnesi ve T tipinde o2 nesnesi olsun. Eğer o1 ile o2 nesneleri yer değiştirdiğinde P’nin davranışı değişmiyorsa S tipi T tipinin alt tipidir!
Evet, bende bişey anlamadım.
Bilimsel olarak matematik ile formülüze bir şekilde LSP’ye açıklama getirmişler. O açıklamaya göreyse;
q(x) fonksiyonu T tipindeki x nesnesi için kanıtlanabilirdir. O halde T tipinin alt tipi olan S tipindeki y nesnesi için de q(y) fonksiyonu kanıtlanabilir olmalıdır.
Evet, bundanda bişey anlamadığımız aşikar.
‘Uncle Bob’ lakaplı Robert Cecil Martin ise LSP’yi daha anlaşılır bir vaziyette aşağıdaki gibi izah etmiştir;
Temel sınıfın(base class) işaretçisini(pointer) ya da referansını kullanan fonksiyonlar, bu sınıftan türemiş olan sınıfları(derived class) da ekstra bilgiye ihtiyaç duymaksızın kullanabilmelidir.
Ehhh… Biraz daha yazılımcıya uygun bir açıklama olmuş gibi. En azından base classlar derived classlar derken kafada bişeylerin hayalini kurabiliyoruz. O kadar literatür taradım, kaynak okudum ama şu yukarıdaki açıklamanın bana polimorfizmi anımsattığı kadar kimse gıram bahsetmemiş. Haliyle algıladığımdan şüphelenir oldum. Eğer kaçırdığım bir mana, bir kelime yahut edat bağlaç varsa haber verinde neden yanlış anlamışım farkına varmama yardımcı olun.
Siz bana Uncle Bob’un sözündeki algı hatamı izah edene kadar benim şu kanaatte olduğumu bilmenizi isterim ki, bu yukarıdaki açıklamaların hiçbirinden bir cacık olmaz! Anlamak için anlaşılır bir açıklama gerek. Koskoca prensibi batı algısıyla özetleyecez derken aman dikkat önemsizleştirmeyelim!
Şimdi konuya şahsen girmeden önce bizim Türkler’in konuya getirdikleri açıklamalara göz atalım. (Adreslerini verdiğim yerli yazılımcılar konuyla ilgili araştırma yaparken internette tesadüfen denk geldiklerimdir.)
Ömer İşıker;
Temel sınıfta aşağıdaki sınıflara ait özel fonksiyon vs bulunmamalıdır. Yani temel sınıfta türemiş sınıflardan hiç biri için özel bir şey yazılmış olmamalıdır.
Bu açıklama Ömer İşıker tarafından şu adresteki LSP ile ilgili makalede yer almaktadır. Kanaatimce LSP’ye izahatte bulunmamızı sağlayan yeterli bir açıklama değildir.
Türkay Ürkmez;
Aynı temel sınıftan türeyen tüm sınıflar, birbirlerinin yerine kullanılabilir olmalıdır. Bu yer değiştirme durumunda, sınıfa özel bir istisna kesinlikle oluşmamalıdır.
Şahsi kanaatim, konuya en iyi açıklama getiren Türk yazarımız Türkay Ürkmez’dir. Türkay Ürkmez’in konuyla ilgili makalesi için tıklayınız.
Bir adette ekşi sözlükte konuya izahatte bulunan arkadaşımızın düşüncesini görelim.
yeni bir istek geldi müşteriden, sen de bunu sağlamak için mevcut olan bir class’ten child class üretiyorsun, veyahut method’ları override ediyorsun. mevcut class yerine child class’i kullandığında bir hata oluşmamalı ya da worst case’de çıkan hata, bütün uygulamayı darmadağın etmemeli. türetilmiş sınıflar (ihtiyaç üzerine method’ları override edilmiş ya da extend edilmiş), türetilikleri class’ler ile değiştirilebilir olmalıdır kısaca.
Evet, bu arkadaşımız bayağı uçuk bir izahatte bulunmuşlar. Kanımca LSP’yi ya anlamamış ya da “sttir et LPS’yi… bakın ben terminoloji biliyorum” diye duyurma derdinde. Ha konuyla alakasını sorarsanız eksilerde tabi… Entrye buradan ulaşabilirsiniz.
Daha sürüsüne bereket Türk yazılım geliştirici tarafından ilgili konu ele alınmıştır. Fazla kafa karıştırmak istemediğim için alıntılarda bunlarla yetiniyorum  
Şimdi LSP’yi kendimiz ele alalım.
Barbara Liskov’un ortaya attığı bu prensibe göre üst sınıf ile alt sınıf arasında davranış olarak hiçbir fark olmamalıdır. Yani birbirlerinin yerine kullanılabilmelidirler.
Düşünün ki, arabanıza bir klima düğmesi koydunuz ve onu işlevsiz bıraktınız. Yani görüntüden ibaret ama iş yok. İşte bu durum LSP’ye aykırıdır. LSP, Dummy Code(Sahte kod) dediğimiz bu tarz duruma hayır demektedir. Yani bir düğme varsa işlevide olmalıdır. Buradan yola çıkarsak eğer base classların(kalıtım veren sınıfların), derived classlardaki(kalıtım alan sınıflardaki) işlevselliği tam olarak yerine getirdiğinden emin olmalıyız.
Eee peki ne anlatmaya çalışıyoruz. Bir sınıfta bulunan herhangi bir işlev, kendisinden kalıtım alan sınıflarda kullanılmayacaksa eğer işte bu durum LSP’ye aykırı bir durumdur.
Örnek olarak şöyle bir senaryo çizelim.
Bir ordumuz olsun. Ordumuzdaki uçaklar bir yandan keşife çıkabilsin bir yandan da hedefi vurabilsin.

01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70	interface IUcak
{
    bool KesifYap();
    bool HedefiVur();
}
 
class UcakA : IUcak
{
    public bool HedefiVur()
    {
        Console.WriteLine("UcakA Hedefi vurdu.");
        return true;
    }
    public bool KesifYap()
    {
        Console.WriteLine("UcakA keşfi tamamladı.");
        return true;
    }
}
class UcakB : IUcak
{
    public bool HedefiVur()
    {
        Console.WriteLine("UcakB Hedefi vurdu.");
        return true;
    }
    public bool KesifYap()
    {
        Console.WriteLine("UcakB keşfi tamamladı.");
        return true;
    }
}
class UcakC : IUcak
{
    public bool HedefiVur()
    {
        Console.WriteLine("UcakC Hedefi vurdu.");
        return true;
    }
    public bool KesifYap()
    {
        Console.WriteLine("UcakC keşfi tamamladı.");
        return true;
    }
}
 
class Savas
{
    List<IUcak> Ucaklar;
    public Savas(List<IUcak> Ucaklar)
    {
        this.Ucaklar = Ucaklar;
    }
 
    public void KesifYap()
    {
        Ucaklar.ForEach(u =>
        {
            u.KesifYap();
        });
    }
 
    public void HedefiVur()
    {
        Ucaklar.ForEach(u =>
        {
            u.HedefiVur();
        });
    }
}
Varsayalım ki, ordumuza yeni bir uçak daha geldi ama sadece keşfe çıkabilmektedir.
01
02
03
04
05
06
07
08
09
10
11
12	class UcakD : IUcak
{
    public bool HedefiVur()
    {
        return false;
    }
    public bool KesifYap()
    {
        Console.WriteLine("UcakD keşfi tamamladı.");
        return true;
    }
}
Yeni uçağımızın hedefi vurma özelliği yoktur. Lakin IUcak arayüzümüz tüm elemanları zorla uygulatmaktadır. Eee haliyle base class var olan HedefiVur metodunu derived classta kullanmayacağız. İşte yeni uçağımız(UcakD) için burada HedefiVur metodu Dummy Code yapısındadır.
Peki “HedefiVur” metodunu UcakD’de kullanmayacaksak aşağıdaki gibi önlem almalıyız.
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16	class Savas
{
    .
    .
    .
    public void HedefiVur(
    {
        Ucaklar.ForEach(u =>
        {
            if (!(u is UcakD))
            {
                u.HedefiVur();
            }
        });
    }
}
Yukarıdaki işlem dışında UcakD’de HedefiVur çağrıldığı zaman hata fırlatılıp “Savas” sınıfımızda try catch bloklarıyla kontrol sağlanabilir.
Tabi bunlar konumuzun dışında kalan konulardır. Asıl mevzu LSP’yi ilgilendiren base classtaki kullanılmayacak kodu derived class’a zorla implement etmektir. Haliyle LSP’ye aykırı olan bu durum OCP‘ye de aykırıdır. Çünkü her yeni gelen ve hedefi vuramayan uçakta “Savas” sınıfı içerisinde yeni if – else bloklarıyla kontrol sağlamız gerekecektir. Buda değişiklik demektir.
Gelin şimdi bu sorunu Liskov’un Yerine Geçme Prensibini uygulayarak çözelim.

Class Diyagramında görüldüğü gibi herşey açık ve net. Tasarımımızı LSP’ye uygun bir vaziyette şekillendirebilmek için gördüğünüz gibi base classtaki tüm işlevler farklı arayüzlere bölmüş bulunmaktayım. Bu yaptığımız işlem bir sonraki yazımda ele alacağım arayüz ayrım prensibinede uyarlı bir yaklaşımdır.
“UcakA”, “UcakB” ve “UcakC” hedefi vurma ve keşif yapma özelliklerine sahip oldukları için iki arayüzden de kalıtım almaktadırlar. “UcakD” ise sadece keşif yapabileceği için sadece “IUcakKesif” arayüzünden kalıtım almaktadır. Bu sayede kullanmayacağı bir işlev olan HedefiVur metodunu barındırmak zorunda kalmayacak ve Dummy Code durumunuda ortadan kaldırmış olacağız.
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
	interface IUcakKesif
{
    bool KesifYap();
}
 
interface IHedefiVur
{
    bool HedefiVur();
}
 
class UcakA : IUcakKesif, IHedefiVur
{
    public bool HedefiVur()
    {
        Console.WriteLine("UcakA Hedefi vurdu.");
        return true;
    }
    public bool KesifYap()
    {
        Console.WriteLine("UcakA keşfi tamamladı.");
        return true;
    }
}
class UcakB : IUcakKesif, IHedefiVur
{
    public bool HedefiVur()
    {
        Console.WriteLine("UcakB Hedefi vurdu.");
        return true;
    }
    public bool KesifYap()
    {
        Console.WriteLine("UcakB keşfi tamamladı.");
        return true;
    }
}
class UcakC : IUcakKesif, IHedefiVur
{
    public bool HedefiVur()
    {
        Console.WriteLine("UcakC Hedefi vurdu.");
        return true;
    }
    public bool KesifYap()
    {
        Console.WriteLine("UcakC keşfi tamamladı.");
        return true;
    }
}
class UcakD : IUcakKesif
{
    public bool KesifYap()
    {
        Console.WriteLine("UcakD keşfi tamamladı.");
        return true;
    }
}
 
class Savas
{
    List<IHedefiVur> HedefVurucular;
    List<IUcakKesif> KesifYapicilar;
    public Savas(List<IUcakKesif> KesifYapicilar, List<IHedefiVur> HedefVurucular)
    {
        this.KesifYapicilar = KesifYapicilar;
        this.HedefVurucular = HedefVurucular;
    }
 
    public void KesifYap()
    {
        KesifYapicilar.ForEach(u =>
        {
            u.KesifYap();
        });
    }
 
    public void HedefiVur()
    {
        HedefVurucular.ForEach(u =>
        {
            u.HedefiVur();
        });
    }
}
Gördüğünüz gibi “Savas” sınıfı içerisindeki if – else kontrolüne gerek duymamaktayız. Haliyle bir değişiklik değil gelişimsellik söz konusu olduğu için OCP ve her yapı sade ve sadece kendi işini gördüğü için SRP‘ye uygun bir tasarım gerçekleştirmiş olduk.
Evet… Liskov’un Yerine Geçme Prensibinde bu şekilde bir tasarım ve bakış açısı sergilememiz gerekmektedir. 2. sayfada bu prensibi pekiştirmek amacıyla farklı bir örnek senaryo bulacaksınız.
Okuduğunuz için teşekkür ederim…
Sonraki yazılarımda görüşmek üzere…
İyi çalışmalar dilerim…
-
-

Struct 	(GITHUB) (örnek)
struct nedir

A struct type is a value type that is typically used to encapsulate small groups of related variables, such as the coordinates of a rectangle or the characteristics of an item in an inventory. The following example shows a simple struct declaration:
        struct Book
        {
            public string title;
            public double price;
            public string author;
        }
Structs share most of the same syntax as classes, but are more limited than classes.
Unlike classes, structs can be instantiated without using a new operator.
        static void Main(string[] args)
        {
            Book b;
            b.title = "Test";
            b.price = 5.99;
            b.author = "David";

            Console.WriteLine(b.title);
            //Outputs "Test"
        }
Structs do not support inheritance and cannot contain virtual methods.

Structs can contain methods, properties, indexers, and so on. Structs cannot contain default constructors (a constructor without parameters), but they can have constructors that take parameters. In that case the new keyword is used to instantiate a struct object, similar to class objects.

        struct Point
        {
            public int x;
            public int y;

            public Point(int x, int y)  // Constructor
            {
                this.x = x;
                this.y = y;
            }
        }
        static void Main(string[] args)
        {
            Point p = new Point(10, 15);
            Console.WriteLine(p.x);
            // Outputs 10
        }
-
-
Struct vs. Class 	(GITHUB) (örnek)
struct nedir, class nedir, struct vs class

In general, classes are used to model more complex behavior, or data, that is intended to be modified after a class object is created. Structs are best suited for small data structures that contain primarily data that is not intended to be modified after the struct is created. Consider defining a struct instead of a class if you are trying to represent a simple set of data. 

All standard C# types (int, double, bool, char, etc.) are actually structs.

Merhaba,
Programlama dillerinde en mühim OOP(Object Oriented Programing) yapılarından olan class yapısına göre daha basit düzeyde işlemler gerçekleştirmemizi sağlayan ve belirli bir takım kısıtlamaları yanında barındıran struct yapısını C# diline özel ele alacağız.
Şimdi düşünün ki, bir yapı oluşturacaksınız ve bu yapı birbirleriyle ilişkili verileri barındıracaktır. Haliyle bunu bir class olarak belirleyebilir ve o classtan üretilen nesne üzerinde işlemlerimizi icra edebiliriz. Amma velakin bu yapımız class kadar kompleks işlemler için tasarlanmış bir yapı gerektirmiyorsa ve tutulacak verileri enkapsüle etmek yetiyorsa işte bu tarz durumlarda struct yapısını tercih edebiliriz.
Unutmayınız ki, classlar bir Referans Tipli(Reference Types) özellik gösterirken struct yapıları bir Değer Tipli(Value Types) değişken özelliği göstermektedir.
Yani anlayacağınız “int” gibi, “bool” gibi değer tipli bir değişken oluşturmak istiyorsanız struct yapısını tercih edebilirsiniz.
Bu demek oluyor ki, gerçekleştireceğimiz işlevselliğin yapısal olarak bir nesne yahut değer tipli bir değişken yapısında gerçekleştirilmesini tercih edebilir ve birazdan bahsedeceğim olumlu olumsuz yanlarıda hesaba katarak projenizde performansı daha maliyetli bir hale getirebilirsiniz.
Şimdi struct yapısını C# perspektifinden adım adım değerlendirelim;
	Yazımızın yukarıdaki satırlarında da bahsettiğimiz gibi struct C#’ta value type yaratabileceğimiz yapıdır.
	struct yapıları, herhangi bir struct yahut class’tan kalıtım alamazlar.
 		 	
	Benzer şekilde bir class yapısıda struct yapısından miras alamamaktadır.
	struct yapıları, interface yapılarını uygulayabilmektedirler.
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19	struct MyStruct1 : IInterface
{
    int x;
    bool y;
    public void A()
    {
        throw new NotImplementedException();
    }
    public void B(bool c)
    {
        throw new NotImplementedException();
    }
}
 
interface IInterface
{
    void A();
    void B(bool c);
}
	struct yapılar new keywordüyle örneklendirilebilmektedir. Burada iki durum söz konusudur.
1.	Eğer new operatörüyle örneklendirirsek ne olur?
Bildiğiniz gibi new operatörü classlarda kullanıldığı zaman ilgili classtan bir nesne talep edilmekte ve üretilen nesne belleğin Heap kısmında muhafaza edilmektedir. Ee söz gelimi struct yapısında da new operatörünü kullanırsak eğer evet ilgili yapıdan bir nesne üretilecektir ama struct bir değer tipli değişken yapısında olduğundan dolayı o nesne belleğin Stack kısmında muhafaza edilecektir.
Bu yapıya kadar oluşturduğumuz tüm nesnelerin Heap kısmında olduğunu söylemiştik. Halbuki Stack kısmında struct yapısında nesneleri tutabilmekteyiz.
Ayriyetten struct içerisindeki fieldlara default değerleri atanmış olacaktır.
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20	public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();
    }
 
    private void Form1_Load(object sender, EventArgs e)
    {
        MyStruct ms = new MyStruct();
        MessageBox.Show(ms.x + " " + ms.y + " " + ms.z);
    }
}
 
struct MyStruct
{
    public int x;
    public bool y;
    public string z;
}
Ekran çıktısı aşağıdadır.
 
2.	Eğer new operatörü kullanmazsak ne olur?

3.	Haliyle classlardaki gibi nesne mecburiyeti yoktur. Yani new operatörü ile struct yapıdan bir nesne üretmeden de o struct’ı kullanabilmekteyiz.
 
Yukarıda da gördüğünüz gibi nesnesiz structları kullanabilmekteyiz kullanmasına ama içerisindeki verilerin ilk değerleri atanmayacağından dolayı hata alınacaktır.
İşte böyle bir durumda ilk değerleri atayarak kullanmak gerekecektir.
1
2
3
4
5	MyStruct ms;
ms.x = 3;
ms.y = true;
ms.z = "abc";
MessageBox.Show(ms.x + " " + ms.y + " " + ms.z);
Anlayacağınız class yapıları new keywordü ile belleğe fiziksel olarak çıkabilmekte ve kullanılabilmektedir. Aksi taktirde belleğe çıkamamaktadırlar. Struct’larda ise new ile belleğe çıkma zorunluluğu yoktur lakin içerisindeki elemanların ilk değerleri mecburi verilmek zorundadır.
	struct yapılar içerilerinde metod, property veya field barındabilirler.
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16	struct MyStruct
{
    public int x;
    public bool y;
    public string z { get; set; }
 
    public double Islem()
    {
        if (y)
        {
            return x * int.Parse(z);
        }
 
        return -1;
    }
}
	Haliyle bu elemanlardan metodları kullanabilmek için struct değişkenine new operatörüyle bir nesne bağlama zorunluluğumuz yoktur. Ama property yapılarını kullanabilmek için struct’tan bir nesneye ihtiyacımız vardır.
1
2
3
4
5
6
7
8	private void Form1_Load(object sender, EventArgs e)
{
    MyStruct ms = new MyStruct();
    ms.x = 3;
    ms.y = true;
    ms.z = "3";
    MessageBox.Show(ms.x + " " + ms.y + " " + ms.z + " " + ms.Islem());
}
	struct yapılar içlerinde static alanlar barındırabilirler.
1
2
3
4
5
6
7
8
9	struct MyStruct
{
    public int x;
 
    static public double Islem()
    {
        return -1;
    }
}
	ve bu static yapılara normal bildiğiniz yapı ismi üzerinden .(nokta) diyerek ulaşabilmekteyiz.
1	MyStruct.Islem().ToString();
	Ve son olarak struct yapılar içerisinde class, class içerisinde de struct yapılar tanımlanabilir.
 	 
Evet, gördüğünüz gibi struct dediğimiz aslen yapısal ve içerik(implicit) olarak bir sealed class‘tır diyebiliriz. Bunun yanında daha hafif(lightweight) bir class yapısı olduğu söylenebilir. İçeriğimizden de anlaşılacağına göre Tip Tanımlama(Type Definition) yaparken kullanabiliriz.
İçerikte bahsedildiği gibi referans değil, değer tipli bir yapı göstermesinin sebebini aşağıdaki örnekten de anlayabiliriz.

Burada dikkat ederseniz eğer ms.x ve ms.y değişmeyeceğinden dolayı bir Deep Copy söz konusudur. Eğer referans tipli yapılar olsalardı aşağıdaki gibi bir sonuç elde edilecekti ve Shallow Copy söz konusu olacaktı.
 
Gördüğünüz gibi iki referansta aynı nesneyi işaret ettiğinden dolayı referanslar üzerindeki field değerleri doğal olarak aynı sonucu vermekte yani mc.x ve mc.y değişkenlik göstermektedir.
Son olarak struct yapılarıyla ilgili uç bir noktaya daha değinip içeriğimizi sonlandıralım.
struct yapılar, kendilerini this keywordünü kullanarak değiştirebilen yapılardır.
Örneğin;
 
Aslında bu tarz bir işleme class yapısı izin vermediğinden dolayı ilginç bir özelliktir.
 
Güzel ve eğlenceli bir konununda sonuna gelmiş bulunmaktayız.
Okuduğunuz için hepinize teşekkür ederim…
Sonraki yazılarımda görüşmek üzere diyelim…  
İyi çalışmalar…
Bir başka kaynak:
In C#, a structure is a value type data type. It helps you to make a single variable hold related data of various data types. The struct keyword is used for creating a structure.
Structures are used to represent a record. Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book −
•	Title
•	Author
•	Subject
•	Book ID
Defining a Structure
To define a structure, you must use the struct statement. The struct statement defines a new data type, with more than one member for your program.
For example, here is the way you can declare the Book structure −
struct Books {
   public string title;
   public string author;
   public string subject;
   public int book_id;
};  
The following program shows the use of the structure −
Live Demo
using System;

struct Books {
   public string title;
   public string author;
   public string subject;
   public int book_id;
};  

public class testStructure {
   public static void Main(string[] args) {
      Books Book1;   /* Declare Book1 of type Book */
      Books Book2;   /* Declare Book2 of type Book */

      /* book 1 specification */
      Book1.title = "C Programming";
      Book1.author = "Nuha Ali"; 
      Book1.subject = "C Programming Tutorial";
      Book1.book_id = 6495407;

      /* book 2 specification */
      Book2.title = "Telecom Billing";
      Book2.author = "Zara Ali";
      Book2.subject =  "Telecom Billing Tutorial";
      Book2.book_id = 6495700;

      /* print Book1 info */
      Console.WriteLine( "Book 1 title : {0}", Book1.title);
      Console.WriteLine("Book 1 author : {0}", Book1.author);
      Console.WriteLine("Book 1 subject : {0}", Book1.subject);
      Console.WriteLine("Book 1 book_id :{0}", Book1.book_id);

      /* print Book2 info */
      Console.WriteLine("Book 2 title : {0}", Book2.title);
      Console.WriteLine("Book 2 author : {0}", Book2.author);
      Console.WriteLine("Book 2 subject : {0}", Book2.subject);
      Console.WriteLine("Book 2 book_id : {0}", Book2.book_id);       

      Console.ReadKey();
   }
}
When the above code is compiled and executed, it produces the following result −
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
Features of C# Structures
You have already used a simple structure named Books. Structures in C# are quite different from that in traditional C or C++. The C# structures have the following features −
•	Structures can have methods, fields, indexers, properties, operator methods, and events.
•	Structures can have defined constructors, but not destructors. However, you cannot define a default constructor for a structure. The default constructor is automatically defined and cannot be changed.
•	Unlike classes, structures cannot inherit other structures or classes.
•	Structures cannot be used as a base for other structures or classes.
•	A structure can implement one or more interfaces.
•	Structure members cannot be specified as abstract, virtual, or protected.
•	When you create a struct object using the New operator, it gets created and the appropriate constructor is called. Unlike classes, structs can be instantiated without using the New operator.
•	If the New operator is not used, the fields remain unassigned and the object cannot be used until all the fields are initialized.

Class versus Structure
Classes and Structures have the following basic differences −
•	classes are reference types and structs are value types
•	structures do not support inheritance
•	structures cannot have default constructor
In the light of the above discussions, let us rewrite the previous example −
Live Demo
using System;

struct Books {
   private string title;
   private string author;
   private string subject;
   private int book_id;
   
   public void getValues(string t, string a, string s, int id) {
      title = t;
      author = a;
      subject = s;
      book_id = id;
   }
   
   public void display() {
      Console.WriteLine("Title : {0}", title);
      Console.WriteLine("Author : {0}", author);
      Console.WriteLine("Subject : {0}", subject);
      Console.WriteLine("Book_id :{0}", book_id);
   }
};  

public class testStructure {

   public static void Main(string[] args) {
      Books Book1 = new Books();   /* Declare Book1 of type Book */
      Books Book2 = new Books();   /* Declare Book2 of type Book */

      /* book 1 specification */
      Book1.getValues("C Programming",
      "Nuha Ali", "C Programming Tutorial",6495407);

      /* book 2 specification */
      Book2.getValues("Telecom Billing",
      "Zara Ali", "Telecom Billing Tutorial", 6495700);

      /* print Book1 info */
      Book1.display();

      /* print Book2 info */
      Book2.display(); 

      Console.ReadKey();
   }
}
When the above code is compiled and executed, it produces the following result −
Title : C Programming
Author : Nuha Ali
Subject : C Programming Tutorial
Book_id : 6495407
Title : Telecom Billing
Author : Zara Ali
Subject : Telecom Billing Tutorial
Book_id : 6495700
-
Bir diğer kaynak:
C# - Struct
________________________________________
Updated on: June 25, 2020
________________________________________
In C#, struct is the value type data type that represents data structures. It can contain a parameterized constructor, static constructor, constants, fields, methods, properties, indexers, operators, events, and nested types.
struct can be used to hold small data values that do not require inheritance, e.g. coordinate points, key-value pairs, and complex data structure.
Structure Declaration
A structure is declared using struct keyword. The default modifier is internal for the struct and its members.
The following example declares a structure Coordinate for the graph.
Example: Structure
struct Coordinate
{
    public int x;
    public int y;
}
A struct object can be created with or without the new operator, same as primitive type variables.
Example: Create Structure
struct Coordinate
{
    public int x;
    public int y;
}

Coordinate point = new Coordinate();
Console.WriteLine(point.x); //output: 0  
Console.WriteLine(point.y); //output: 0  
Try it
Above, an object of the Coordinate structure is created using the new keyword. It calls the default parameterless constructor of the struct, which initializes all the members to their default value of the specified data type.
If you declare a variable of struct type without using new keyword, it does not call any constructor, so all the members remain unassigned. Therefore, you must assign values to each member before accessing them, otherwise, it will give a compile-time error.
Example: Create Structure Without new Keyword
struct Coordinate
{
    public int x;
    public int y;
}

Coordinate point;
Console.Write(point.x); // Compile time error  

point.x = 10;
point.y = 20;
Console.Write(point.x); //output: 10  
Console.Write(point.y); //output: 20  

Constructors in Structure
A struct cannot contain a parameterless constructor. It can only contain parameterized constructors or a static constructor.
Example: Parameterized Constructor in Struct
struct Coordinate
{
    public int x;
    public int y;

    public Coordinate(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
}

Coordinate point = new Coordinate(10, 20);

Console.WriteLine(point.x); //output: 10  
Console.WriteLine(point.y); //output: 20  
Try it
You must include all the members of the struct in the parameterized constructor and assign parameters to members; otherwise C# compiler will give a compile-time error if any member remains unassigned.
Methods and Properties in Structure
A struct can contain properties, auto-implemented properties, methods, etc., same as classes.
Example: Methods and Properties in Struct
struct Coordinate
{
    public int x { get; set; }
    public int y { get; set; }

    public void SetOrigin()
    {
        this.x = 0;
        this.y = 0;
    }
}

Coordinate point = Coordinate();
point.SetOrigin();

Console.WriteLine(point.x); //output: 0  
Console.WriteLine(point.y); //output: 0  
Try it
The following struct includes the static method.
Example: Static Constructor in Struct
struct Coordinate
{
    public int x;
    public int y;

    public Coordinate(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    public static Coordinate GetOrigin()
    {
        return new Coordinate();
    }
}

Coordinate point = Coordinate.GetOrigin();

Console.WriteLine(point.x); //output: 0  
Console.WriteLine(point.y); //output: 0  
Try it
Events in Structure
A struct can contain events to notify subscribers about some action. The following struct contains an event.
Example: Event in Structure
struct Coordinate
{
    private int _x, _y;

    public int x 
    {
        get{
            return _x;
        }

        set{
            _x = value;
            CoordinatesChanged(_x);
        }
    }

    public int y
    {
        get{
            return _y;
        }

        set{
            _y = value;
            CoordinatesChanged(_y);
        }
    }

    public event Action<int> CoordinatesChanged;
}
The above structure contains CoordinatesChanged event, which will be raised when x or y coordinate changes. The following example demonstrates the handling of the CoordinatesChanged event.
Example: Handle Structure Events
class Program
{
    static void Main(string[] args)
    {

        Coordinate point = new Coordinate();
        
        point.CoordinatesChanged += StructEventHandler;
        point.x = 10;
        point.y = 20;
    }

    static void StructEventHandler(int point)
    {
        Console.WriteLine("Coordinate changed to {0}", point);
    }
} 
struct is a value type, so it is faster than a class object. Use struct whenever you want to just store the data. Generally, structs are good for game programming. However, it is easier to transfer a class object than a struct. So do not use struct when you are passing data across the wire or to other classes.
Summary
•	struct can include constructors, constants, fields, methods, properties, indexers, operators, events & nested types.
•	struct cannot include a parameterless constructor or a destructor.
•	struct can implement interfaces, same as class.
•	struct cannot inherit another structure or class, and it cannot be the base of a class.
•	struct members cannot be specified as abstract, sealed, virtual, or protected
-
-
Enumeration	(GITHUB) (örnek)
enumeration nedir

An enumeration is a complete, ordered listing of all the items in a collection. The term is commonly used in mathematics and computer science to refer to a listing of all of the elements of a set. The precise requirements for an enumeration (for example, whether the set must be finite, or whether the list is allowed to contain repetitions) depend on the discipline of study and the context of a given problem.
Some sets can be enumerated by means of a natural ordering (such as 1, 2, 3, 4, ... for the set of positive integers), but in other cases it may be necessary to impose a (perhaps arbitrary) ordering. In some contexts, such as enumerative combinatorics, the term enumeration is used more in the sense of counting – with emphasis on determination of the number of elements that a set contains, rather than the production of an explicit listing of those elements.
-
-
Enum 	(GITHUB) (örnek)
enum nedir, enum keyword nedir
The enum keyword is used to declare an enumeration: a type that consists of a set of named constants called the enumerator list.
By default, the first enumerator has the value 0, and the value of each successive enumerator is increased by 1.
For example, in the following enumeration, Sun is 0, Mon is 1, Tue is 2, and so on:

        enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat };

You can also assign your own enumerator values:

        enum Days { Sun, Mon, Tue = 4, Wed, Thu, Fri, Sat };

In the example above, the enumeration will start from 0.
Sun is 0, then Mon is 1, Tue is 4, Wed is 5, and so on. The value of the next item in an Enum is one increment of the previous value.
Note that the values are comma separated.
You can refer to the values in the Enum with the dot syntax.
In order to assign Enum values to int variables, you have to specify the type in parentheses:

        enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat };

        static void Main(string[] args)
        {
            int x = (int)Days.Sat;
            Console.WriteLine(x);
            Console.ReadKey();
            //Outputs 6
        }
Basically, Enums define variables that represent members of a fixed set.
Some sample Enum uses include month names, days of the week, cards in a deck, etc.
-
-
interface vs. abstract class (GITHUB) (örnek)
enum nedir, enum keyword nedir

https://medium.com/software-development-turkey/abstract-class-ve-interface-aras%C4%B1ndaki-farklar-nelerdir-3c0a4f956eba
Total encapsulation sunar, bunu sağlamak isteyen programmer'lar interface kullanmalıdır. Multiple inheritance kullanma amacındaysak bu işi interface ile yapabiliriz. Tüm metotların sadece ne yaptığı belli, nasıl yaptığı belirsizdir çünkü interface içindeki memberlar sadece signature'a sahip olan metotlara sahiplerdir. İçi dolu olan, yani işlemi "nasıl" yaptığı belli olan bir metot barındırmaz. Dolayısıyla tam bir encapsulation sağlar.
Interface'in avantajları: 

•  It is used to achieve loose coupling.
•  It is used to achieve total abstraction.
•  To achieve component-based programming
•  To achieve multiple inheritance and abstraction.
•  Interfaces add a plug and play like architecture into applications.

  Points to Remember :
1.	An interface only contains declarations of method, properties, indexers, and events.
2.	An interface can be implement implicitly or explicitly by a class or struct.
3.	A class or struct which implements an interface, must use 'public' access modifier.
4.	An interface cannot include private, protected, or internal members. All the members are public by default.
5.	Do not include 'public' in an interface as all the members are public by default. C# will give compile-time error if used 'public'.
6.	Implement interface explicitly using InterfaceName. with all the members.
7.	An interface can inherit one or more interfaces.

An interface is like a contract. In the human world, the contract between the two or more humans binds them to act as per the contract. In the same way, the interface includes the declaration of one or more functionalities. Entities that implement the interface must define functionalities declared in the interface. In C#, a class or a struct can implement one or more interfaces.
In C#, an interface can be defined using the interface keyword. Interfaces can contain methods, properties, indexers, and events as members.
Consider the following IPen interface that declares some basic functionality for a pen.
Example: An Interface
interface IPen
{
    string Color { get; set; }
    bool Open();
    bool Close();
    void Write(string text);
}
Example: Invalid Interface with Access Modifiers
interface IPen
{
    public string Color { get; set; }  //error
    protected bool Open(); //error
    private bool Close();  //error
    protected internal void Write(string text);//error
}
An interface can only contain declarations but not implementations. The following will give a compile-time error.
Example: Invalid Interface with Implementation
interface IPen
{
    string Color { get; set; }
    bool Open();
    bool Close();
    void Write(string text){
        Console.Write(text);  //error: cannot implement method
    }
}
Implementing an Interface
For example, the following class implements IPen interface implicitly.
Example: Interface Implementation
class Cello : IPen
{
    public string Color { get; set; }
        
    private bool isOpen = false;
        
    public bool Close()
    {
        isOpen = false;
        Console.WriteLine("Cello closed for writing!");

        return isOpen;
    }

    public bool Open()
    {
        isOpen = true;
        Console.WriteLine("Cello open for writing!");
            
        return isOpen;
    }

    public void Write(string text)
    {
        //write text if open
        if(isOpen)
            Console.WriteLine("Cello: " + text);
    }
}
In the above example, the Cello class implements the IPen interface. It defines all the members of the IPen interface with public access modifier. However, other non-interface members of the class can have any access modifiers e.g. isOpen field is a private member of the Cello class.
 Note:
All the members of the interface must be implemented with the public modifier in a class or struct. C# will give a compile-time error if any one of the members declared other than public access modifier.
Explicit Interface Implementation
Explicit implementation is useful when class is implementing multiple interface thereby it is more readable and eliminates the confusion. It is also useful if interfaces have same method name coincidently.
 Note:
Do not use public modifier with an explicit implementation. It will give compile time error.
You can implement interface explicitly by prefixing interface name with all the members of an interface, as shown below:
Example: Explicit Implementation
class Cello : IPen
{
    string IPen.Color { get; set; }
        
    private bool isOpen = false;
        
    bool IPen.Close()
    {
        isOpen = false;
        Console.WriteLine("Cello closed for writing!");

        return isOpen;
    }

    bool IPen.Open()
    {
        isOpen = true;
        Console.WriteLine("Cello open for writing!");
            
        return isOpen;
    }

    void IPen.Write(string text)
    {
        //write text if open
        if(isOpen)
            Console.WriteLine("Cello: " + text);
    }
} 
In the above example of explicit implementation, notice that it cannot use access modifier 'public' explicitly. C# will give an error if you use 'public' modifier when implementing interface explicitly.

There can be multiple classes or structs that implements the same interface. Consider the following example.
class Parker : IPen
{
    public string Color { get; set; }
        
    private bool canWrite = false;
        
    public bool Close()
    {
        canWrite = false;
        Console.WriteLine("Parker is closed now!");

        return canWrite;
    }

    public bool Open()
    {
        canWrite = true;
        Console.WriteLine("Parker is open now!");
            
        return canWrite;
    }

    public void Write(string text)
    {
        //write text if open
        if(canWrite)
            Console.WriteLine("Parker: " + text);
    }
}
As you can see, the Parker class implements the IPen class. It implements the same functionalities declared in IPen class but in a different way than Cello class. (prints different messages in Open(), Close() and Write() methods.) Thus, multiple classes or Structs can implement the same interface which performs the same action but differently.
You can now create objects of the class and assigned to a variable of interface type.
Example: Interface Type Variable
IPen pen1 = new Cello();

IPen pen2 = new Parker();
Try it
The same variable can be used to instantiate all the classes which implemented IPen interface.
IPen mypen = new Cello();
mypen = new Parker(); // assign Parker object to same variable
Implement Multiple Interfaces
A class or struct can implement multiple interfaces and must define all the members of all interfaces.
Example: Implement Multiple Interface
interface IBrandedPen
{
    string GetBrandName();
}

class Parker : IPen, IBrandedPen
{
    //Implement all members of IPen and IBrandedPen
}
Now, the Parker class can be instantiated and assigned to either IPen or IBrandedPen interface, as shown below.
Example: Interface Type Variables
IPen pen1 = new Parker();
pen1.Open();// valid 
pen1.GetBrandName(); //Compile-time error. Cannot call IBrandedPen method on the object of type IPen

IBrandedPen pen2 = new Parker();
pen2.GetBrandName();// valid 
pen2.Open();//Compile-time error. Cannot call IPen method on the object of type IBrandedPen
Try it
As you can see, an object only supports methods of an interface to which it assigned to, e.g. pen1 assigned to IPen so only supports methods of IPen and not of IBrandedPen.
An interface can also inherit one or more interface.
Example: Interface Inheritance
interface IPen
{
    string Color { get; set; }
    bool Open();
    bool Close();
    void Write(string text);
}

interface IBrandedPen : IPen 
{
    string GetBrandName();
}

class Parker : IBrandedPen
{
    //Implement all members of IPen and IBrandedPen
}

Kendi yaptığım örnek, hata olabilir belki:
using System;
 
class Program
{
    public abstract class AbstractClass
    {
        //public abstract int AbstractInt; //hata verir: field can not be abstract.
 
        public int Number; //örnek field'ımızı oluşturmuş olduk.
        public string Text; //örnek field.
 
        //Aşağıdaki WriteSomething metodu AbstractClass'ı implement eden class'larda kullanılmak zorunda değil. Çünkü abstract değil bu metot. Interface - Abstract class arası farklardan birisi bu.
        public void WriteSomething()
        {
            Console.WriteLine("FullMethod içindeyiz.");
            //görüldüğü gibi, AbstractMethod'da sadece bir signature metot oluşturabilirken burada içi dolu, yani normal metotlar oluş
            //turabiliriz. Abstract class'larda bu yapılabilirken interface'lerde yapılamamaktadır.
        }
 
        //public abstract AbstractMethod(); //hata verir. Bir şey geriye dönmüyorsan void keyword eklemelisin. Aşağıdaki SampleMethod'a bak örneğin.
 
        public abstract NormalClass SampleMethod(); //abstact metot olduğu için override edilmelidir.
 
        public abstract void AbstractMethod(); //abstact metot olduğu için override edilmelidir.
    }
 
    public class NormalClass : AbstractClass
    {
        public string Name { get; set; }
 
        //NormalClass'ı oluşturup içini boş bırakırsak hata verir. Çünkü AbstractClass'taki abstract member'leri implement etmemiz zorunludur (interface'de signature metotların mecburen class'ta kullanılmasının gerektiği gibi). Edelim:
 
        //public void AbstractMethod()
        //{
 
        //}
 
        //Yukarıdaki hata verir. Çünkü override keyword'ünü kullanmadık (interface'de override kullanmıyoruz, farklardan biri. Kullanarak tekrardan oluşturalım:
 
        //Aşağıdaki AbstractMethod public olmalıdır. Çünkü bu bir Abstract Member'dir. 
        //Abstract member: implement edilen class'tan gelen, implement edilmesi zorunlu olan abstract member'lar
        //Zaten public access modifier'ini silersen hatayı görürsün. Bu önemli...
        //Ayrıca hatanın devamını okumak da faydalı olur:  ...can not change access rights.. Yani erişim haklarını değiştiremezsin! çünkü abstract class içindeki bu metot public'ti ve sen burada onu private olmaya zorluyorsun; yani erişim haklarını değiştirmeye çalışıyorsun.
         public override void AbstractMethod()
        {
            Console.WriteLine("NormalClass içindeyiz.");
        }
 
        public override NormalClass SampleMethod()
        {
            throw new NotImplementedException();
        }
    }
 
    public class NormalClass2 : AbstractClass
    {
        public override void AbstractMethod()
        {
            Console.WriteLine("NormalClass2 içindeyiz.");
        }
 
        public override NormalClass SampleMethod()
        {
            throw new NotImplementedException();
        }
    }
 
    interface ISampleInterfaceForMessaging
    {
        void KullaniciyaBildirimYolla(string text);
    }
 
    class SampleClassForSendMessage : ISampleInterfaceForMessaging
    {
        public void KullaniciyaBildirimYolla(string yollanacakBildirim)  //bunun public olması gerekiyor. Interface'deki metotlara ulaşabilmesi için public olması gerekiyor. C# da bu uyarıyı zaten veriyor.
        {
            Console.WriteLine("Telefona mesaj göndererek bildirim yapıldı. Yollanan bildirim şudur: " + yollanacakBildirim);
        }
    }
 
    class SampleClassForSendMail : ISampleInterfaceForMessaging
    {
        public void KullaniciyaBildirimYolla(string yollanacakBildirim)
        {
            Console.WriteLine("E-mail adresine mail göndererek bildirim yapıldı. Yollanan bildirim şudur: " + yollanacakBildirim);
        }
    }
 
 
    static void Main(string[] args)
    {
        Console.WriteLine("Hello World!");
 
        NormalClass normalClass = new NormalClass();
        normalClass.AbstractMethod();
 
        NormalClass2 normalClass2 = new NormalClass2();
        normalClass2.AbstractMethod();
 
        //--------------
        SampleClassForSendMessage sampleClassForSendMessage = new SampleClassForSendMessage();
        sampleClassForSendMessage.KullaniciyaBildirimYolla("messahe");
 
        SampleClassForSendMail sampleClassForSendMail = new SampleClassForSendMail();
        sampleClassForSendMail.KullaniciyaBildirimYolla("mail");
    }
}
-
Interface örnek, interface örnek:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using CodeInConsole;
 
namespace CodeInConsole
{
    class Program
    {
        public class Student
        {
            public int Id { get; set; }
            public string Name { get; set; }
        }
 
        interface IWork
        {
            Student GetStudentById(int id);
            void DoSomething();
            IList<Student> GetStudentList();
        }
 
        public class StudentWorks : IWork
        {
            public IList<Student> StudentList = CreateSampleDataAndPopulateStudentList();
 
            public IList<Student> GetStudentList()
            {
                return StudentList;
            }
 
            public Student GetStudentById(int id)
            {
                var s1 = StudentList.Cast<Student>().ElementAt(0); // pseudo
                return s1;
            }
 
            public void DoSomething()
            {
                Console.WriteLine("");
            }
        }
 
        public static IList<Student> CreateSampleDataAndPopulateStudentList()
        {
            Student s1 = new Student();
            s1.Id = 1;
            s1.Name = "Eren";
 
            Student s2 = new Student();
            s2.Id = 2;
            s2.Name = "Ahmet";
 
            var studentList = new List<Student>();
            studentList.Add(s1);
            studentList.Add(s2);
 
            return studentList;
        }
 
        public static void Main(string[] args)
        {
            StudentWorks studentWorks = new StudentWorks();
 
            studentWorks.GetStudentById(1);
            studentWorks.DoSomething();
            studentWorks.GetStudentList();
 
            Console.ReadKey();
        }
    }
}
-
-
Html Helper 	(GITHUB - yetersiz) (örnek)
html helper nedir
-
HtmlHelper class generates html elements. For example, 
@Html.ActionLink("Create New", "Create") 
would generate anchor tag:
 <a href="/Student/Create">Create New</a>.
Visual Studio also provides minimum IntelliSense support when writing HTML Helpers, as the parameters for the HTML Helper methods are all strings. For example, in the following code, the LabelFor and TextBoxFor HTML Helper methods are used to create a label and textbox for a model property:
Copy
<div class="form-group"> 
    @Html.LabelFor(m => m.Email, new { @class = "col-md-2 control-label" }) 
    <div class="col-md-10"> 
        @Html.TextBoxFor(m => m.Email, new { @class = "form-control" }) 
    </div> 
</div> 
Because the class is a reserved word in C#, you will notice in the preceding code how you have to append the @ sign in order to...
The difference between HTML Helpers and Tag Helpers
Tag Helpers are attached to HTML elements inside your Razor views and can help you write markup that is both cleaner and easier to read than the traditional HTML Helpers. HTML Helpers, on the other hand, are invoked as methods that are mixed with HTML inside your Razor views.
-
-
Razor 	(GITHUB) (örnek)
razor nedir, razor view nedir
Razor bir markup syntax'ıdır. MVC'nin view tarafında kullanılır.
Razor is a markup syntax that lets you embed server-based code into web pages using C# and cshtml is the extension of razor file Cshtml = cs (C#) + HTML. Components are typically implemented in Razor Component files (.razor) using a combination of C# and HTML markup (.cshtml files are used in Blazor apps).
-
-
Reference Type, Value Type  	(GITHUB) (örnek)
Reference type nedir, Value type nedir,

Reference Data Types : The Reference Data Types will contain a memory address of variable value because the reference types won’t store the variable value directly in memory. The built-in reference types are string, object.

Value Data Types : In C#, the Value Data Types will directly store the variable value in memory and it will also accept both signed and unsigned literals. The derived class for these data types are System.ValueType. Following are different Value Data Types in C# programming language:…
Value Type VALUE TUTAR. Adı üstünde… Başka da bişey tutmaz. Yani sadece Value alacak… 0,1,2,3 gibi…
Reference Type da reference tutar. Adı üstünde. Yani referansını tutar…
Initialize etmediğimiz bir int değeri olsun;
Int newInt;
Bu obje'nin bu haldeki değeri 0 olur.Null olmaz. Çünkü int'ler value type'dır ve value'den başka bir şey tutamaz. (Int, yukarıdaki haliyle null olamaz, bir int değeri null olabilmesi için int? şeklinde declare edilmelidir)
String asdf;
Bu ise Reference Type olduğu için null değere işaret eder. Yani değeri NULL olur. Çünkü String'ler Reference Type'dır. Bir değeri yoktur. Değeri olmayan bir verinin ADRESİNİ TUTAR. Adresini tuttuğu şeyin değeri yoktur şu anda (String asdf;). Bu yüzden bu string'in şu anki değeri NULL olur.
-
-
HyperText, HyperMedia	(GITHUB) (örnek)
Hypertext nedir, hypermedia nedir 
Hypertext is text which contains links to other texts. The term was coined by Ted Nelson around 1965.
HyperMedia is a term used for hypertext which is not constrained to be text: it can include graphics, video and sound , for example. Apparently Ted Nelson was the first to use this term too.
Hypertext and HyperMedia are concepts, not products.
-
-
HTTP	(GITHUB) (örnek)
http nedir
The Hypertext Transfer Protocol (HTTP) is designed to enable communications between clients and servers. 
HTTP works as a request-response protocol between a client and server. 
A web browser may be the client, and an application on a computer that hosts a web site may be the server. 
Example: A client (browser) submits an HTTP request to the server; then the server returns a response to the client. The response contains status information about the request and may also contain the requested content. 
HTTP Methods
GET
POST
PUT
HEAD
DELETE
PATCH
OPTIONS
-
-
Tag Helper	(GITHUB) (örnek)
Tag Helper nedir, taghelper nedir
Detay: https://docs.microsoft.com/tr-tr/aspnet/core/mvc/views/tag-helpers/intro?view=aspnetcore-3.0
Tag Helpers enable server-side code to participate in creating and rendering HTML elements in Razor files. Tag helpers are a new feature and similar to HTML helpers, which help us render HTML.

örnek:
Rendering Links
The easiest way to render an HTML link in a view is to use the HTML.ActionLink() helper. The Html.ActionLink() does not link to a view. Instead, you use the Html.ActionLink() helper to create a link to a controller action.
For example, the view in Listing 1 includes a link to an action named About (see Figure 1).
Figure 1 – Link rendered by Html.ActionLink() helper
 

Tag Helpers enable server-side code to participate in creating and rendering HTML elements in Razor files. For example, the built-in ImageTagHelper can append a version number to the image name. Whenever the image changes, the server generates a new unique version for the image, so clients are guaranteed to get the current image (instead of a stale cached image). There are many built-in Tag Helpers for common tasks - such as creating forms, links, loading assets and more - and even more available in public GitHub repositories and as NuGet packages. Tag Helpers are authored in C#, and they target HTML elements based on element name, attribute name, or parent tag. For example, the built-in LabelTagHelper can target the HTML <label> element when the LabelTagHelper attributes are applied. If you're familiar with HTML Helpers, Tag Helpers reduce the explicit transitions between HTML and C# in Razor views. In many cases, HTML Helpers provide an alternative approach to a specific Tag Helper, but it's important to recognize that Tag Helpers don't replace HTML Helpers and there's not a Tag Helper for each HTML Helper. Tag Helpers compared to HTML Helpers explains the differences in more detail.
public class Movie
{
    public int ID { get; set; }
    public string Title { get; set; }
    public DateTime ReleaseDate { get; set; }
    public string Genre { get; set; }
    public decimal Price { get; set; }
}
The following Razor markup:
<label asp-for="Movie.Title"></label>
Generates the following HTML:
<label for="Movie_Title">Title</label>

Tag Helper nedir ve yararları nelerdir?
Tag helper server-side kodlarımızı html tagleri gibi oluşturup kullanmamızı sağlar. Tag Helper HTML ve C# arasındaki geçişleri azaltır.(Yani Razor görünümü azalır-@ kullanımı azalmış olur.) Bu da bizlere Viewmizin daha okunabilir, anlaşılabilir ve kolay geliştirilebilir hale getirmesini sağlamaktadır.

Örneğin;

  @Html.ActionLink("Go to index","Index","Home")
  <a asp-action="index" asp-controller="home" >Go to index</a>

HTML taglerimide asp- dediğimizde o tagin Tag Helperları kullanabiliriz. VS bizlere IntelliSense desteğini de sağlamaktadır.
Tag Helperları kullanmak istiyorsak 
View/_ViewImports.cshtml üzerinden yapıyoruz.
-
-
StringBuilder	(GITHUB) (örnek)
StringBuilder nedir
Detay:
The String object is immutable. Every time you use one of the methods in the System.String class, you create a new string object in memory, which requires a new allocation of space for that new object. In situations where you need to perform repeated modifications to a string, the overhead associated with creating a new String object can be costly. The System.Text.StringBuilder class can be used when you want to modify a string without creating a new object. For example, using the StringBuilder class can boost performance when concatenating many strings together in a loop.
-
-
Mutable and Immutable (GITHUB)  (örnek)
mutable nedir, immutable nedir
In English Language Mutable means "can change" and immutable means "cannot change". The term Immutable Object means that the state of the Object cannot change after its creation. An immutable type sets the property or state of the object as read only because it cannot be modified after it is assigned during initialization.
Is String in .Net immutable ?
Yes, the String in .Net is immutable. The System.String class is an immutable type provided in the .NET framework class library. Since a String is an immutable type, it cannot be modified. When you modify a string you are actually creating a new string object with the desired value.
e.g.
 
The above code will create 1000 new string variables in the memory.
-
-
DataSet (GITHUB)  (örnek)
dataset nedir
DataSet. This is a collection of DataTables. We use the DataSet type to store many DataTables in a single collection. Conceptually, the DataSet acts as a set of DataTable instances.
Usage. DataSet simplifies programs that use many DataTables. To effectively use the DataSet, you will need to have some DataTables handy. We begin by creating some.
Create. In this program, we create two DataTables. One stores two rows of patient information. And the second stores two rows of medication information.
Next: We create a DataSet with the DataSet constructor. Then we add the two DataTables to the DataSet instance. Finally we print the XML.


public ActionResult Index()
        {
            // Çalıştırabilmek için Controller adını "Home" olarak değiştirmek gerekebilir (gerekmeyedebilir).


            ////////////////////////////////////////////////////////////////////////////////
            // DataSet Nedir?


            // Önce DataSet oluşturuldu
            // Sonra DataTable oluşturuldu (tablo)
            // Sonra oluşturulan tabloya kolonlar eklendi
            // Sonra bu kolonlara örnek veriler eklendi (datarow)
            // Sonra ilk başta oluşturduğumuz Dataset'in içine, DataTable'ımızı yerleştirdik ve View'a yolladık.

            DataSet ds = new DataSet();
            DataTable dt = new DataTable("YeniTablo");

            dt.Clear();

            dt.Columns.Add("Isim");
            dt.Columns.Add("SoyIsim");

            DataRow dr = dt.NewRow();

            dr["Isim"] = "Eren";
            dr["SoyIsim"] = "OZTEN";
            dt.Rows.Add(dr);

            ds.Tables.Add(dt);

            return View(ds);

            //View Kısmı ise şöyle olmalı:

            /*

            @model System.Data.DataSet

            @using System.Data

            @foreach (DataRow row in Model.Tables["YeniTablo"].Rows)
            {
                @(row["Isim"] + " " + row["SoyIsim"])
            }

            @{
                ViewBag.Title = "Home Page";
            }

            */

            ////////////////////////////////////////////////////////////////////////////////
        }
-
-
Dapper, ADO.NET - EF hız karşılaştırma
There's no doubt that Entity Framework with LINQ is great (I've certainly written enough articles about it). But Entity Framework comes at a cost. As Matthew Jones points out on his blog, using LINQ+Entity Framework adds time to each data retrieval compared to using ADO.NET's SqlDataAdapter. The cost is small (anywhere from a third of a millisecond to 100 milliseconds) but it's not zero, either.
If speed is important to you but you don't want to give up object-oriented data access, then you can consider using Dapper. Like Entity Framework, Dapper is an Object Relation Mapper that allows you to issue queries against a relational database and get back objects. What's attractive about Dapper, compared to Entity Framework, is that its response times are equivalent to using pure ADO.NET.
-
-
Base keyword      (GITHUB)  (örnek)
Base nedir, base keyword nedir
The base keyword is used to access members of the base class from within a derived class:
•	Call a method on the base class that has been overridden by another method.
•	Specify which base-class constructor should be called when creating instances of the derived class.
A base class access is permitted only in a constructor, an instance method, or an instance property accessor.
It is an error to use the base keyword from within a static method.
The base class that is accessed is the base class specified in the class declaration. For example, if you specify class ClassB : ClassA, the members of ClassA are accessed from ClassB, regardless of the base class of ClassA.

Örnekte base kullanılmış. Güzel örnek:
using System;
using System.Collections.Generic;

public class Shape
{
    // A few example members
    public int X { get; private set; }
    public int Y { get; private set; }
    public int Height { get; set; }
    public int Width { get; set; }
   
    // Virtual method
    public virtual void Draw()
    {
        Console.WriteLine("Performing base class drawing tasks");
    }
}

class Circle : Shape
{
    public override void Draw()
    {
        // Code to draw a circle...
        Console.WriteLine("Drawing a circle");
        base.Draw();
    }
}
class Rectangle : Shape
{
    public override void Draw()
    {
        // Code to draw a rectangle...
        Console.WriteLine("Drawing a rectangle");
        base.Draw();
    }
}
class Triangle : Shape
{
    public override void Draw()
    {
        // Code to draw a triangle...
        Console.WriteLine("Drawing a triangle");
        base.Draw();
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Polymorphism at work #1: a Rectangle, Triangle and Circle
        // can all be used whereever a Shape is expected. No cast is
        // required because an implicit conversion exists from a derived 
        // class to its base class.
        var shapes = new List<Shape>
        {
            new Rectangle(),
            new Triangle(),
            new Circle()
        };

        // Polymorphism at work #2: the virtual method Draw is
        // invoked on each of the derived classes, not the base class.
        foreach (var shape in shapes)
        {
            shape.Draw();
        }

        // Keep the console open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
    }

}

/* Output:
    Drawing a rectangle
    Performing base class drawing tasks
    Drawing a triangle
    Performing base class drawing tasks
    Drawing a circle
    Performing base class drawing tasks
 */
-
-
abstract	    (GITHUB)  (örnek)
abstract nedir
The abstract modifier indicates that the thing being modified has a missing or incomplete implementation. The abstract modifier can be used with classes, methods, properties, indexers, and events. Use the abstract modifier in a class declaration to indicate that a class is intended only to be a base class of other classes, not instantiated on its own. Members marked as abstract must be implemented by non-abstract classes that derive from the abstract class.
Example
In this example, the class Square must provide an implementation of GetArea because it derives from Shape:
C#Copy
abstract class Shape
{
    public abstract int GetArea();
}

class Square : Shape
{
    int side;

    public Square(int n) => side = n;

    // GetArea method is required to avoid a compile-time error.
    public override int GetArea() => side * side;

    static void Main()
    {
        var sq = new Square(12);
        Console.WriteLine($"Area of the square = {sq.GetArea()}");
    }
}
// Output: Area of the square = 144
Abstract classes have the following features:
•	An abstract class cannot be instantiated.
•	An abstract class may contain abstract methods and accessors.
•	It is not possible to modify an abstract class with the sealed modifier because the two modifiers have opposite meanings. The sealed modifier prevents a class from being inherited and the abstract modifier requires a class to be inherited.
-
-
Abstract data type 	(GITHUB) (örnek)
Abstract data type nedir
Abstract Data type (ADT) is a type (or class) for objects whose behaviour is defined by a set of value and a set of operations.
The definition of ADT only mentions what operations are to be performed but not how these operations will be implemented. It does not specify how data will be organized in memory and what algorithms will be used for implementing the operations. It is called “abstract” because it gives an implementation-independent view. The process of providing only the essentials and hiding the details is known as abstraction.
 
The user of data type does not need to know how that data type is implemented, for example, we have been using Primitive values like int, float, char data types only with the knowledge that these data type can operate and be performed on without any idea of how they are implemented. So a user only needs to know what a data type can do, but not how it will be implemented. Think of ADT as a black box which hides the inner structure and design of the data type. Now we’ll define three ADTs namely List ADT, Stack ADT, Queue ADT.
1.	List ADT
•	The data is generally stored in key sequence in a list which has a head structure consisting of count, pointers and address of compare function needed to compare the data in the list.
 


•	The data node contains the pointer to a data structure and a self-referential pointer which points to the next node in the list.
filter_none
brightness_4
//List ADT Type Definitions 
typedef struct node 
{ 
 void *DataPtr; 
 struct node *link; 
} Node; 
typedef struct
{ 
 int count; 
 Node *pos; 
 Node *head; 
 Node *rear; 
 int (*compare) (void *argument1, void *argument2) 
} LIST;  
•	The List ADT Functions is given below:
 
A list contains elements of the same type arranged in sequential order and following operations can be performed on the list.
•	get() – Return an element from the list at any given position.
•	insert() – Insert an element at any position of the list.
•	remove() – Remove the first occurrence of any element from a non-empty list.
•	removeAt() – Remove the element at a specified location from a non-empty list.
•	replace() – Replace an element at any position by another element.
•	size() – Return the number of elements in the list.
•	isEmpty() – Return true if the list is empty, otherwise return false.
•	isFull() – Return true if the list is full, otherwise return false.
2.	Stack ADT
•	In Stack ADT Implementation instead of data being stored in each node, the pointer to data is stored.
•	The program allocates memory for the data and address is passed to the stack ADT.
 
•	The head node and the data nodes are encapsulated in the ADT. The calling function can only see the pointer to the stack.
•	The stack head structure also contains a pointer to top and count of number of entries currently in stack.

filter_none
brightness_4
//Stack ADT Type Definitions 
typedef struct node 
{ 
 void *DataPtr; 
 struct node *link; 
} StackNode; 
typedef struct
{ 
 int count; 
 StackNode *top; 
} STACK; 
A Stack contains elements of the same type arranged in sequential order. All operations take place at a single end that is top of the stack and following operations can be performed:
•	push() – Insert an element at one end of the stack called top.
•	pop() – Remove and return the element at the top of the stack, if it is not empty.
•	peek() – Return the element at the top of the stack without removing it, if the stack is not empty.
•	size() – Return the number of elements in the stack.
•	isEmpty() – Return true if the stack is empty, otherwise return false.
•	isFull() – Return true if the stack is full, otherwise return false.
3.	Queue ADT
•	The queue abstract data type (ADT) follows the basic design of the stack abstract data type.
 
•	Each node contains a void pointer to the data and the link pointer to the next element in the queue. The program’s responsibility is to allocate memory for storing the data.


//Queue ADT Type Definitions 
typedef struct node 
{ 
 void *DataPtr; 
 struct node *next; 
} QueueNode; 
typedef struct 
{ 
 QueueNode *front; 
 QueueNode *rear; 
 int count; 
} QUEUE; 
A Queue contains elements of the same type arranged in sequential order. Operations take place at both ends, insertion is done at the end and deletion is done at the front. Following operations can be performed:
•	enqueue() – Insert an element at the end of the queue.
•	dequeue() – Remove and return the first element of the queue, if the queue is not empty.
•	peek() – Return the element of the queue without removing it, if the queue is not empty.
•	size() – Return the number of elements in the queue.
•	isEmpty() – Return true if the queue is empty, otherwise return false.
•	isFull() – Return true if the queue is full, otherwise return false.
From these definitions, we can clearly see that the definitions do not specify how these ADTs will be represented and how the operations will be carried out. There can be different ways to implement an ADT, for example, the List ADT can be implemented using arrays, or singly linked list or doubly linked list. Similarly, stack ADT and Queue ADT can be implemented using arrays or linked lists.
Reference: https://en.wikipedia.org/wiki/Abstract_data_type
This article is contributed by Anuj Chauhan. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.
Don’t stop now and take your learning to the next level. Learn all the important concepts of Data Structures and Algorithms with the help of the most trusted course: DSA Self Paced. Become industry ready at a student-friendly price.
-
-
Microsoft Exchange Server  (GITHUB) (örnek)

Microsoft Exchange Server nedir
Microsoft Exchange Server, Microsoft tarafından üretilen bir haberleşme yazılımıdır. Sunucu ürünlerinden Microsoft Servers'ın bir parçası olup Microsoft altyapısına sahip sistemlerde sıkça kullanılmaktadır. Exchange'in öne çıkan özellikleri e-posta, takvim, kişiler ve işler, bilgiye web tabanlı erişim olanağı ve veri depolama desteğidir.


Dependency injection (services) in ASP.NET CORE
ASP.NET Core has a built-in dependency injection (DI) framework that makes configured services available to an app's classes. One way to get an instance of a service in a class is to create a constructor with a parameter of the required type. The parameter can be the service type or an interface. The DI system provides the service at runtime.
Here's a class that uses DI to get an Entity Framework Core context object. 
-
-
Apache Subversion / Subversion (eski adı)
apache subversion nedir, subversion nedir

SVN: Subversion bir sürüm takip sistemidir. Kısaca SVN olarak da adlandırılmaktadır.
Ortak bir depoda sürümlenmiş şekilde saklanan proje dosyalarını geliştiriceler kendilerine tanımlanmış kullanıcı adı ile çekebilirler. Kendi depolama alanına çekilen bu dosyalar üzerinde işlemler yapıp tekrar ortak depoya gönderebilirle


Yazılım geliştirmede Apache Subversion (eski adıyla Subversion[1], 2000 yılında CollabNet firması tarafından başlatılan ve desteklenen bir sürüm kontrol sistemidir. Yazılım geliştiricileri Subversion'ı kaynak kodu, ağ sayfaları veya belgelendirme gibi dosyaların güncel ve geçmiş tüm değişikliklerini tutmak için kullanırlar. Amacı yaygın olarak kullanılan Concurrent Versions System (CVS)'in olabildiğince uyumlu bir ardılı olmaktır.
Açık kaynak topluluğu Subversion'ı yaygın olarak kullanmıştır: örneğin Apache Software Foundation projelerinde, Free Pascal, FreeBSD, GCC, Django, Ruby, Mono, SourceForge, ExtJS, Tigris.org, PHP ve MediaWiki. Google Code açık kaynak proje barındırmalarında Subversion desteği de vermektedir. CodePlex diğer istemcilere olduğu kadar Subversion erişimi de sağlamaktadır.
İş dünyası da Subversion kullanımı kabul etmeye başlamıştır. Forrester Research tarafından 2007 yılında hazırlanan bir rapora göre Tekbaşına Yazılım Konfigürasyonu Yönetimi (SCM) kategorisinde Subversion'ı lider ve Yazılım Konfigürasyonu ve Değişiklik Yönetimi (SCCM) alanında da güçlü bir oyuncu gösterilmiştir.[2]
Subversion Apache Lisansını kullanmaktadır ve açık kaynak kodludur.
-
-
Single Page Application 
Single web application nedir
Ajax yollama json dönme sayfanın tamamen yenilenmeden içeriğinin değişmesi olayının teknik anlatımı.. Bir örnek üzerinden anlatılıyor:
The app uses a single-page application (SPA) design. "Single-page application" is the general term for a web application that loads a single HTML page and then updates the page dynamically, instead of loading new pages. After the initial page load, the app talks with the server through AJAX requests. The AJAX requests return JSON data, which the app uses to update the UI.

AJAX isn't new, but today there are JavaScript frameworks that make it easier to build and maintain a large sophisticated SPA application. This tutorial uses Knockout.js, but you can use any JavaScript client framework.

Here are the main building blocks for this app:

ASP.NET MVC creates the HTML page.
ASP.NET Web API handles the AJAX requests and returns JSON data.
Knockout.js data-binds the HTML elements to the JSON data.
Entity Framework talks to the database.
-
-
XHTML     (GITHUB) (örnek)
What Is XHTML?
XHTML stands for EXtensible HyperText Markup Language
XHTML is almost identical to HTML
XHTML is stricter than HTML
XHTML is HTML defined as an XML application
XHTML is supported by all major browsers 
Why XHTML?
Many pages on the internet contain "bad" HTML.
This HTML code works fine in most browsers (even if it does not follow the HTML rules):
<html>
<head>
  <title>This is bad HTML</title>

<body>
  <h1>Bad HTML
  <p>This is a paragraph
</body>

Today's market consists of different browser technologies. Some browsers run on computers, and some browsers run on mobile phones or other small devices. Smaller devices often lack the resources or power to interpret "bad" markup.
XML is a markup language where documents must be marked up correctly (be "well-formed").
XHTML was developed by combining the strengths of HTML and XML.
XHTML is HTML redesigned as XML.

The Most Important Differences from HTML:
Document Structure:
XHTML DOCTYPE is mandatory
The xmlns attribute in <html> is mandatory
<html>, <head>, <title>, and <body> are mandatory
XHTML Elements:
XHTML elements must be properly nested
XHTML elements must always be closed
XHTML elements must be in lowercase
XHTML documents must have one root element
XHTML Attributes:
Attribute names must be in lower case
Attribute values must be quoted
Attribute minimization is forbidden
<!DOCTYPE ....> Is Mandatory
An XHTML document must have an XHTML DOCTYPE declaration.
A complete list of all the XHTML Doctypes is found in our HTML Tags Reference.
The <html>, <head>, <title>, and <body> elements must also be present, and the xmlns attribute in <html> must specify the xml namespace for the document.
This example shows an XHTML document with a minimum of required tags:
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <title>Title of document</title>
</head>

<body>
  some content
</body>

</html>

XHTML Elements Must Be Properly Nested
In HTML, some elements can be improperly nested within each other, like this:
<b><i>This text is bold and italic</b></i>
In XHTML, all elements must be properly nested within each other, like this:
<b><i>This text is bold and italic</i></b>
________________________________________
XHTML Elements Must Always Be Closed
This is wrong:
<p>This is a paragraph
<p>This is another paragraph
This is correct:
<p>This is a paragraph</p>
<p>This is another paragraph</p>
________________________________________
Empty Elements Must Also Be Closed
This is wrong:
A break: <br>
A horizontal rule: <hr>
An image: <img src="happy.gif" alt="Happy face">
This is correct:
A break: <br />
A horizontal rule: <hr />
An image: <img src="happy.gif" alt="Happy face" />
________________________________________
XHTML Elements Must Be In Lower Case
This is wrong:
<BODY>
<P>This is a paragraph</P>
</BODY>
This is correct:
<body>
<p>This is a paragraph</p>
</body>
________________________________________
XHTML Attribute Names Must Be In Lower Case
This is wrong:
<table WIDTH="100%">
This is correct:
<table width="100%">





