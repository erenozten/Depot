2021 - REPETITION!
-
-
-
-
-
-
To make sure that database connections are properly closed and the resources they hold freed up, you have to dispose the context instance when you are done with it. That is why the scaffolded code provides a Dispose method at the end of the StudentController class in StudentController.cs, as shown in the following example: 
protected override void Dispose(bool disposing)
{
    db.Dispose();
    base.Dispose(disposing);
}

If you don't specify a connection string or the name of one explicitly, Entity Framework assumes that the connection string name is the same as the class name. The default connection string name in this example would then be SchoolContext, the same as what you're specifying explicitly.
The name of the connection string (which you'll add to the Web.config file later) is passed in to the constructor.
public SchoolContext() : base("SchoolContext")
{
}
-
-
-
-
-
-
BOŞ		(bosch)	 (bosch)
ne nedir
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Delete(int id)
{
    try
    {
        Student student = db.Students.Find(id);
        db.Students.Remove(student);
        db.SaveChanges();
    }
    catch (DataException/* dex */)
    {
        //Log the error (uncomment dex variable name and add a line here to write a log.
        return RedirectToAction("Delete", new { id = id, saveChangesError = true });
    }
    return RedirectToAction("Index");
}
This code retrieves the selected entity, then calls the Remove method to set the entity's status to Deleted. When SaveChanges is called, a SQL DELETE command is generated. You have also changed the action method name from DeleteConfirmed to Delete. The scaffolded code named the HttpPost Delete method DeleteConfirmed to give the HttpPost method a unique signature. (The CLR requires overloaded methods to have different method parameters.) Now that the signatures are unique, you can stick with the MVC convention and use the same name for the HttpPost and HttpGet delete methods.
If improving performance in a high-volume application is a priority, you could avoid an unnecessary SQL query to retrieve the row by replacing the lines of code that call the Find and Remove methods with the following code:
C#Copy
Student studentToDelete = new Student() { ID = id };
db.Entry(studentToDelete).State = EntityState.Deleted;
This code instantiates a Student entity using only the primary key value and then sets the entity state to Deleted. That's all that the Entity Framework needs in order to delete the entity.
-
-
-
A query string is the portion of a URL where data is passed to a web application and/or back-end database. The reason we need query strings is that the HTTP protocol is stateless by design. For a website to be anything more than a brochure, you need to maintain state (store data). 
There are a number of ways to do this: On most web servers, you can use something like session state server-side. On the client, you can store via cookies. Or in the URL, you can store data via a query string. 

On the world wide web, all URLs can be broken down into the protocol, the location of the file (or program) and the query string. The protocol you see in a browser is almost always HTTP; the location is the typical form of the hostname and filename (for example, www.techopedia.com/somefile.html), and the query string is whatever follows the question mark sign ("?").
For example, in the URL below, the bolded area is the query string that was generated when the term "database" was searched on the Techopedia website.
//www.techopedia.com
-
-
-
-
-
-
HTTPPost method hides information from URL and does not bind data to URL. It is more secure than HttpGet method but it is slower than HttpGet. It is only useful when you are passing sensitive information to the server.
-
-
-
-
-
-
A static class can contain only the static members while a non-static class can contain static members. Static classes are by-default sealed so they cannot be inherited.
-
-
-
-
-
-
MVC, server-side bir sistemdir. Server-side sistemlerde end-user sadece html-javascript i görebilir. Csharp koduna erişemez.
Mvc bir UI-centric bir sistem değil; Server side’dır. 
-
-
-
-
-
Önemli repository bilgi:
You could instantiate a new context in the repository, but then if you used multiple repositories in one controller, each would end up with a separate context. Later you'll use multiple repositories in the Course controller, and you'll see how a unit of work class can ensure that all repositories use the same context.
-
-
-
-
-
-
Kısayollar / Keyboard Shortcuts	(GITHUB) (asasas)
Kısayol nedir, shortcut nedir
-
f2 - değişkene yeni isim ver (sistemdeki hepsinin)
ctrl alt f9  - breakpoint’e götürüyo seni

Ctrl  backspace    kelimeyi siliyo tamamen sola doğru
Ctrl  delete kelimeyi olduğu gibi siliyor. Sağa doğru siliyor. // ctrl + backspace de sola  doğru siliyor

ctrl + shift + nokta -> aynı değişkenlerin tümünü aynı anda editleme imkanı sağlıyor. (bende çalışmıyo)

-
Chrome offers “F5” key and the “Ctrl+R” key combination are used to reload the currently open Web page. 
Chrome also offers the reload shortcut combinations of “Ctrl + F5” and “Ctrl + Shift + R” to reload the currently open page and override the locally cached version.
Having cursor in the address field and pressing ENTER will also do the same as CTRL + F5
-Home, end (numpad’dakiler) : satırın başına ve sonuna gider. (shift ile de kullanılır, yazıyı seçmek için...)

-Klavyenin üstündeki normal home end tuşları: sayfanın başına ve sonuna gider.

-Numpad’daki home end tuşları ctrl ile kullanıldığında, tıpkı klavyenin üstündeki home-end tuşları gibi çalışıyor. Yani klavyenin üstündeki home-end tuşlarını kullanmaya gerek yok gibi görünüyor.

-Ctrl – yön tuşları  kelimenin başına sonuna gidiyor atlayarak.

-Next Error (F2) (çalışmadı)

-Previous error (Shift + F2) ) (çalışmadı)

-Expand Selection (Ctrl + W)

-Ctrl + n  search everywhere (acayip bişey) / create new file

- alt + yukarı aşağı arrows  iki satırın yerini birbiri arasında değiştirme.

- shift + alt  veya sadece alt-> kare alan seçme (çoklu satır)

-
Don’t use anything in the cache when making the request. Forces the browser to re-download every JavaScript file, image, text file, etc.

Empty Cache and Hard Reload
Empty Cache and hard reload = Empty the cache and Force the browser do re-download every JavaScript file, image, text file, etc.
Chrome kısayol: 
Crtl+F5 or Shift+F5 -> re-download cached content (i.e. JavaScript files, images, etc…)
Normal Reload
F5 or Control + R = Reload the current page
“Ctrl+R” is the same thing as pressing f5. This will use the cache in every way possible. If the browser can avoid re-downloading JavaScript files, images, text files, etc. then it will.
Note: Having cursor in the address field and pressing ENTER will also do the same as CTRL + F5
Hard reload / Force Refresh
Control + Shift + R or Control + F5 or Shift + F5 = ignoring cached content
Obviously if the cache is empty then it will have to do a hard reload in order to load the required/support files again. This will again force the browser to re-download everything. However, if the page makes any after the fact downloads via JavaScript that weren’t part of page load, then these might still use the cache, which is where emptying the cache helps because it makes sure that even these won’t use cached files.

RESHARPER:

Ctrl + T

-

Step over code to skip functions
When you are on a line of code that is a function or method call, you can press F10(Debug > Step Over) instead of F11.


Advance the debugger out of the current function
Sometimes, you might want to continue your debugging session but advance the debugger all the way through the current function.
Press Shift + F11 (or Debug > Step Out).
This command resumes app execution (and advances the debugger) until the current function returns.
-
F10 vs F11
https://stackoverflow.com/questions/15584132/what-is-the-difference-between-f10-and-f11-keys-in-visual-studio/39843982
F10 ("step over") does not descend any further into the call stack. It moves to the next line of the current function.
F11 ("step into") drills down into the function being called.
void function1()
{
    function2();
    function3();
}
If you hit a breakpoint on function2(), F10 will advance to the line function3(). F11 will advance to the first line inside function2.
-

CHROME
CTRL + SHIFT + C --> konsolu açmadan (ters tıklayıp incele demeden) mause'un üstünde olduğu elementi seçiyor. Muhteşem.

RESHARPER
alt FL   SAVE

ALT WL    QUIT ALL

ctrl D	  copy paste

ctrl tab   açık dosyalar arası geçiş 
ismin adının üstüne gelip F2 -> ismi değiştirmek için (projenin tümünde her yerde değiştirmek için)

ctrl shift r  bir class'ı yeni bir folder'a taşı

ctrl W kopyalıyor bi üst element/metoda kadar. (geri almak için: ctrl shift W)

alt aşağı / yukarı   metodlar arası geçiş

ctrl B  class definition'una gitme (ctrl click ile aynı)


windows+ sağ yön tuşu (visual studio’yu ekranın sağına yapıştırıyor. Google chrome’u açıp sola bas, onu da sola yapıştır.

f3    search yapılan text'i ara (diğer satırlarda)

ctrl alt J     kelimeyi <tag> ile çevreleme

ctrl f12    sayfa içinde text ara

ctrl shift R   model'imizi farklı bir klasöre taşımak istiyorsak. (namespace'i de değiştiriyor, kolaylık sağlıyor)

windows + sağ sol yukarı yön tuşları: progrmı büyütme yana yatırma 

ctrl tab   sekmeler arası geçiş

ctrl r     kullanma. F5 ile aynı. Eğer tam refresh yapmak istiyorsan ctrl shift f5 yap.

alt enter (en alttaki seçenekten: sayfadaki aynı textlerin tümünü değiştirme)
-
ctrl f10 - cursor'ın olduğu yere kadar projeyi çalıştırır. Break point koymuşsun gibi.
-
-
HARD RELOAD – NORMAL RELOAD nedir
Normal reload
The same thing as pressing F5. This will use the cache but revalidate everything during page load, looking for "304 Not Modified" responses. If the browser can avoid re-downloading cached JavaScript files, images, text files, etc. then it will.
________________________________________
Hard reload
Don't use anything in the cache when making the request. (which is equal to SHIFT+F5 No need to open Developer console) Force the browser do re-download every JavaScript file, image, text file, etc.


Hard reload / Force Refresh
Control + Shift + R or Control + F5 or Shift + F5 = ignoring cached content
Obviously if the cache is empty then it will have to do a hard reload in order to load the required/support files again. This will again force the browser to re-download everything. However, if the page makes any after the fact downloads via JavaScript that weren’t part of page load, then these might still use the cache, which is where emptying the cache helps because it makes sure that even these won’t use cached files.
RESHARPER:

Ctrl + T

-

Step over code to skip functions
When you are on a line of code that is a function or method call, you can press F10(Debug > Step Over) instead of F11.


Advance the debugger out of the current function
Sometimes, you might want to continue your debugging session but advance the debugger all the way through the current function.
Press Shift + F11 (or Debug > Step Out).
This command resumes app execution (and advances the debugger) until the current function returns.
-
F10 vs F11
https://stackoverflow.com/questions/15584132/what-is-the-difference-between-f10-and-f11-keys-in-visual-studio/39843982
F10 ("step over") does not descend any further into the call stack. It moves to the next line of the current function.
F11 ("step into") drills down into the function being called.
void function1()
{
    function2();
    function3();
}
If you hit a breakpoint on function2(), F10 will advance to the line function3(). F11 will advance to the first line inside function2.
-

CHROME
CTRL + SHIFT + C --> konsolu açmadan (ters tıklayıp incele demeden) mause'un üstünde olduğu elementi seçiyor. Muhteşem.

RESHARPER
alt FL   SAVE

ALT WL    QUIT ALL

ctrl D	  copy paste

ctrl tab   açık dosyalar arası geçiş 
ismin adının üstüne gelip F2 -> ismi değiştirmek için (projenin tümünde her yerde değiştirmek için)

ctrl shift r  bir class'ı yeni bir folder'a taşı

ctrl W kopyalıyor bi üst element/metoda kadar. (geri almak için: ctrl shift W)

alt aşağı / yukarı   metodlar arası geçiş

ctrl B  class definition'una gitme (ctrl click ile aynı)


windows+ sağ yön tuşu (visual studio’yu ekranın sağına yapıştırıyor. Google chrome’u açıp sola bas, onu da sola yapıştır.

f3    search yapılan text'i ara (diğer satırlarda)

ctrl alt J     kelimeyi <tag> ile çevreleme

ctrl f12    sayfa içinde text ara

ctrl shift R   model'imizi farklı bir klasöre taşımak istiyorsak. (namespace'i de değiştiriyor, kolaylık sağlıyor)

windows + sağ sol yukarı yön tuşları: progrmı büyütme yana yatırma 

ctrl tab   sekmeler arası geçiş

ctrl r     kullanma. F5 ile aynı. Eğer tam refresh yapmak istiyorsan ctrl shift f5 yap.

alt enter (en alttaki seçenekten: sayfadaki aynı textlerin tümünü değiştirme)
-
ctrl f10 - cursor'ın olduğu yere kadar projeyi çalıştırır. Break point koymuşsun gibi.

-
-
-
-
-
Bildirim için aşağıdaki yapıyı kullandık.
 
Bildirim için inheritance da kullanılabilirdi. Ama mantıklı olmazdı. O yüzden yukarıdaki gibi yaptık. Aşağıdaki gibi YAPMADIK.
Mosh hamedani: Her halta inheritance uygulama. İnheritance şu durumlarda kullanılır: polimorfizm gerekiyorsa, ortada "behavior" varsa. Bunlar yoksa inheritance falan uygulama. Çünkü gereksiz olur. Boşuna complexity artırırsın. Kodun zorlaşır.
-
-
-
-
Integral to integral conversions
Integral conversions are implicit when the destination type can represent every possible
value of the source type. Otherwise, an explicit conversion is required. For
example:
int x = 12345; // int is a 32-bit integral
long y = x; // Implicit conversion to 64-bit integral
short z = (short)x; // Explicit conversion to 16-bit integral
A float can be implicitly converted to a double, since a double can represent every
possible value of a float. The reverse conversion must be explicit.
-
-
(okundu - github)
Remember, that an if can have zero or more else if's and they must come before the last else, which is optional.
Once an else if succeeds, none of the remaining else if's or else clause will be tested.
-
A do-while loop is similar to a while loop, except that a do-while loop is guaranteed to execute at least one time.
-
-
-
-
-

(okundu – github)
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Delete(int id)
{
    try
    {
        Student student = db.Students.Find(id);
        db.Students.Remove(student);
        db.SaveChanges();
    }
    catch (DataException/* dex */)
    {
        //Log the error (uncomment dex variable name and add a line here to write a log.
        return RedirectToAction("Delete", new { id = id, saveChangesError = true });
    }
    return RedirectToAction("Index");
}
This code retrieves the selected entity, then calls the Remove method to set the entity's status to Deleted. When SaveChanges is called, a SQL DELETE command is generated. You have also changed the action method name from DeleteConfirmed to Delete. The scaffolded code named the HttpPost Delete method DeleteConfirmed to give the HttpPost method a unique signature. (The CLR requires overloaded methods to have different method parameters.) Now that the signatures are unique, you can stick with the MVC convention and use the same name for the HttpPost and HttpGet delete methods.
If improving performance in a high-volume application is a priority, you could avoid an unnecessary SQL query to retrieve the row by replacing the lines of code that call the Find and Remove methods with the following code:
C#Copy
Student studentToDelete = new Student() { ID = id };
db.Entry(studentToDelete).State = EntityState.Deleted;
This code instantiates a Student entity using only the primary key value and then sets the entity state to Deleted. That's all that the Entity Framework needs in order to delete the entity.
-
-
-
Performance considerations
In general, a web page shouldn't be loading an arbitrary number of rows. A query should use paging or a limiting approach. For example, the preceding query could use Take to limit the rows returned:
C#Kopyala
public class IndexModel : PageModel
{
    private readonly SchoolContext _context;
    private readonly MvcOptions _mvcOptions;

    public IndexModel(SchoolContext context, IOptions<MvcOptions> mvcOptions)
    {
        _context = context;
        _mvcOptions = mvcOptions.Value;
    }

    public IList<Student> Student { get;set; }

    public async Task OnGetAsync()
    {
        Student = await _context.Students.Take(
            _mvcOptions.MaxModelBindingCollectionSize).ToListAsync();
    }
}
Enumerating a large table in a view could return a partially constructed HTTP 200 response if a database exception occurs part way through the enumeration.
MaxModelBindingCollectionSize defaults to 1024. The following code sets MaxModelBindingCollectionSize:
C#Kopyala
public void ConfigureServices(IServiceCollection services)
{
    int MyMaxModelBindingCollectionSize = 100;
    Int32.TryParse(Configuration["MyMaxModelBindingCollectionSize"],
                               out MyMaxModelBindingCollectionSize);
    
    services.Configure<MvcOptions>(options => 
           options.MaxModelBindingCollectionSize = MyMaxModelBindingCollectionSize);

    services.AddRazorPages();

    services.AddDbContext<SchoolContext>(options =>
          options.UseSqlServer(Configuration.GetConnectionString("SchoolContext")));

    services.AddDatabaseDeveloperPageExceptionFilter();
}

-
-
-
<span asp-validation-for="Venue" class="text-danger"></span>
property'ler için validation kullanmazsan, class tarafında; property'leri required olarak işaretlemen bir işe yaramaz. Örneğin class'ımız şuydu:
public class ConcertFormViewModel
   {
       // property'leri string olarak oluşturduğumuza dikkat:
 
       [Required]
       public string Venue { get; set; }
       
       [Required]
       public string Date { get; set; }
       
       [Required]
       public string Time { get; set; }
       
       [Required]
       public byte Genre { get; set; }
       
       public IEnumerable<Genre> Genres { get; set; } // db'deki tüm Genre'leri dropdownlist'e eklemek için kullanacağımız property
 
       public DateTime GetDateTime()
       {
           return DateTime.Parse(string.Format("{0} {1}", Date, Time));
       }
   }


Bu required attribute'lerini kullanmak client side validation'lar için yeterli değil. View'da; gereken işlem yapılmalı ki validasyon çalışsın.. Yani şunu yazmamız lazım her property için:
<span asp-validation-for="Venue" class="text-danger"></span>

Örnek olarak; venue'nin validasyon yapan html helper'ini silmiş olalım view'dan. Bu durumda client side validation, aşağıdaki resimdeki gibi olacaktır:
 
Görüldüğü üzere venue boş bırakıldığı halde "The venue field is required" gibi bir uyarı verilmedi.
Son
-
-
Abstract data type 	(GITHUB) (örnek)
Abstract data type nedir
Abstract Data type (ADT) is a type (or class) for objects whose behaviour is defined by a set of value and a set of operations.
The definition of ADT only mentions what operations are to be performed but not how these operations will be implemented. It does not specify how data will be organized in memory and what algorithms will be used for implementing the operations. It is called “abstract” because it gives an implementation-independent view. The process of providing only the essentials and hiding the details is known as abstraction.
 
The user of data type does not need to know how that data type is implemented, for example, we have been using Primitive values like int, float, char data types only with the knowledge that these data type can operate and be performed on without any idea of how they are implemented. So a user only needs to know what a data type can do, but not how it will be implemented. Think of ADT as a black box which hides the inner structure and design of the data type. Now we’ll define three ADTs namely List ADT, Stack ADT, Queue ADT.

1.	List ADT
•	The data is generally stored in key sequence in a list which has a head structure consisting of count, pointers and address of compare function needed to compare the data in the list.
 
The data node contains the pointer to a data structure and a self-referential pointer which points to the next node in the list.

//List ADT Type Definitions 
typedef struct node 
{ 
 void *DataPtr; 
 struct node *link; 
} Node; 
typedef struct
{ 
 int count; 
 Node *pos; 
 Node *head; 
 Node *rear; 
 int (*compare) (void *argument1, void *argument2) 
} LIST;  
•	The List ADT Functions is given below:
 
A list contains elements of the same type arranged in sequential order and following operations can be performed on the list.
•	get() – Return an element from the list at any given position.
•	insert() – Insert an element at any position of the list.
•	remove() – Remove the first occurrence of any element from a non-empty list.
•	removeAt() – Remove the element at a specified location from a non-empty list.
•	replace() – Replace an element at any position by another element.
•	size() – Return the number of elements in the list.
•	isEmpty() – Return true if the list is empty, otherwise return false.
•	isFull() – Return true if the list is full, otherwise return false.

2.	Stack ADT

•	In Stack ADT Implementation instead of data being stored in each node, the pointer to data is stored.
•	The program allocates memory for the data and address is passed to the stack ADT.
 
•	The head node and the data nodes are encapsulated in the ADT. The calling function can only see the pointer to the stack.
•	The stack head structure also contains a pointer to top and count of number of entries currently in stack.

A Stack contains elements of the same type arranged in sequential order. All operations take place at a single end that is top of the stack and following operations can be performed:
•	push() – Insert an element at one end of the stack called top.
•	pop() – Remove and return the element at the top of the stack, if it is not empty.
•	peek() – Return the element at the top of the stack without removing it, if the stack is not empty. (peak  yani tepe kelimesinden akla getirilebilir)
•	size() – Return the number of elements in the stack.
•	isEmpty() – Return true if the stack is empty, otherwise return false.
•	isFull() – Return true if the stack is full, otherwise return false.

// C# code to illustrate the 
// Stack.Peek Method 
using System; 
using System.Collections; 
  
class GFG { 
  
    // Driver code 
    public static void Main() 
    { 
  
        // Creating a Stack 
        Stack myStack = new Stack(); 
  
        // Inserting the elements into the Stack 
        myStack.Push("1st Element"); 
        myStack.Push("2nd Element"); 
        myStack.Push("3rd Element"); 
        myStack.Push("4th Element"); 
        myStack.Push("5th Element"); 
        myStack.Push("6th Element"); 
  
        // Displaying the count of elements 
        // contained in the Stack 
        Console.Write("Total number of elements"+ 
                         " in the Stack are : "); 
  
        Console.WriteLine(myStack.Count); 
  
        // Displaying the top element of Stack 
        // without removing it from the Stack 
        Console.WriteLine("Element at the top is : " 
                                  + myStack.Peek()); 
  
        // Displaying the top element of Stack 
        // without removing it from the Stack 
        Console.WriteLine("Element at the top is : " 
                                + myStack.Peek()); 
  
        // Displaying the count of elements 
        // contained in the Stack 
        Console.Write("Total number of elements "+ 
                           "in the Stack are : "); 
  
        Console.WriteLine(myStack.Count); 
    } 
-
-
-




3.	Queue ADT
•	The queue abstract data type (ADT) follows the basic design of the stack abstract data type.
 
•	Each node contains a void pointer to the data and the link pointer to the next element in the queue. The program’s responsibility is to allocate memory for storing the data.


//Queue ADT Type Definitions 
typedef struct node 
{ 
 void *DataPtr; 
 struct node *next; 
} QueueNode; 
typedef struct 
{ 
 QueueNode *front; 
 QueueNode *rear; 
 int count; 
} QUEUE; 

A Queue contains elements of the same type arranged in sequential order. Operations take place at both ends, insertion is done at the end and deletion is done at the front. Following operations can be performed:
•	enqueue() – Insert an element at the end of the queue.
•	dequeue() – Remove and return the first element of the queue, if the queue is not empty.
•	peek() – Return the element of the queue without removing it, if the queue is not empty.
•	size() – Return the number of elements in the queue.
•	isEmpty() – Return true if the queue is empty, otherwise return false.
•	isFull() – Return true if the queue is full, otherwise return false.
From these definitions, we can clearly see that the definitions do not specify how these ADTs will be represented and how the operations will be carried out. There can be different ways to implement an ADT, for example, the List ADT can be implemented using arrays, or singly linked list or doubly linked list. Similarly, stack ADT and Queue ADT can be implemented using arrays or linked lists.
Reference: https://en.wikipedia.org/wiki/Abstract_data_type
This article is contributed by Anuj Chauhan. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.
Don’t stop now and take your learning to the next level. Learn all the important concepts of Data Structures and Algorithms with the help of the most trusted course: DSA Self Paced. Become industry ready at a student-friendly price.
-
-
-
-
-
In Controllers\StudentController.cs, the action method for the Details view uses the Find method to retrieve a single Student entity. 
public ActionResult Details(int? id) 
{ 
if (id == null) 
{ 
return new HttpStatusCodeResult(HttpStatusCode.BadRequest); 
} 
Student student = db.Students.Find(id); 
if (student == null) 
{ 
return HttpNotFound(); 
} 
return View(student); 
}
-
-
-
-
Action Filter, Filter MSDN
Action filter nedir
Action filter dediğimiz aslında action metotların çalışma öncesi ve sonrasına hayat veren özel attribute sınıflarıdır.
Action filter executes before and after an action method executes. Action filter attributes can be applied to an individual action method or to a controller. When action filter applied to controller then it will be applied to all the action methods in that controller.
OutputCache is a built-in action filter attribute that can be apply to an action method for which we want to cache the output. For example, output of the following action method will be cached for 100 seconds.
Example: ActionFilter

[OutputCache(Duration=100)]
public ActionResult Index()
{
    return View();
}
-
-
Filters in ASP.NET Core allow code to be run before or after specific stages in the request processing pipeline.
Built-in filters handle tasks such as:
•	Authorization (preventing access to resources a user isn't authorized for).
•	Response caching (short-circuiting the request pipeline to return a cached response).
Custom filters can be created to handle cross-cutting concerns. Examples of cross-cutting concerns include error handling, caching, configuration, authorization, and logging. Filters avoid duplicating code. For example, an error handling exception filter could consolidate error handling.
This document applies to Razor Pages, API controllers, and controllers with views. Filters don't work directly with Razor components. A filter can only indirectly affect a component when:
•	The component is embedded in a page or view.
•	The page or controller/view uses the filter.
View or download sample (how to download).

How filters work
Filters run within the ASP.NET Core action invocation pipeline, sometimes referred to as the filter pipeline. The filter pipeline runs after ASP.NET Core selects the action to execute.
 
Filter types
Each filter type is executed at a different stage in the filter pipeline:
•	Authorization filters run first and are used to determine whether the user is authorized for the request. Authorization filters short-circuit the pipeline if the request is not authorized.
•	Resource filters:
o	Run after authorization.
o	OnResourceExecuting runs code before the rest of the filter pipeline. For example, OnResourceExecuting runs code before model binding.
o	OnResourceExecuted runs code after the rest of the pipeline has completed.
•	Action filters:
o	Run code immediately before and after an action method is called.
o	Can change the arguments passed into an action.
o	Can change the result returned from the action.
o	Are not supported in Razor Pages.
•	Exception filters apply global policies to unhandled exceptions that occur before the response body has been written to.
•	Result filters run code immediately before and after the execution of action results. They run only when the action method has executed successfully. They are useful for logic that must surround view or formatter execution.

The following diagram shows how filter types interact in the filter pipeline.
 
Implementation
Filters support both synchronous and asynchronous implementations through different interface definitions.
Synchronous filters run code before and after their pipeline stage. For example, OnActionExecuting is called before the action method is called. OnActionExecuted is called after the action method returns.
C#Copy
public class MySampleActionFilter : IActionFilter 
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        // Do something before the action executes.
        MyDebug.Write(MethodBase.GetCurrentMethod(), context.HttpContext.Request.Path);
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        // Do something after the action executes.
        MyDebug.Write(MethodBase.GetCurrentMethod(), context.HttpContext.Request.Path);
    }
}
In the preceding code, MyDebug is a utility function in the sample download.
Asynchronous filters define an On-Stage-ExecutionAsync method. For example, OnActionExecutionAsync:
C#Copy
public class SampleAsyncActionFilter : IAsyncActionFilter
{
    public async Task OnActionExecutionAsync(
        ActionExecutingContext context,
        ActionExecutionDelegate next)
    {
        // Do something before the action executes.

        // next() calls the action method.
        var resultContext = await next();
        // resultContext.Result is set.
        // Do something after the action executes.
    }
}
In the preceding code, the SampleAsyncActionFilter has an ActionExecutionDelegate (next) that executes the action method.

Multiple filter stages
Interfaces for multiple filter stages can be implemented in a single class. For example, the ActionFilterAttribute class implements:
•	Synchronous: IActionFilter and IResultFilter
•	Asynchronous: IAsyncActionFilter and IAsyncResultFilter
•	IOrderedFilter
Implement either the synchronous or the async version of a filter interface, not both. The runtime checks first to see if the filter implements the async interface, and if so, it calls that. If not, it calls the synchronous interface's method(s). If both asynchronous and synchronous interfaces are implemented in one class, only the async method is called. When using abstract classes like ActionFilterAttribute, override only the synchronous methods or the asynchronous methods for each filter type.
Built-in filter attributes
ASP.NET Core includes built-in attribute-based filters that can be subclassed and customized. For example, the following result filter adds a header to the response:
C#Copy
public class AddHeaderAttribute : ResultFilterAttribute
{
    private readonly string _name;
    private readonly string _value;

    public AddHeaderAttribute(string name, string value)
    {
        _name = name;
        _value = value;
    }

    public override void OnResultExecuting(ResultExecutingContext context)
    {
        context.HttpContext.Response.Headers.Add( _name, new string[] { _value });
        base.OnResultExecuting(context);
    }
}
Attributes allow filters to accept arguments, as shown in the preceding example. Apply the AddHeaderAttribute to a controller or action method and specify the name and value of the HTTP header:
C#Copy
[AddHeader("Author", "Rick Anderson")]
public class SampleController : Controller
{
    public IActionResult Index()
    {
        return Content("Examine the headers using the F12 developer tools.");
    }
Use a tool such as the browser developer tools to examine the headers. Under Response Headers, author: Rick Anderson is displayed.
The following code implements an ActionFilterAttribute that:
•	Reads the title and name from the configuration system. Unlike the previous sample, the following code doesn't require filter parameters to be added to the code.
•	Adds the title and name to the response header.
C#Copy
public class MyActionFilterAttribute : ActionFilterAttribute
{
    private readonly PositionOptions _settings;

    public MyActionFilterAttribute(IOptions<PositionOptions> options)
    {
        _settings = options.Value;
        Order = 1;
    }

    public override void OnResultExecuting(ResultExecutingContext context)
    {
        context.HttpContext.Response.Headers.Add(_settings.Title, 
                                                 new string[] { _settings.Name });
        base.OnResultExecuting(context);
    }
}
The configuration options are provided from the configuration system using the options pattern. For example, from the appsettings.json file:
JSONCopy
{
  "Position": {
    "Title": "Editor",
    "Name": "Joe Smith"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}
In the StartUp.ConfigureServices:
•	The PositionOptions class is added to the service container with the "Position" configuration area.
•	The MyActionFilterAttribute is added to the service container.
C#Copy
public void ConfigureServices(IServiceCollection services)
{
    services.Configure<PositionOptions>(
             Configuration.GetSection("Position"));
    services.AddScoped<MyActionFilterAttribute>();

    services.AddControllersWithViews();
}
The following code shows the PositionOptions class:
C#Copy
public class PositionOptions
{
    public string Title { get; set; }
    public string Name { get; set; }
}
The following code applies the MyActionFilterAttribute to the Index2 method:
C#Copy
[AddHeader("Author", "Rick Anderson")]
public class SampleController : Controller
{
    public IActionResult Index()
    {
        return Content("Examine the headers using the F12 developer tools.");
    }

    [ServiceFilter(typeof(MyActionFilterAttribute))]
    public IActionResult Index2()
    {
        return Content("Header values by configuration.");
    }

Under Response Headers, author: Rick Anderson, and Editor: Joe Smith is displayed when the Sample/Index2 endpoint is called.
The following code applies the MyActionFilterAttribute and the AddHeaderAttribute to the Razor Page:
C#Copy
[AddHeader("Author", "Rick Anderson")]
[ServiceFilter(typeof(MyActionFilterAttribute))]
public class IndexModel : PageModel
{
    public void OnGet()
    {
    }
}
Filters cannot be applied to Razor Page handler methods. They can be applied either to the Razor Page model or globally.
Several of the filter interfaces have corresponding attributes that can be used as base classes for custom implementations.
Filter attributes:
•	ActionFilterAttribute
•	ExceptionFilterAttribute
•	ResultFilterAttribute
•	FormatFilterAttribute
•	ServiceFilterAttribute
•	TypeFilterAttribute
Filter scopes and order 
Action filters
Action filters do not apply to Razor Pages. Razor Pages supports IPageFilter and IAsyncPageFilter . For more information, see Filter methods for Razor Pages.
Action filters:
•	Implement either the IActionFilter or IAsyncActionFilter interface.
•	Their execution surrounds the execution of action methods.
The following code shows a sample action filter:
C#Copy
public class MySampleActionFilter : IActionFilter 
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        // Do something before the action executes.
        MyDebug.Write(MethodBase.GetCurrentMethod(), context.HttpContext.Request.Path);
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        // Do something after the action executes.
        MyDebug.Write(MethodBase.GetCurrentMethod(), context.HttpContext.Request.Path);
    }
}
The ActionExecutingContext provides the following properties:
•	ActionArguments - enables reading the inputs to an action method.
•	Controller - enables manipulating the controller instance.
•	Result - setting Result short-circuits execution of the action method and subsequent action filters.
Throwing an exception in an action method:
•	Prevents running of subsequent filters.
•	Unlike setting Result, is treated as a failure instead of a successful result.
The ActionExecutedContext provides Controller and Result plus the following properties:
•	Canceled - True if the action execution was short-circuited by another filter.
•	Exception - Non-null if the action or a previously run action filter threw an exception. Setting this property to null:
o	Effectively handles the exception.
o	Result is executed as if it was returned from the action method.
For an IAsyncActionFilter, a call to the ActionExecutionDelegate:
•	Executes any subsequent action filters and the action method.
•	Returns ActionExecutedContext.
To short-circuit, assign Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext.Result to a result instance and don't call next (the ActionExecutionDelegate).

The framework provides an abstract ActionFilterAttribute that can be subclassed.
The OnActionExecuting action filter can be used to:
•	Validate model state.
•	Return an error if the state is invalid.
C#Copy
public class ValidateModelAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext 
                                           context)
    {
        if (!context.ModelState.IsValid)
        {
            context.Result = new BadRequestObjectResult(
                                                context.ModelState);
        }
    }
 Note
Controllers annotated with the [ApiController] attribute automatically validate model state and return a 400 response. For more information, see Automatic HTTP 400 responses.
The OnActionExecuted method runs after the action method:
•	And can see and manipulate the results of the action through the Result property.
•	Canceled is set to true if the action execution was short-circuited by another filter.
•	Exception is set to a non-null value if the action or a subsequent action filter threw an exception. Setting Exception to null:
o	Effectively handles an exception.
o	ActionExecutedContext.Result is executed as if it were returned normally from the action method.
C#Copy
public class ValidateModelAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext 
                                           context)
    {
        if (!context.ModelState.IsValid)
        {
            context.Result = new BadRequestObjectResult(
                                                context.ModelState);
        }
    }


    public override void OnActionExecuted(ActionExecutedContext 
                                          context)
    {
        var result = context.Result;
        // Do something with Result.
        if (context.Canceled == true)
        {
            // Action execution was short-circuited by another filter.
        }

        if(context.Exception != null)
        {
            // Exception thrown by action or action filter.
            // Set to null to handle the exception.
            context.Exception = null;
        }
        base.OnActionExecuted(context);
    }
}
-
-
-
-
-
Association, aggregation, and composition in OOP explained
How to use association, aggregation, and composition to define relationships between the objects in your application
•	 
 
•	 
 
•	 
 
•	 
 
•	 
 
•	 
 
The Unified Modeling Language (UML) is a de-facto standard for modeling object-oriented systems. In UML there are five different types of relationships: association, aggregation, composition, dependency, and inheritance. This article presents a discussion of the first three of these concepts, leaving the remaining ones to another blog post.
[ .Net roadmap: The new features you can expect in .Net Standard 2.1. | .Net Framework or .Net Core? Learn when to use which. | Keep up with hot topics in programming with InfoWorld’s App Dev Report newsletter. ]
Association in object oriented programming
Association is a semantically weak relationship (a semantic dependency) between otherwise unrelated objects. An association is a “using” relationship between two or more objects in which the objects have their own lifetime and there is no owner.
As an example, imagine the relationship between a doctor and a patient. A doctor can be associated with multiple patients. At the same time, one patient can visit multiple doctors for treatment or consultation. Each of these objects has its own life cycle and there is no “owner” or parent. The objects that are part of the association relationship can be created and destroyed independently.
In UML an association relationship is represented by a single arrow. An association relationship can be represented as one-to-one, one-to-many, or many-to-many (also known as cardinality). Essentially, an association relationship between two or more objects denotes a path of communication (also called a link) between them so that one object can send a message to another. The following code snippet illustrates how two classes, IDGBlogAccount and IDGBlogEntry, are associated with one another.
public class IDGBlogAccount
   {
       private IDGBlogEntry[] blogEntries;
       //Other members of the IDGBlogAccount class
   }
public class IDGBlogEntry
   {
       Int32 blogId;
       string caption;
       string text;
       //Other members of the IDGBlogEntry class
   }
-

Aggregation in object oriented programming
Aggregation is a specialized form of association between two or more objects in which each object has its own life cycle but there exists an ownership as well. Aggregation is a typical whole/part or parent/child relationship but it may or may not denote physical containment. An essential property of an aggregation relationship is that the whole or parent (i.e. the owner) can exist without the part or child and vice versa.  
As an example, an employee may belong to one or more departments in an organization. However, if an employee’s department is deleted, the employee object would not be destroyed but would live on. Note that the relationships between objects participating in an aggregation cannot be reciprocal—i.e., a department may “own” an employee, but the employee does not own the department. In the following code example, an aggregation relationship is evident between the IDGBlogAuthor and IDGBlogAccount classes.
public class IDGBlogAuthor
   {
       private Int32 authorId;
       private string firstName;
       private string lastName;
       //Other members of the IDGBlogAuthor class
   }
public class IDGBlogAccount
   {
       private IDGBlogEntry[] blogEntries;
       //Other members of the IDGBlogAccount class
   }
Aggregation is usually represented in UML using a line with a hollow diamond. Like association, aggregation can involve a one-to-one, one-to-many, or many-to-many relationship between the participating objects. In the case of a one-to-many or many-to-many relationship, we may say that it is a redundant relationship.
-
Composition in object oriented programming
Composition is a specialized form of aggregation. In composition, if the parent object is destroyed, then the child objects also cease to exist. Composition is actually a strong type of aggregation and is sometimes referred to as a “death” relationship. As an example, a house may be composed of one or more rooms. If the house is destroyed, then all of the rooms that are part of the house are also destroyed. The following code snippet illustrates a composition relationship between two classes, House and Room.
public class House
{
   private Room room;
   public House()
   {
       room = new Room();
   }
}
Like aggregation, composition is also a whole/part or parent/child relationship. However, in composition the life cycle of the part or child is controlled by the whole or parent that owns it. It should be noted that this control can either be direct or transitive. That is, the parent may be directly responsible for the creation or destruction of the child or the parent may use a child that has been already created. Similarly, a parent object might delegate the control to some other parent to destroy the child object. Composition is represented in UML using a line connecting the objects with a solid diamond at the end of the object that owns the other object.
I hope this discussion of association, aggregation, and composition relationships has helped you understand how these three concepts differ. Remember that aggregation and composition are both subsets of association. In both aggregation and composition, an object of one class can be the owner of an object of another class. And in both aggregation and composition, the child objects belong to a single parent object, i.e., they may have only one owner.
Finally, in an aggregation relationship, the life cycles of parent objects and child objects are independent. In a composition relationship, the death of a parent object also means the death of its children.
-
-
-
-
-
-
Assigning			      (GITHUB)  (test)
Assign nedir, assigning nedir
Assigning is simply the storing of one value to a variable.  x = 5 assigns the value 5 to the variable  x.
(assign kelime anlamı: allocate (a job or duty) / to give a particular job or piece of work to someone: “The case has been assigned to our most senior officer.”)
x = 5 assigns the value 5 to the variable  x. In some languages, assignment cannot be combined with declaration, but in C# it can be: int x = 5;
Note that the statement object myObject = new object(); combines all four of these.
new object() instantiates a new object object, returning a reference to it.
object myObject declares a new object reference.
= initializes the reference variable by assigning the value of the reference to it.
-
-
-
-
-
Authentication and authorization might sound similar, but they are distinct security processes in the world of identity and access management (IAM).
Authentication confirms that users are who they say they are. Authorization gives those users permission to access a resource.
What Is Authentication?
Authentication is the act of validating that users are whom they claim to be. This is the first step in any security process. 
Complete an authentication process through:
•	Passwords. Usernames and passwords are the most common authentication factors. If a user enters the correct data, the system assumes the identity is valid and grants access.
•	One-time pins. Grant access for only one session or transaction.
•	Authentication apps. Generate security codes via an outside party that grants access.
•	Biometrics. A user presents a fingerprint or eye scan to gain access to the system. 
In some instances, systems require the successful verification of more than one factor before granting access. This multi-factor authentication (MFA) requirement is often deployed to increase security beyond what passwords alone can provide.

What Is Authorization?
Authorization in a system security is the process of giving the user permission to access a specific resource or function. This term is often used interchangeably with access control or client privilege. 
Giving someone permission to download a particular file on a server or providing individual users with administrative access to an application are good examples of authentication. 
In secure environments, authorization must always follow authentication. Users should first prove that their identities are genuine before an organization’s administrators grant them access to the requested resources.
-
-
-
-
-


-
Instance ve obje arasındaki fark! Instance nedir, object nedir
-
-
The Instance and Object are from Object Oriented Programming.
For some programming languages like Java, C++, and Smalltalk, it is important to describe and understand code. In other languages that used in Structured Programming, this concept doesn't exist.
This is a view from Structural Programming. There's no real significant difference that should consume too much of your time. There might be some fancy language that some people might take up a lot of spaces to write about, but at the end of the day, as far as a coder, developer, programmer, architect, is concerned, an instance of a class and an object mean the same thing and can often be used interchangeably. I have never met anyone in my career that would be picky and spend a half-hour trying to point out the differences because there's really none. Time can be better spent on other development efforts.
UPDATE With regards to Swift, this is what Apple who invented Swift prefers :
An instance of a class is traditionally known as an object. However, Swift classes and structures are much closer in functionality than in other languages, and much of this chapter describes functionality that can apply to instances of either a class or a structure type. Because of this, the more general term instance is used.
-
SQL alıştırma siteleri:

https://sqlbolt.com/lesson/select_queries_with_constraints

https://www.hackerrank.com/challenges/revising-the-select-query/problem
-
-
-
Properties expose fields. Fields should (almost always) be kept private to a class and accessed via get and set properties. 
Properties provide a level of abstraction allowing you to change the fields while not affecting the external way they are accessed by the things that use your class.

public class MyClass
{

    // this is a field.  It is private to your class and stores the actual data.
    private string _myField;

    // this is a property. When accessed it uses the underlying field,
    // but only exposes the contract, which will not be affected by the underlying field
    public string MyProperty
    {
        get
        {
            return _myField;
        }
        set
        {
            _myField = value;
        }
    }

    // This is an AutoProperty (C# 3.0 and higher) - which is a shorthand syntax
    // used to generate a private field for you
    public int AnotherProperty{get;set;} 
}
-
Constant (GITHUB)
[constant nedir, constants nedir, const nedir]

MSDN:
You use the const keyword to declare a constant field or a constant local. Constant fields and locals aren't variables and may not be modified. Constants can be numbers, Boolean values, strings, or a null reference. Don’t create a constant to represent information that you expect to change at any time. For example, don’t use a constant field to store the price of a service, a product version number, or the brand name of a company. These values can change over time, and because compilers propagate constants, other code compiled with your libraries will have to be recompiled to see the changes. See also the readonly keyword. For example:
const int X = 0;
public const double GravitationalConstant = 6.673e-11;
private const string ProductName = "Visual C#";
-
-
-
-
-
-
Constant (GITHUB)
[constant nedir, constants nedir, const nedir]
MSDN:
You use the const keyword to declare a constant field or a constant local. Constant fields and locals aren't variables and may not be modified. Constants can be numbers, Boolean values, strings, or a null reference. Don’t create a constant to represent information that you expect to change at any time. For example, don’t use a constant field to store the price of a service, a product version number, or the brand name of a company. These values can change over time, and because compilers propagate constants, other code compiled with your libraries will have to be recompiled to see the changes. See also the readonly keyword. For example:
const int X = 0;
public const double GravitationalConstant = 6.673e-11;
private const string ProductName = "Visual C#";

Remarks
The type of a constant declaration specifies the type of the members that the declaration introduces. The initializer of a constant local or a constant field must be a constant expression that can be implicitly converted to the target type.
A constant expression is an expression that can be fully evaluated at compile time. Therefore, the only possible values for constants of reference types are string and a null reference.
The constant declaration can declare multiple constants, such as:
C#Copy
public const double X = 1.0, Y = 2.0, Z = 3.0;
The static modifier is not allowed in a constant declaration.
A constant can participate in a constant expression, as follows:
C#Copy
public const int C1 = 5;
public const int C2 = C1 + 100;
 Note
The readonly keyword differs from the const keyword. A const field can only be initialized at the declaration of the field. A readonly field can be initialized either at the declaration or in a constructor. Therefore, readonly fields can have different values depending on the constructor used. Also, although a const field is a compile-time constant, the readonly field can be used for run-time constants, as in this line: public static readonly uint l1 = (uint)DateTime.Now.Ticks;

Example
C#Copy
public class ConstTest
{
    class SampleClass
    {
        public int x;
        public int y;
        public const int C1 = 5;
        public const int C2 = C1 + 5;

        public SampleClass(int p1, int p2)
        {
            x = p1;
            y = p2;
        }
    }

    static void Main()
    {
        var mC = new SampleClass(11, 22);
        Console.WriteLine($"x = {mC.x}, y = {mC.y}");
        Console.WriteLine($"C1 = {SampleClass.C1}, C2 = {SampleClass.C2}");
    }
}

/* Output
    x = 11, y = 22
    C1 = 5, C2 = 10
*/
Example
This example demonstrates how to use constants as local variables.
C#Copy
public class SealedTest
{
    static void Main()
    {
        const int C = 707;
        Console.WriteLine($"My local constant = {C}");
    }
}
// Output: My local constant = 707
-
-
-
Constants store a value that cannot be changed from their initial assignment.
To declare a constant, use the const modifier.
For example:
const double PI = 3.14; 

The value of const PI cannot be changed during program execution.
- 
Constants store a value that cannot be changed from their initial assignment.
To declare a constant, use the const modifier. For example: 
const double PI = 3.14;
PI = 8; //error
(Constants must be initialized with a value when declared.)
-
Difference between readonly and const keyword in C#  	 (GITHUB)
const nedir, readonly nedir  
In C#, a const keyword is used to declare constant fields and constant local. The value of the constant field is the same throughout the program or in other words, once the constant field is assigned the value of this field is not be changed. In C#, constant fields and locals are not variables, a constant is a number, string, null reference, boolean values.

Example:
// C# program to illustrate the 
// use of const keyword 
using System; 
  
class GFG { 
  
    // Constant fields 
    public const int myvar = 10; 
    public const string str = "GeeksforGeeks"; 
  
    // Main method 
    static public void Main() 
    { 
  
        // Display the value of Constant fields 
        Console.WriteLine("The value of myvar: {0}", myvar); 
        Console.WriteLine("The value of str: {0}", str); 
    } <} 
Output:

The value of myvar: 10
The value of str: GeeksforGeeks
In C#, you can use a readonly keyword to declare a readonly variable. This readonly keyword shows that you can assign the variable only when you declare a variable or in a constructor of the same class in which it is declared.

// C# program to illustrate the use  
// of the readonly keyword 
using System; 
  
class GFG { 
  
    // readonly variables 
    public readonly int myvar1; 
    public readonly int myvar2; 
  
    // Values of the readonly  
    // variables are assigned 
    // Using constructor 
    public GFG(int b, int c) 
    { 
  
        myvar1 = b; 
        myvar2 = c; 
        Console.WriteLine("Display value of myvar1 {0}, "+ 
                        "and myvar2 {1}", myvar1, myvar2); 
    } 
  
    // Main method 
    static public void Main() 
    { 
        GFG obj1 = new GFG(100, 200); 
    } 
} 
Output:
Display value of myvar1 100, and myvar2 200 
ReadOnly Vs Const Keyword
-
-
-
-
-
-
Constructors
Class’larda constructor’u sen belirtmesen bile, constructor’lar IMPLICIT olarak zaten yaratılırlar. Sen explicit olarak yazmasan dahi vardır yani ve sen bir obje initialize edeceğin zaman bu constructor her halükarda çalışacaktır. Sen ister yazmış ol ister yazmamış ol.
A class constructor is a special member method of a class that is executed whenever a new object of that class is created.
-
-
-
-
Data Types in C# (Reference Type, Value Type) 	      (GITHUB)  (test)
Data type nedir, data types nedir, ref type nedir, reference type nedir, value types nedir, value type nedir
Önemli: https://www.tutorialsteacher.com/csharp/csharp-data-types

The following data types are all of value type:
•	bool
•	byte
•	char
•	decimal
•	double
•	enum
•	float
•	int
•	long
•	sbyte
•	short
•	struct
•	uint
•	ulong
•	ushort
-
-
-
-
-
C# mainly categorized data types in two types: Value types and Reference types. Value types include simple types (e.g. int, float, bool, and char), enum types, struct types, and Nullable value types. 
Reference types include class types, interface types, delegate types, and array types. 
Learn about value types and reference types in detail in the next chapter.
 
Reference Types:
Reference types have null value by default, when they are not initialized.
For example, a string variable (or any other variable of reference type datatype) without a value assigned to it. In this case, it has a null value, meaning it doesn't point to any other memory location, because it has no value yet.
A value type variable cannot be null because it holds a value not a memory address. However, value type variables must be assigned some value before use. 

The compiler will give an error if you try to use a local value type variable without assigning a value to it. However, value type field in a class can be declared without initialization (field is not a local variable in the function). It will have a default value if not assigned any value, e.g., int will have 0, boolean will have false and so on.
(Field variables: Variable that are declared as a member of a class. OR Variables declared outside any method/constructor but inside the class block.
Scope: they can live as long as the instance they belong to is active.

Local variables: Variables that are declared within a method or a specific block of statements.)
-

class myClass
{
    public int i;
}

myClass mcls = new myClass();

Console.WriteLine(mcls.i); 
 
Output: 0
-

Aşağıdaki örnekte yukardaki olay açığa çıkıyor:

using System;

class Program
{
         // Hata oluşmaması için int a; ve int b; deklarasyonu burada, yani class içind yapılmalıydı!
	  // Hata oluşmasının sebebi şu: Local variable’larda initialization yapılmaz! (yani int a; -> 0’a eşitlenmez.
         // Fakat field’lar initialize edilir… yani int a; dediğimizde a değişkeni 0’a eşitlenir…
         // Kısacası, bir değişkenin (field veya local variable) otomatik olarak initialize edilmesini istiyorsan, bu değişkeni metot içinde değil, class içinde deklare etmelisin!

    static void Main()
    {
        int a;
        string b;

        Console.WriteLine(a); // Hata! Use of unassigned loal variable 'a'
        Console.WriteLine(b); // Hata! Use of unassigned loal variable 'b'

        // instance method çağırılıyor
        SampleClass sampleClass = new SampleClass();
        sampleClass.SampleMethod();

        // static method çağırılıyor
        SampleClass.SampleMethod2();
    }

    class SampleClass
    {
        int a1;
        int b1;

        static int a2;
        static int b2;

        public void SampleMethod()
        {
            Console.WriteLine(a1); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
            Console.WriteLine(b1); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
        }

        public static void SampleMethod2()
        {
            Console.WriteLine(a2); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
            Console.WriteLine(b2); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
        }
    }
}
-
Hatasız çalışan:

using System;

class Program
{
    public static int a;
    public static string b;

    static void Main()
    {
        Console.WriteLine(a); // Result: 0
        Console.WriteLine(b); // Result: ""
        Console.WriteLine("-"); 

        // instance method çağırılıyor
        SampleClass sampleClass = new SampleClass();
        sampleClass.SampleMethod();

        // static method çağırılıyor
        SampleClass.SampleMethod2();
    }

    class SampleClass
    {
        int a1;
        int b1;

        static int a2;
        static int b2;

        public void SampleMethod()
        {
            Console.WriteLine(a1); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
            Console.WriteLine(b1); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
        }

        public static void SampleMethod2()
        {
            Console.WriteLine(a2); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
            Console.WriteLine(b2); // result: 0 (otomatik olarak 0'a initialize edildiği için 0 döndü)
        }
    }
}
-
ÖNEMLİ, static metotlar sadece static field’I, property’i çağırabiliyor:


using System;

class Program
{
    static void Main()
    {
    }

    class SampleClass
    {
        int instanceField;
        static int staticField;

        public void SampleMethod()
        {
            Console.WriteLine(instanceField);
            Console.WriteLine(staticField); 
        }

        public static void SampleMethod2()
        {
            Console.WriteLine(instanceField); // Hata! Static metot, instance field'ı çağıramıyor! 
            Console.WriteLine(staticField); // Hata yok. Static method static field'ı çağırdı.
        }
    }
}

-
-
What is the difference between a field variable and a local variable?
Local Variables:

- Local variable’s scope is within the block in which they were defined.
- They are alive as long as the block is executed.
- They can not have static access modifier

Field Variables:

- The life span is more than the local variables.
- The are alive as long as the instance of that class is active.
- They can have only ‘static’ access modifier.
What is the difference between a field variable and a local variable?
Field variables: Variable that are declared as a member of a class. OR Variables declared outside any method/constructor but inside the class block.
Scope: they can live as long as the instance they belong to is active.

Local variables: Variables that are declared within a method or a specific block of statements.
Scope: Live throughout the execution of the block
-
Points to Remember :
1.	Value type stores the value in its memory space, whereas reference type stores the address of the value where it is stored.
2.	Primitive data types and struct are of the 'Value' type. Class objects, string, array, delegates are reference types.
3.	Value type passes byval by default. Reference type passes byref by default.
4.	Value types and reference types stored in Stack and Heap in the memory depends on the scope of the variable.

Reference Data Types : The Reference Data Types will contain a memory address of variable value because the reference types won’t store the variable value directly in memory. The built-in reference types are string, object.
•	String : It represents a sequence of Unicode characters and its type name is System.String. So, string and String are equivalent.
Example:
•	string s1 = "hello"; // creating through string keyword  
•	String s2 = "welcome"; // creating through String class  
•	Object : In C#, all types, predefined and user-defined, reference types and value types, inherit directly or indirectly from Object. So basically it is the base class for all the data types in C#. Before assigning values, it needs type conversion. When a variable of a value type is converted to object, it’s called boxing. When a variable of type object is converted to a value type, it’s called unboxing. Its type name is System.Object.
-
Class’lar referans tiptedirler.
Değişkenler içinde pointer value tutar.
Objeler de içinde pointer tutar. Resimleri incele 
 

        public class Book
        {
           public List<int> theList = new List<int>();
        }

        static void Main(string[] args)
        {
            Book book1 = new Book();
            book1.theList.Add(20);
            book1.theList.Add(21);

            Book book2 = book1;
            book2.theList.Add(51);

            foreach(var item in book2.theList)
            {
                Console.WriteLine(item); //sonuç: 20,21,51
                //Çünkü book2 ile yeni bir obje oluşturmadık. Ram'de aynı noktaya işaret ediyorlar. Dikkat edilirse book2 oluştururken new keyword'ü de kullanılmadı.
            }
            Console.ReadKey();
        }
-
Resimlerde görüldüğü gibi, book1 i instantiate ettik. Sonra book2 yi book1’e eşitledik. Bu durumda iki tane obje oluşturulmuş olmadı. İki tane pointer (book1 ve book2) tek bir objeye işaret ediyor oldu. Yani iki isimden de (book1,book2) tek bir objeye ulaşıyoruz, yani iki değişken ile aslında tek bir RAM lokasyonuna ulaşıyoruz. (dikkat edilirse new keyword’ü falan kullanmadık)
Zaten dikkat edilirse, book2 yi oluştururken bir initialization yapmıyoruz. New keword’ünü kullanmıyoruz. Bu bize yeni bir obje oluşturmadığımız konusunda kolayca ipucu verir.
-
-
-


Variables in C# are broadly classified into two types: Value types and Reference types. In this tutorial we will be discussing about primitive (simple) data types which is a subclass of Value types.
-
-
-
-
-
One to Many ilişki  Entity Framework ile nasıl yapılıyor. Düzgün anlatım:

One-to-Many Relationships
model
relationship
In a one-to-many relationship, each row of data in one table is linked to one or more rows in the second table. It is the most common type of relationship.
•	A one-to-many relationship happens when the primary key of one table becomes foreign keys in another table.
•	The foreign key is defined in the table that represents the many end of the relationship.
Let's say we have Author and Book entities.
public class Author
{
    public int AuthorId { get; set; }
    public string Name { get; set; }
}

public class Book
{
    public int BookId { get; set; }
    public string Title { get; set; }
}
-
-
-
-
-
Configure One-to-Many Relationship
In EF6, most of the times you don't need to configure the one-to-many relationship because one-to-many relationship conventions cover all combinations. You can establish a one-to-many relationship by using any of the following code first conventions.
Code First Conventions
Add Reference Navigation Property
Include a reference navigation property of type Author in the Book entity class.
public class Author
{
    public int AuthorId { get; set; }
    public string Name { get; set; }
}

public class Book
{
    public int BookId { get; set; }
    public string Title { get; set; }
    public Author Author { get; set; }
}
Adding an Author navigation property will create a one-to-many relationship between the Authors and Books tables in the database by adding a foreign key Author_AuthorId to Books table.
Add Collection Navigation Property
You can achieve one-to-many relationship by adding the collection navigation property of Book entity in the Author entity class.
-
public class Author
{
    public int AuthorId { get; set; }
    public string Name { get; set; }
    public virtual ICollection<Book> Books { get; set; }
}

public class Book
{
    public int BookId { get; set; }
    public string Title { get; set; }
}
Try it
Add Navigation Properties in Both Entities
Adding navigation properties at both entities will also result in a one-to-many relationship. For example, Author class contains a collection of Books while Book class contains a navigation property of type Author.
public class Author
{
    public int AuthorId { get; set; }
    public string Name { get; set; }
    public virtual ICollection<Book> Books { get; set; }
}

public class Book
{
    public int BookId { get; set; }
    public string Title { get; set; }
    public Author Author { get; set; }
}
Try it
Fully Defined Relationship
A fully defined relationship at both ends will also create a one-to-many relationship. For example, the Book entity includes foreign key property AuthorId with its reference property Author and Author class contains a collection of Books.
public class Author
{
    public int AuthorId { get; set; }
    public string Name { get; set; }
    public virtual ICollection<Book> Books { get; set; }
}

public class Book
{
    public int BookId { get; set; }
    public string Title { get; set; }
    public int AuthorId { get; set; }
    public Author Author { get; set; }
}
Try it
All these conventions produces the same result in the database.

Using Fluent API
You can also configure relationships using Fluent API to override the default conventions and make it more maintainable.
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
    // configures one-to-many relationship
    modelBuilder.Entity<Book>()
        .HasRequired<Author>(b => b.Author)
        .WithMany(a => a.Books)
        .HasForeignKey<int>(b => b.AuthorId);
}

Bkz:

ICollection<Gig> Gigs 
Bunun adı Navigation Property'dir
-
Linki kesin oku bi: https://blog.staticvoid.co.nz/2012/entity_framework-navigation_property_basics_with_code_first/

Entity Framework - Navigation Property Basics with Code First
What is a navigation property?
Navigation properties are Entity Frameworks way of representing Foreign Key relationships inside the database. Navigation properties allow you to define relationships between entities (rows in your database) in a way that makes sense in an object oriented language. Consider the following database:
 
As you can see a post has an author and that is relationaly linked inside our database. So how would we represent this same structure inside of an application (if we ignore the way this is implemented in a relational database)? It seems sensible that we would model this same structure with something like the following:
public class User
{
	public string Name { get; set; }
}

public class Post
{
	public User Author { get; set; }
}
Which means we can use it in code like this:
String.Format("{0} wrote this post", post.Author.Name);
What Entity Framework navigation proprieties do is to allow us to do just this with our database models. For example the above database structure could be represented as:
public class User
{
	public int Id { get; set; }
	public string Name { get; set; }
}

public class Post
{
	public int Id { get; set; }
	public User Author { get; set; }
}
-
-
How do Navigation Properties work?
When you are using navigation properties in your code you are asking Entity Framework to automatically perform a SQL join between your two tables. For example:
context.Posts.Where(p => p.Author.Name == "Luke");
will be translated into the following SQL*:
SELECT
	 p.Id,
	 p.Author_Id
   FROM  Posts AS p
	 INNER JOIN Users AS u ON p.Author_Id = u.Id
   WHERE u.Name = N'Luke'
As you can see our relationship in c# has been converted into the equivalent SQL join.
How do I load my properties (Why is my navigation property null)?
Navigation properties are not loaded by default, so its important to know how and when you need to load navigation properties. So lets look at some scenarios and see what entity framework will give us. These scenarios are based off the following data:
User
Id	Name
1	Luke
2	Bob
Post
Id	Author_Id
1	1
2	2
Case 1 :
context.Posts.ToArray();
When we make this request we get the following:
{
	"posts": [
		{
			"id": 1,
			"author": null
		},
		{
			"id": 2,
			"author": null
		}
	]
}
As you can see we have retrieved all the posts but haven’t received any of the linked authors.

Case 2:
context.Posts.Where(p => p.Author.Name == "Luke").ToArray();
When we make this request we get the following:
{
	"posts": [
		{
			"id": 1,
			"author": null
		}
	]
}
In this case the where clause successfully interacts with the author to filter by name, however when the results are returned the author is still not linked.
Case 3:
using System.Data.Entity; //this is required for .Include
...
context.Posts.Include(p => p.Author).ToArray();
When we make this request we get the following:
{
	"posts": [
		{
			"id": 1,
			"author": {
				"id":1,
				"name": "Luke"
			}
		},
		{
			"id": 2,
			"author":  {
				"id":2,
				"name": "Bob"
			}
		}
	]
}
As you can see by adding a .Include statement we are able to fetch the linked authors.
-
-
A note on lazy loading
Lazy loading is also an alternative to using the .Include syntax, however I recommend against using it in almost all cases as it makes it very easy to introduce subtle performance issues into your application. in addition using the include syntax makes it much more obvious what queries your code performs so increases readability.

How does Entity Framework detect Navigation Properties
When entity framework examines a class which is attached to the context it finds other complex type properties on the class and assumes that they are a foreign key to that table. Entity framework then creates a foreign key with the name [PropertyName]_[PropertyIdName] for example in the case of the post class the Author is [PropertyName] and in the user table Id is the Id. This means Author_Id is generated as the foreign key name.
The rules around navigation properties what’s acceptable and how they are generated are defined by a set of conventions. I’m not going to go into any more detail on how these work but for more information you can take a look at the following pages:
•	EF Feature CTP5: Pluggable Conventions
•	MSDN - System.Data.Entity.ModelConfiguration.Conventions Namespace
•	Entity Framework Navigation Property generation rules

More than the defaults with the Model Builder
Entity framework provides a mechanism to configure additional information about navigation properties. This additional configuration can be done using the Model Builder. The model builder allows control over how Entity Framework represents the database, one of the features of the model builder allows for control over how foreign keys in the database are translated to Navigation Properties in the Entity Framework Model.
To get access to the model builder you will need to override the OnModelCreating method on your DbContext. You can then use the modelBuilder argument to structure your Entity Framework Model.
public class MyContext : DbContext
{
	protected override void OnModelCreating(DbModelBuilder modelBuilder)
	{
	}   
}
The Model Builder uses a two part fluent expression to define navigation properties within the model. The first part of the expression defines the navigation property on the current entity, the second part of the expression defines the reverse navigation property. Navigation properties properties can be either Optional (ie 0..1 to x), Required (ie 1 to x) or Many (ie ** to x*). So lets take a look at some examples:
Optional relationship
If you have the following classes:
public class Entity1
{
    public int Id { get; set; }
}

public class Entity2
{
    public int Id { get; set; }
    public Entity1 Entity1 { get; set; }
}
Using the following model builder statement
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
    modelBuilder.Entity<Entity2>().HasOptional(e => e.Entity1).WithMany();
}  
Yukarıdaki kodu okuyalım: Entity2 optional olarak Entity1 e sahip (sahip olabilir de olmayabilir de.) (yani aşağıdaki çizimde, okun ucu 0 veya 1 olabilir... sahip olabilir veya olmayabilir)
Sağ kısmı okuyalım (entity1).WithMany();           Entity1 birçok (withmany) entity1’e sahip.

Will create the following relationship
 
Note the two parts of the query the first to define Entity1 navigation property, the first part defines an optional relationship (ie a nullable foreign key) and the second part .WithMany() defines the remote entity’s (Entity1) multiplicity. Using .WithMany() with no argument tells Entity Framework that the relationship does not have a remote navigation property. (koda bak oradan da görürsün... Entity1 class’ında navigation property yok)
Required Relationship
If you have the following classes:
public class Entity1
{
   public int Id { get; set; }
   public List<Entity2> Entity2s { get; set; }
}

public class Entity2
{
   public int Id { get; set; }
   public Entity1 Entity1 { get; set; }
}
Using the following model builder statement
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
	modelBuilder.Entity<Entity2>()
		.HasRequired(e => e.Entity1)
		.WithMany(e => e.Entity2s);
}   
Will create the following relationship
 
Note that in this example we have specified a remote collection for the relationship. This means that you can use the Entity2s property to find all linked entities.
-
-
-
-
-
-
Default Parameters / Optional Parameters / Required Parameters

static void Main()
        {
            MyMethod(3,3);
            Console.ReadKey();
        }
        static void MyMethod(int x, int y = 2)
        {
            Console.WriteLine(x);
            Console.WriteLine(y);       
        }
Yukarıdaki MyMethod metodumuzda iki tane parametre var: x ve y.
Bunlardan:
 int x ==> required parameter
int y = 2  ==> optional parameter (default parameter)
ikinci parametreye opsiyonel deniyor; çünkü bu parametreye değer vermesek de olur.
Not: Metod tanımlanırken, optional parametreler, required parametrelerden sonra yazılmalıdır. 
Yani şu durumda:
static void MyMethod(int x = 2, int y)
gibi bir şey yazarsak hata verecektir.

Bi örnek daha:
using System;

class Program
{
    static void Main()
    {
        MyMethod(1, 2);
        MyMethod(5);
        Console.ReadKey();
    }
    static void MyMethod(int x, int y = 0)
    {
        Console.WriteLine(x + ", " + y);
        //1,2
        //5,0   (x'i 5 verip y yi boş bıraktık. y'nin default value'su da 0 idi. O yüzden 0 döndü)
    }

}


Uzun anlatım:
Merhaba Arkadaşlar,
2004 ve  2005 yıllarında uzun bir süre editörlüğünü yaptığım C#Nedir? topluluğunun düzenlediği C# Akademi eğitimlerinde, yarı zamanlı eğitmen olarak görev yapmıştım. Genellikle C# programlama dilinin basit ve temel konularını, ayrıca Object Oriented özelliklerini aktarmaya çalışırdım. Elbette sınıfımdaki öğrencilerim yanda görüldüğü gibi her zaman pür neşe olmazlardı.
Ancak insan zaman içerisinde profesyonelleşme yolunda ilerledikçe konuları çok daha farklı açılardan ele alması gerektiğini de öğreniyor. Profesyonel bir eğitmenin en iyi yaptığı işlerin başında, en zor konuları çöp adam kullanarak anlatmak gelmektedir. Tabi eğitmenin gerçek hayat tecrübelerini ve ip uçlarını da aktarıyor olması, profesyonelliğinin diğer bir göstergesidir. Böyle bir eğitmenin vereceği önerileri pür dikkat dinlemekte yarar vardır.
Ben eğitmenliği bırakalı uzun bir süre oldu ama makale yazarken veya görsel ders çekerken, konunun anlatımı sırasında yukarıdaki hususlara dikkat etmeye çalışıyorum. Bu anlamda bazen çok basit olarak görünen bir konunun, aslında derinlere inildiğinde dikkat edilmesi gereken noktalar içerdiğini sürekli vurgulamaya çalışan yazıları da hazırlama uğraşısı içerisindeyim. İşte bu yazımızın konusu da; C# 4.0 ile birlikte gelen yeni dil özelliklerden birisi olan Default Parameters ile ilişkili tuzaklar. Öncelikli olarak konuya aşağıdaki hazır kod parçası ile başlayalım.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52	using System;
 
namespace DefaultAndOptionalParametersCase 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            Connection myConn = new Connection(); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks"); 
            Console.WriteLine(myConn.ToString()); 
        } 
    }
 
    class Connection 
    { 
        public string Server { get; set; } 
        public string Database { get; set; } 
        public int Timeout { get; set; } 
        public int PacketSize { get; set; }
 
        #region Constructors
 
        public Connection(string server,string databaseName,int timeout,int packetSize) 
        { 
            Server = server; 
            Database = databaseName; 
            Timeout = timeout; 
            PacketSize = packetSize; 
        } 
        public Connection(string server, string databaseName, int timeout) 
            : this(server, databaseName, timeout, 4096) 
        { 
        } 
        public Connection(string server, string databaseName) 
            : this(server, databaseName, 45, 4096) 
        { 
        } 
        public Connection() 
            : this(".", "master", 45, 4096) 
        { 
        }
 
        #endregion
 
        public override string ToString() 
        { 
            return String.Format("server={0};database={1};timeout={2},packetSize={3}", Server, Database, Timeout, PacketSize); 
        } 
    } 
}
 
Bu kod parçasında dikkat etmemiz gereken nokta Constructor metodlarıdır. Görüldüğü üzere en fazla sayıda parametre alan yapıcı metod, diğer yapıcı metodlar tarafından kullanılmaktadır. Burada this anahtar kelimesini takip eden ifadeler içerisinde gerekli aktarma işlemlerinin yapıldığı görülebilir.

Eski bilgilerimizi bir hatırlayalım. Bilindiği üzere yapıcı metodlarda(Constructors) this yerine base anahtar kelimesini kullanarak, metod parametrelerinin bir üst sınıftaki versiyonuna gönderilmesi de sağlanabilir.
Tabi burada C# 4.0 ile gelen Default Parameters yeteneğinin devreye girmesi ile n sayıda metod yerine tek bir metodun kullanılması söz konusu olabilir. Nitekim ele aldığımız örnek senaryoda yapıcı metodların tek yaptığı, uygun olan versiyona parametre değerlerini taşımaktır. Dikkat edileceği üzere sadece tek bir yapıcı metod içerisinde özellik değer atama işlemleri yapılmaktadır. Diğer yapıcı metodlar sadece parametre değerlerini taşımak için kullanılmaktadır. Aşağıdaki şekilde bu durum ifade edilmeye çalışılmaktadır.

Aslında Constructor kullanımının buradaki amacı, Connection tipine ait nesne örneklerinin oluşturulması sırasında alternatif versiyonları varsayılan parametre değerlerine göre sunabilmektir. Bu amaç düşünüldüğünde Default Parameters yeteneği önemli bir avantaj sağlamaktadır. Gelin kodumuzu Default Parameters kabiliyetini kullanarak aşağıdaki hale getirelim.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38	using System;
 
namespace DefaultAndOptionalParametersCase 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            Connection myConn = new Connection(); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks"); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks",20,512); 
            Console.WriteLine(myConn.ToString()); 
        } 
    }
 
    class Connection 
    { 
        public string Server { get; set; } 
        public string Database { get; set; } 
        public int Timeout { get; set; } 
        public int PacketSize { get; set; }
 
        public Connection(string server=".", string databaseName="master", int timeout=45, int packetSize=4096) 
        { 
            Server = server; 
            Database = databaseName; 
            Timeout = timeout; 
            PacketSize = packetSize; 
        }
 
        public override string ToString() 
        { 
            return String.Format("server={0};database={1};timeout={2},packetSize={3}", Server, Database, Timeout, PacketSize); 
        } 
    }    
}
-
Bu kod parçasında dikkat etmemiz gereken nokta Constructor metodlarıdır. Görüldüğü üzere en fazla sayıda parametre alan yapıcı metod, diğer yapıcı metodlar tarafından kullanılmaktadır. Burada this anahtar kelimesini takip eden ifadeler içerisinde gerekli aktarma işlemlerinin yapıldığı görülebilir.

Eski bilgilerimizi bir hatırlayalım. Bilindiği üzere yapıcı metodlarda(Constructors) this yerine base anahtar kelimesini kullanarak, metod parametrelerinin bir üst sınıftaki versiyonuna gönderilmesi de sağlanabilir.
Tabi burada C# 4.0 ile gelen Default Parameters yeteneğinin devreye girmesi ile n sayıda metod yerine tek bir metodun kullanılması söz konusu olabilir. Nitekim ele aldığımız örnek senaryoda yapıcı metodların tek yaptığı, uygun olan versiyona parametre değerlerini taşımaktır. Dikkat edileceği üzere sadece tek bir yapıcı metod içerisinde özellik değer atama işlemleri yapılmaktadır. Diğer yapıcı metodlar sadece parametre değerlerini taşımak için kullanılmaktadır. Aşağıdaki şekilde bu durum ifade edilmeye çalışılmaktadır.

Aslında Constructor kullanımının buradaki amacı, Connection tipine ait nesne örneklerinin oluşturulması sırasında alternatif versiyonları varsayılan parametre değerlerine göre sunabilmektir. Bu amaç düşünüldüğünde Default Parameters yeteneği önemli bir avantaj sağlamaktadır. Gelin kodumuzu Default Parameters kabiliyetini kullanarak aşağıdaki hale getirelim.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38	using System;
 
namespace DefaultAndOptionalParametersCase 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            Connection myConn = new Connection(); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks"); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks",20,512); 
            Console.WriteLine(myConn.ToString()); 
        } 
    }
 
    class Connection 
    { 
        public string Server { get; set; } 
        public string Database { get; set; } 
        public int Timeout { get; set; } 
        public int PacketSize { get; set; }
 
        public Connection(string server=".", string databaseName="master", int timeout=45, int packetSize=4096) 
        { 
            Server = server; 
            Database = databaseName; 
            Timeout = timeout; 
            PacketSize = packetSize; 
        }
 
        public override string ToString() 
        { 
            return String.Format("server={0};database={1};timeout={2},packetSize={3}", Server, Database, Timeout, PacketSize); 
        } 
    }    
}

Dikkat edileceği üzere tek bir yapıcı metod kullanımı söz konusudur. Bir başka deyişle kod kısalmıştır. Yapıcı metodun parametrelerinde verilen varsayılan değerler sayesinde, Connection tipine ait nesne örneklerinin oluşturulması şekillendirilmiştir. Örneğin, çalışma zamanı çıktısı aşağıdaki gibi olacaktır.
 
Aslında işin içerisine Named Parameters kullanımını da katmamız yerinde olacaktır. Neden? Main metodu içerisindeki aşağıdaki kod satırını göz önüne alalım.
1	myConn = new Connection("localhost", "AdventureWorks",20,512);
Geliştirici kodu yazarken parametrelerin ne anlama geldiğini, isimlerinden veya varsa eğer XML Comment’ lerden çıkartabilir. Ancak tamamlanmış kodun okunması sırasında 20 ve 512 rakamlarının en anlama geldiği kolayca anlaşılamayabilir. İşte bu noktada parametreleri isimlendirerek kullanmak aşağıdaki okunurluğu sağlayacaktır.
1	myConn = new Connection(server:"localhost", databaseName:"AdventureWorks", timeout:20, packetSize:512);

Parametre Sayısının Arttırılması
Gelelim default parameters kullanımında dikkatli olmamız gereken hususlara. İlk olarak parametre sayısının arttırılması durumunu göz önüne alacağız. Ancak senaryonun oluşumunda Named Parameters kullanmadığımızı varsayıyoruz. Bu amaçla Connection tipine ait yapıcı metodu aşağıdaki gibi değiştirdiğimizi düşünelim.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40	using System;
 
namespace DefaultAndOptionalParametersCase 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            Connection myConn = new Connection(); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks"); 
            Console.WriteLine(myConn.ToString()); 
            myConn = new Connection("localhost", "AdventureWorks",20,512);            
            Console.WriteLine(myConn.ToString()); 
        } 
    }
 
    class Connection 
    { 
        public string Server { get; set; } 
        public string Database { get; set; } 
        public int Timeout { get; set; } 
        public int PacketSize { get; set; } 
        public int ProcessId { get; set; }
 
        public Connection(string server=".", string databaseName="master", int timeout=45,int processId=10, int packetSize=4096) 
        { 
            Server = server; 
            Database = databaseName; 
            Timeout = timeout; 
            PacketSize = packetSize; 
            ProcessId = processId; 
        }
 
        public override string ToString() 
        { 
            return String.Format("server={0};database={1};timeout={2},packetSize={3},PId:{4}", Server, Database, Timeout, PacketSize,ProcessId); 
        } 
    }    
}

Kodda sadece processId isimli bir metod parametresi eklendiğini görmekteyiz. Bu aslında sonradan yapılan bir değişiklik olarak düşünülmelidir. Bir başka deyişle geliştirdiğimiz projelerde sonradan varsayılan parametre eklenmesi söz konusu olabilir. Buna göre çalışma zamanı çıktısı aşağıdaki gibi olacaktır.
 
Dikkatinizi çeken bir nokta var mı?
Son çıktıya göre ProcessId değerinin 512 olduğu görülmektedir. Oysaki 512 değeri daha önceki kodlamaya göre PacketSize özelliği için atanan bir değerdir. Bir başka deyişle yanlış bir değer ataması söz konusudur. İşin kötü yanı bu senaryoda derleme zamanında bir hata veya uyarı mesajı alınmamaktadır. Dolayısıyla kodun hatalı çalışması olasıdır.
Öyleyse varsayılan parametre kullanımı gibi senaryolarda, metodlara yeni parametrelerin eklenmesi söz konusu ise, bu parametrelerin en sona eklenmesi daha doğru olacaktır. Named Parameters aslında köklü çözüm olsa da, ilgili tip metodlarını kullanan diğer geliştiricilerin bu kullanımı göz ardı etmesi ihtimali vardır.
Yani metod yapısını aşağıdaki gibi değiştirmemiz doğru bir çalışma zamanı çıktısı elde etmemizi sağlayacaktır.
1	public Connection(string server = ".", string databaseName = "master", int timeout = 45, int packetSize = 4096,int processId = 10)
,sonucu çalışma zamanı çıktısı aşağıdaki gibidir.

Türetme(Inheritance) ve Varsayılan Parametreler
Gelelim diğer bir vakaya. Bu vaka çok daha kritik ve önemlidir. Nitekim işin içerisinde türetme(Inheritance) kavramı vardır. Konuyu netleştirmek için aşağıdaki sınıf şemasına sahip örnek kod parçasını göz önüne alarak ilerleyelim.
 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43	using System;
 
namespace DefaultAndOptionalParametersCase 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            MyCommand myCmd = new MyCommand(); 
            ICommand iCmd = myCmd; 
            Command cmd = myCmd;
 
            Console.WriteLine(myCmd.PrepareSelectTop("Product")); 
            Console.WriteLine(iCmd.PrepareSelectTop("Product")); 
            Console.WriteLine(cmd.PrepareSelectTop("Product")); 
        } 
    }
 
    interface ICommand 
    { 
        string PrepareSelectTop(string tableName, int topNumber = 3); 
    } 
    class Command 
       : ICommand 
    { 
        #region ICommand Members
 
        public virtual string PrepareSelectTop(string tableName, int topNumber = 10) 
        { 
            return String.Format("Select top {0} from {1}",topNumber,tableName);            
        }
 
        #endregion 
    } 
    class MyCommand 
       : Command 
    { 
        public override string PrepareSelectTop(string tableName, int topNumber = 50) 
        { 
            return String.Format("Select top {0} from {1}",topNumber,tableName); 
        } 
    }   
}

Aslında bu senaryo Temeller Kolay Unutulur (C# – Implicitly Name Hiding Sorunsalı) başlıklı yazımızdan size tanıdık gelecektir.
Sınıf şemasından da görüleceği üzere ICommand arayüzünü(Interface) uygulayan Command isimli bir tip ve bundan türeyen MyCommand sınıfı söz konusudur. MyCommand sınıfı, Command tipinde virtual olarak tanımlanmış ve aslında ICommand arayüzü tarafından zorunlu hale getirilmiş PrepareSelectTop metodunu ezmektedir(Overriding).
Kritik olan yer Main metodu içerisindeki değişken atamalardır. Dikkat edileceği üzere ICommand ve Command tipinden olan değişkenlere aynı MyCommand nesne örneği atanmıştır. Eğer çok biçimlilik ilkesini biliyorsak, iCmd ve cmd isimli nesne örnekleri üzerinden yapılan PrepareSelectTop çağrılarının aslında MyCommand tipindeki metod içeriğine doğru yapılması gerektiğini biliriz. Buna göre de tüm Select sorgularında Top 50 değerinin kullanılıyor olması gerekmektedir. Oysaki çalışma zamanı çıktısı aşağıdaki gibi olacaktır.
 
Görüldüğü gibi son iki çağrıda topNumber için Default Parameter değerleri tanımlandıkları yerdekiler olmuştur. ICommand için 3 iken Command için 10 olarak ele alınmıştır. Tam bu noktada “Amanın! Yoksa ICommand ve Command tipleri çok biçimlilik göstermiyorlarmış!” diye haykırabilirsiniz. Ama dereyi görmeden paçaları sıvamamak lazım. Nitekim uygulamayı debug modda değerlendirdiğimizde, aslında tüm PrepareSelectTop çağrılarının, MyCommand içinden yapıldığı görülecektir.
Sorun tamamen Default Parameter’ lar ile alakalıdır. Söz gelimi ICommand üzerinden yapılan çağrı sonucu topNumber değeri aşağıdaki gibi olacaktır.
 
veya Command tipi için şu şekilde olacaktır.
 
Böyle bir vakanın oluşmasının sebebi Defaul Parameter’ ların çalışma zamanı(Runtime) yerine derleme zamanında(Compile Time) çözümleniyor olmalarıdır. Bu durum IL(Intermediate Language) kodunda açık bir şekilde görülebilir ve ispatlanabilir.


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38	.method private hidebysig static void  Main(string[] args) cil managed 
{ 
  .entrypoint 
  // Code size       68 (0x44) 
  .maxstack  3 
  .locals init ([0] class DefaultAndOptionalParametersCase.MyCommand myCmd, 
           [1] class DefaultAndOptionalParametersCase.ICommand iCmd, 
           [2] class DefaultAndOptionalParametersCase.Command cmd) 
  IL_0000:  nop 
  IL_0001:  newobj     instance void DefaultAndOptionalParametersCase.MyCommand::.ctor() 
  IL_0006:  stloc.0 
  IL_0007:  ldloc.0 
  IL_0008:  stloc.1 
  IL_0009:  ldloc.0 
  IL_000a:  stloc.2 
  IL_000b:  ldloc.0 
  IL_000c:  ldstr      "Product" 
  IL_0011:  ldc.i4.s   50 
  IL_0013:  callvirt   instance string DefaultAndOptionalParametersCase.Command::PrepareSelectTop(string, 
                                                                                                  int32) 
  IL_0018:  call       void [mscorlib]System.Console::WriteLine(string) 
  IL_001d:  nop 
  IL_001e:  ldloc.1 
  IL_001f:  ldstr      "Product" 
  IL_0024:  ldc.i4.3 
  IL_0025:  callvirt   instance string DefaultAndOptionalParametersCase.ICommand::PrepareSelectTop(string, 
                                                                                                   int32) 
  IL_002a:  call       void [mscorlib]System.Console::WriteLine(string) 
  IL_002f:  nop 
  IL_0030:  ldloc.2 
  IL_0031:  ldstr      "Product" 
  IL_0036:  ldc.i4.s   10 
  IL_0038:  callvirt   instance string DefaultAndOptionalParametersCase.Command::PrepareSelectTop(string, 
                                                                                                  int32) 
  IL_003d:  call       void [mscorlib]System.Console::WriteLine(string) 
  IL_0042:  nop 
  IL_0043:  ret 
} // end of method Program::Main
IL kodunda yer alan ldc komutlaraına bakıldığında Defualt Parameter değerlerinin, tip tanımlamaları sırasında yazıldığı gibi set edildiği açık bir şekilde görülebilmektedir.
Kolayca gözden kaçabilecek bir durum olduğu için tehlikeli bir vaka olduğunu ifade edebiliriz. Dolayısıyla en azından bu senaryoya göre Default Parameter kullanımını aslında Interface seviyesinde bırakmak çözüm olarak düşünülebilir.
Böylece geldik bir yazımızın daha sonuna. Tekrardan görüşünceye dek hepinize mutlu günler dilerim.
-
-
-
-
One of the major annoyances when starting with C# was the lack of default arguments. Generating two or three overloads manually is ok, but looking at the 28 overloads for a MessageBox makes my head tingle (in an ugly way).
Now I can't hack the C# compiler to magically allow this. I can, however, provide a code generator that creates a set of overloads from a declaration containing default arguments.
Using the Tool
Enter your declaration in the first edit box. You can add default arguments like you would in C++, and the generated code appears immediately in the text field below. Click "Copy" to copy the generated code to the clipboard. Example:
Hide   Copy Code
void Add(string name = "(none)", int age = 22)
The above generates the following implementations:
Hide   Copy Code
// $overload: void Add(string name = "(none)", int age = 22){
 // do your worst! - implement the actual method here
}

#region overloads for: Add

public void Add(string name)
{
 Add(name, 22);
}

public void Add()
{
 Add("(none)", 22);
}

#endregion // overloads
public void Add(string name, int age)
The first overload is the method you actually implement. The other overloads have a reduced argument list and call the first.
The first line is for integration with Linkify (see below).
It Gets Better (Optionally)
C++ default arguments allow to omit parameters at the end of the argument list. However, in the above example where argument types are distinct, you may want to omit the name but still specify the age. I've added a custom "keyword", optional, that can drop arguments from the middle of the argument list:
Hide   Copy Code
void Add(optional string name = "(none)", int age = 22)
This generates the following signatures:
Hide   Copy Code
public void Add(string name, int age) { } // the one to implement
public void Add(string name)
public void Add()
public void Add(int age)
The last one omits the string name parameter.
It is your responsibility to make sure the resulting overloads aren't ambiguous. If you don't feel up to the job, the compiler will catch you!

Integration with Visual Studio - Linkify
I've updated my Linkify article that allows to visit URLs and run external tools from source code comments. Also, DefaultOverloader now generates a declaration line that Linkify can understand:
Hide   Copy Code
// $overload: void Add(string name = "(none)", int age = 22)
void Add(string name, int age)
Note: You need to set the path to the DefaultOverloader executable first in the Linkify configuration dialog. See that article for details.
Place the caret on the "$overload" and click "Linkify". Default Overloader opens with your declaration already in place.
You can also copy the two declaration lines separately by clicking "copy head", and the overloads region by clicking "copy body". This allows to preserve the body of the main functions implementation. Auto-Paste makes that even easier.
Auto-Paste
Auto-Paste makes that even easier. It works without Linkify installed (but then, the first step is more complicated). To modify an existing block with overloads:
1.	Place caret on "$overload", and start Linkify
» DefaultOverloader will open, with your declaration ready to be edited.
2.	After making your modifications, click "Auto-Paste"
» DefaultOverloader minimizes, and displays "Paste Head" as title
3.	Select the two head lines (comment and main function header), and paste
» The declarations are replaced with the new contents
» DefaultOverloader (still minimized) displays "Paste Body" as title
4.	Collapse the #region Overloads for..., select the entire line, and paste
» New overloads replace the previous ones
» DefaultOverloader closes
Restore the DefaultOverloader from minimized state to cancel the paste sequence. There is a small delay between the first paste and the second data arriving on clipboard, so don't paste too fast in succession!

Limitations
The parser is fairly simple. So you might be able to create declarations that aren't interpreted correctly. One thing is a function name with multiple template parameters: don't put spaces in the template list, otherwise, I get the function name wrong!
The parser doesn't validate your declaration - that's left to your compiler.
This is unfortunately no full replacement for default parameters. One thing where some language and IDE support would be helpful is Intellisense - you still get listed all overloads separately. Also, when you modify the declaration, you have to use the Overloader again.
The Debate
There is a reason there are no default parameters in MSIL or the C# language - to learn about the reasons, read Eric Gunnersons response [^] or start at Google [^].
In my opinion, Eric has a valid argument why default arguments aren't in MSIL - but it doesn't hold up for the C# language itself. After all, C# could do what I do.:)
Points of Interest
Permutation of Bools
For implementing the optional keyword, I needed to permute over all variations of having them in. With N parameters tagged optional, I need to generate all possible combinations of N bool values. While some approaches can be found on the 'net, none was plug-and-play-enough for me. Thinking how to implement it myself, a "background thread" associated the idea of a bool array with a bit array - bools are bits! This allows a very simple solution: just count from 0 to 2<sup>N</sup>-1, and treat each bit as a flag.

Parsing the Argument List
The sources contain a (still somewhat experimental) Tokenizer that respects single- and double-quoted strings as well as round, square and curly brackets. This is required to parse declarations like the following correctly:
Hide   Copy Code
SendMessage(string X = "Hello, World", int[,] targetCoords) 
It's barely tested and needs some extensions to be reusable, but it works well enough for the application given.
Thank You
A big thank you to everyone who helped me at the C# forums here - especially Judah Himango who often went an extra mile.
I am currently working on my first "real world" C# project (complete with time pressure, feature creep, big plans, and get-it-done-while-everybody-is-out-to-distract you), and you have been really helpful in getting my stubborn head through this wall - or at least into it.

Domain / Application Domain	 (GITHUB)  (test)
Domain nedir, application domain nedir
A domain is the targeted subject area of a computer program. It is a term used in software engineering. Formally it represents the target subject of a specific programming project, whether narrowly or broadly defined.[1] For example, a particular programming project might have had as a goal the creation of a program for a particular hospital, and that hospital would be the domain. Or the project could be expanded in scope to include all hospitals as their domain. In a computer programming design, you define a domain by delineating a set of common requirements, terminology, and functionality for any software program constructed to solve a problem in the area of computer programming, known as domain engineering. The word domain is also taken as a synonym of application domain.
Domain in the realm of software engineering commonly refers to the subject area on which the application is intended to apply. In other words, during application development, the domain is the "sphere of knowledge and activity around which the application logic revolves." —Andrew Powell-Morse
Domain: A sphere of knowledge, influence, or activity. The subject area to which the user applies a program is the domain of the software. —Eric Evans

Eager Loading

(bu cümle ne diyor) If you use lazy loading, EntityFramework will take care of loading the navigation property for you, so you won't get an exception.
Lazy loading will produce several SQL calls while Eager loading may load data with one "more heavy" call (with joins/subqueries).
Mantık şu şekilde kurumalı. Lazyloading = tembel, o yüzden en az ne kadar data getirebiliyorsa, o kadar getiriyor. Yani her ilişkili datayı yüklenmiyor sırtına. 
Eager ise adı üstünde, eager olduğu için tüm datayı getiriyor, eager bir kedi gibi düşünebiliriz, yerinde durmayan. Lazy kedi ise en ufak işgücünü ortaya koyar, kendini yormaz.
For example, If there is a high ping between your web and sql servers you would go with Eager loading instead of loading related items 1-by-1 with lazy Loading.

 Lazy loading will produce several SQL calls while Eager loading may load data with one "more heavy" call (with joins/subqueries).
For example, If there is a high ping between your web and sql servers you would go with Eager loading instead of loading related items 1-by-1 with lazy Loading.

You can't perform eager loading with the Find method, so the Where
and Single methods are used instead to select the instructor.

Eager Loading: Eager Loading helps you to load all your needed entities at once. i.e. related objects (child objects) are loaded automatically with its parent object.
Use Eager Loading when the relations are not too much. Thus, Eager Loading is a good practice to reduce further queries on the Server.
1.	Use Eager Loading when you are sure that you will be using related entities with the main entity everywhere.

Lazy Loading: In case of lazy loading, related objects (child objects) are not loaded automatically with its parent object until they are requested. By default LINQ supports lazy loading.
Use Lazy Loading when you are using one-to-many collections.
1.	Use Lazy Loading when you are sure that you are not using related entities instantly.
NOTE: Entity Framework supports three ways to load related data – eager loading, lazy loading and explicit loading.

Eager loading is the opposite of Lazy loading but Explicit loading is similar to lazy loading, except that: you explicitly retrieve the related data in code; it doesn't happen automatically when you access a navigation property. You load related data manually by getting the object state manager entry for an entity and calling the Collection.Load method for collections or the Reference.Load method for properties that hold a single entity.
From techblog:
Eager Loading :
Eager loading is the opposite of Lazy loading which is : The process of loading a specific set of related objects along with the objects that were explicitly requested in the query.
Explicit Loading :
Explicit loading is defined as : when objects are returned by a query, related objects are not loaded at the same time. By default, they are not loaded until explicitly requested using the Load method on a navigation property.
And:
If I Use lazy loading and I call for example dpc_gestion.dpc_participant, does the navigation properties loads?or I will get an exception?
You don't get any exception and the navigation properties should loads.
Is there a case when eager loading or explicit loading were better than lazy loading in performance and responsiveness?

Eager loading is typically more efficient when you need the related data for all retrieved rows of the primary table. And also when relations are not too much, eager loading will be good practice to reduce further queries on server. But when you know that you will not need a property instantly then lazy loading maybe a good choice. And also eager loading is a good choice in a situation where your db context would be disposed and lazy loading could not take place anymore. For example consider the following:
public List<Auction> GetAuctions()
{
    using (DataContext db = new DataContext())
    {
        return db.Auctions.ToList();
    }
}
After calling this method, You cannot load the related entity lazily because the db is disposed and so the Eager Loading would be a better choice here.
One more thing to note is: Lazy loading will produce several SQL request while Eager loading load data with one request. Eager loading is also a good choice to solve the n+1 selects issue in ORMs. Have a look at this post: What is the n+1 selects issue?
-

we have known how to use Eager Loading, Explicit Loading and Lazy Loading in the previous three posts. I am going to dig into what’s the advantages and disadvantages of those methods.
Eager Loading
Eager Loading means that the related data will load from the database as the initial query. in other words, Eager Loading can save your time from avoid executing additional SQL queries.
both Entity Framework 6 and Entity Framework Core support eager loading of entities. if you are operating some lightweight data or fast-queries, then the eager loading would be suited for you.
Most of the scenarios can fit this Eager Loading strategy.

Lazy Loading
the Lazy Loading is the opposite of the Eager Loading, the Lazy Loading means the related entities are loaded transparently when the navigation property is accessed. in other words, in the underlying of Entity Framework, the Lazy Loading would run separate SQL queries.
In the blowing scenario, the Lazy Loading would be a no sense option. you have many books, each book has navigation properties like author, reviewer, editor. you are iterating books to access these navigation properties. Lazy Loading is going to degrade the performance because books are small lightweight data. for example, if you have 5 thousand books, each iteration will access 3 navigation properties, then you are going to execute 15 thousand separate SQL queries. it would be a disaster!
Actually. The Lazy Loading was added on .NET Core 2.1, it’s not a wise choice for most scenarios. but if you have a member that could be costly to load, and this member is infrequently visited, for scenarios like this, it would be a good choice to use Lazy Loading.
Explicit Loading
Explicit loading is valid in EF 6 and EF Core both. Explicit loading is similar to lazy loading, except that: you explicitly retrieve the related data in code; it doesn’t happen automatically when you access a navigation property. in other words, Related entities are only loaded when you say “Load!”,
So, if you are figuring how to avoid relation entities instantly load in Lazy Loading, you can disable Lazy Loading as an option, or you can use Explicit Loading.
The Explicit Loading is typically more efficient when you need the related data for all retrieved rows of the primary table. Explicit Loading would be a good practice to reduce further SQL queries.
-
-
-
-
-
Fields, Properties	      (GITHUB)  (test)
Field nedir Property nedir, field vs property, property vs field
Msdn forumu önemli: https://social.msdn.microsoft.com/Forums/en-US/7e1ac2fd-850d-4eb3-b96c-95149d628cfd/whats-the-difference-between-class-variable-amp-instance-variable-amp-how-many-variable-types-r?forum=csharplanguage

Properties expose fields. Fields should (almost always) be kept private to a class and accessed via get and set properties. 
Properties provide a level of abstraction allowing you to change the fields while not affecting the external way they are accessed by the things that use your class.

süper örnek:

public class MyClass
{
    // this is a field.  It is private to your class and stores the actual data.
    private string _myField;

    // this is a property. When accessed it uses the underlying field,
    // but only exposes the contract, which will not be affected by the underlying field
    public string MyProperty
    {
        get
        {
            return _myField;
        }
        set
        {
            _myField = value;
        }
    }

    // This is an AutoProperty 
    // used to generate a private field for you
    public int AnotherProperty{get;set;} 
}

Fields are ordinary member variables or member instances of a class. Properties are an abstraction to get and set their values. Properties are also called accessors because they offer a way to change and retrieve a field if you expose a field in the class as private. Generally, you should declare your member variables private, then declare or define properties for them.
-
-
-
-
-
MSDN forumundan puanlı bi adamdan cevap: 
"Class variables", in C#, are called static variables.  They are variables that are defined at the type level instead of defined on an instance.  This allows all instances of the class (and the class itself) to reference the same variable.
 
Instance variables are defined on an instance of the class.  This means that each instance of an object will have it's own "copy" of the instance variable.

For example:
 
// Given:

public class MyClass {

  public static int ClassVariable { get; set; }

  public int InstanceVariable { get; set; }

  public void Print()
  {
     Console.WriteLine("Class: {0} - Instance: {1}", ClassVaraible, InstanceVariable );
  }
}


// You can do:

// Set the "class" level variable
MyClass.ClassVariable = 3;

// Create two instances
MyClass instance1 = new MyClass();
MyClass instance2 = new MyClass();

instance1.InstanceVariable = 5;
instance2.InstanceVariable = 7;

instance1.Print(); // Prints 3, 5

instance2.Print(); // Prints 3, 7
-
-
I think people use different terminology for these kind of things like we hear all kind of terms Base class, parent class, inherited class or derived class etc.
As per the ECMA Specification of C# here is some explaination of fields:
A field is a member that represents a variable associated with an object or class.
A static variable is associated with a type, whereas an instance variable is associated with an instance.
For example:

class Employee
{
     private static ds;
     public string Name;
     public decimal Salary;
…
}
Shows an Employee class that has a private static variable and two public instance variables.

-
-
Class Variables are variables which are declared as static in Class. And Instance variable are variables which are not declared as static they can either private or public.
Static Example
Declaring instance variables:
private string customerName;
private int customerAge;
private boolean favoriteCustomer = false;
Declaring a class variable:
private static int noOfCustomers;
 
________________________________________
Regards
Nayan Paregi (MCTS)
Please remember to click “Mark as Answer” on the post that helps you, and to click “Unmark as Answer” if a marked post does not actually answer your question. This can be beneficial to other community members reading the thread.-

-
-
Birisi anlatmış:
Nesneye yönelik programlamanın üç temel ilkesinden biri olan sarmalamayı (encapsulation) uygularken kullanılıyoruz.
Sarmalama ilkesinde, bir sınıf tanımlaması içindeki değerleri tutan asıl değişkenlere (field) doğrudan erişimi engelleriz. Bu değişkenlere değer atamak için özelliklerden (property) yararlanırız. 
Bu değişkenlere değer atarken veya değerini istediklerinde tanımladığımız özellik bloğu otomatik olarak çalıştırılır. Biz de bu bloğun içinde değerleri test eder ve ondan sonra göndeririz veya değiştiririz.
Sınıfı kullanan kişi özelliklere doğrudan erişebilir. Alanlara doğrudan erişemez, erişmemelidir. Aksi halde istenmeyen değerleri bilerek veya yanlışlıkla atayarak sınıfımızın hatalı çalışmasına neden olabilirler.
1.	public class Deneme
2.	{
3.	    // Bu bir alan (field). Asıl genişlik değeri bunda saklanacak. 
4.	    private int genislik;
5.	 
6.	    // Bu (Genislik) bir özellik (property). Sınıfı kullanan bunu değiştirmek istediğinde
7.	    // set ile tanımlanan blok, bunun değerini istediğinde get ile tanımlanan
8.	    // blok otomatik çalıştırılır.
9.		
10.	    public int Genislik
11.	    {
12.		// Genislik özelliğinin değerini istediğinde...
13.	        get
14.	        {
15.		    // ... genislik alanının değerini gönder.
16.	            return genislik; 
17.	        }
18.		// Genislik özelliğinin değerini değiştirmek istediğinde...
19.	        set
20.	        {
21.		    // ... gelen değeri (value ile gelir) genislik alanına ata.
22.	            genislik = value;
23.	        }
24.	    }
25.	}
Tabi bu örnekte kontrol kısmı (ki asıl önemli konudur) yok. Sade olsun diye eklenmedi. Aşağıdakinde ise kontrol ediyoruz. Genellikle değer gönderirken (get bloğunda) varsa değer göndermeden önce yapılacak işler, testler veya ayarlamalar yapılır. Tabi varsa.
Asıl önemli olan set bölümü. Bu bölümde value ile gelen değeri kontrol ederiz ve eğer değer uygun ise alana atarız. Aksi halde bir hata fırlatırız veya varsayılan bir değeri atarız. Tabi değer atamadan önce veya sonra başka yapılacak işlemler de varsa onları da yapabiliriz.


1.	public class Deneme
2.	{
3.	    private int genislik;
4.	 
5.	    public int Genislik
6.	    {
7.	        get
8.	        {
9.	            return genislik; 
10.	        }
11.	        set
12.	        {
13.	            if (value <= 0)
14.	                throw new Exception("Deneme'nin genişliği 0'dan büyük bir değer olmalı.");
15.	            genislik = value;
16.	        }
17.	    }
18.	}
Örnekte set bölümünde gelen değer (value) 0 veya daha küçük ise bir hata fırlatıyoruz. Tabi varsayılan bir değerle de değiştirilebilir.
Peki kullanırken neler oluyor?
Örnek bir kullanım ve etkileri şöyle:
1.	Deneme d = new Deneme();
2.	d.Genislik = 10; // set bölümü çalışır ve value'nin değeri 10 olur.
3.	int gen = d.Genislik; // get bölümü çalıştırılır ve genislik alanının değeri gelir.
4.	d.Genislik = 0; // set bölümü çalışır, hata verir.
-
Field:
class Person
{
 int age;
  	string name;
public void SayHi()
{
    	Console.WriteLine("Hi");
  }
}
The code above declares a class named Person, which has age and name fields as well as a SayHi method that displays a greeting to the screen.

Properties & Fields – Difference: 

class Person
{
private string name;   // field

public string Name    // property
{
get { return name; }
set { name = value; }
}
}
The property is accessed by its name, just like any other public member of the class.

-
-
Instance Variable
Instance variable nedir, instance variable nedir
Instance variables are non-static variables and are declared in a class but outside any method, constructor or block. As instance variables are declared in a class, these variables are created when an object of the class is created and destroyed when the object is destroyed. Unlike local variables, we may use access specifiers for instance variables.

Difference betwwen Instance variable & Static variable
Each object will have its own copy of instance variable whereas We can only have one copy of a static variable per class irrespective of how many objects we create.
Changes made in an instance variable using one object will not be reflected in other objects as each object has its own copy of instance variable. In the case of static, changes will be reflected in other objects as static variables are common to all object of a class.
We can access instance variables through object references and Static Variables can be accessed directly using class name.
In the life cycle of a class a static variable ie initialized one and only one time, whereas instance variables are initialized for 0 times if no instance is created and n times if n instances are created.
The Syntax for static and instance variables are :
 class Example
        {
            static int a; // static variable
            int b;        // instance variable
        }

In object-oriented programming with classes, an instance variable is a variable defined in a class (i.e. a member variable), for which each instantiated object of the class has a separate copy, or instance. An instance variable has similarities with a class variable[1], but is non-static. An instance variable is a variable which is declared in a class but outside of constructors, methods, or blocks. Instance variables are created when an object is instantiated, and are accessible to all the constructors, methods, or blocks in the class. Access modifiers can be given to the instance variable.
An instance variable is not a class variable although there are similarities. It is a type of class attribute (or class property, field, or data member). The same dichotomy between instance and class members applies to methods ("member functions") as well; a class may have both instance methods and class methods.
Each instance variable lives in memory for the life of the object it is owned by.
Variables are properties an object knows about itself. All instances of an object have their own copies of instance variables, even if the value is the same from one object to another. One object instance can change values of its instance variables without affecting all other instances. Instance variables can be used by all methods of a class unless the method is declared as static.

C# - Static Class, Methods, Constructors, Fields	      (GITHUB)  (test) 
Static nedir
-
Class members (variables, properties, methods) can also be declared as static. This makes those members belong to the class itself, instead of belonging to individual objects. No matter how many objects of the class are created, there is only one copy of the static member.
-
We can’t use this keyword inside the static function.
-
The Main method is static, as it is the starting point of any program. Therefore any method called directly from Main had to be static.

In C#, static means something which cannot be instantiated. You cannot create an object of a static class and cannot access static members using an object.
C# classes, variables, methods, properties, operators, events, and constructors can be defined as static using the static modifier keyword.
Static Class
Apply the static modifier before the class name and after the access modifier to make a class static. The following defines a static class with static fields and methods.
Example: C# Static Class
public static class Calculator
{
    private static int _resultStorage = 0;
    
    public static string Type = "Arithmetic";

    public static int Sum(int num1, int num2)
    {
        return num1 + num2;
    }

    public static void Store(int result)
    {
        _resultStorage = result;
    }
}
Above, the Calculator class is a static. All the members of it are also static.
You cannot create an object of the static class; therefore the members of the static class can be accessed directly using a class name like ClassName.MemberName, as shown below.
Example: Accessing Static Members
class Program
{
    static void Main(string[] args)
    {
        var result = Calculator.Sum(10, 25); // calling static method
        Calculator.Store(result); 

        var calcType = Calculator.Type; // accessing static variable
        Calculator.Type = "Scientific"; // assign value to static variable
    }
}

Rules for Static Class
1.	Static classes cannot be instantiated.
2.	All the members of a static class must be static; otherwise the compiler will give an error.
3.	A static class can contain static variables, static methods, static properties, static operators, static events, and static constructors.
4.	A static class cannot contain instance members and constructors.
5.	Indexers and destructors cannot be static
6.	var cannot be used to define static members. You must specify a type of member explicitly after the static keyword.
7.	Static classes are sealed class and therefore, cannot be inherited.
8.	A static class cannot inherit from other classes.
9.	Static class members can be accessed using ClassName.MemberName.
10.	A static class remains in memory for the lifetime of the application domain in which your program resides.
Static Members in Non-static Class
The normal class (non-static class) can contain one or more static methods, fields, properties, events and other non-static members.
It is more practical to define a non-static class with some static members, than to declare an entire class as static.
Static Fields
Static fields in a non-static class can be defined using the static keyword.
Definition - What does Static Field mean?
A static field is in programming languages is the declaration for a variable that will be held in common by all instances of a class. The static modifier determines the class variable as one that will be applied universally to all instances of a particular class. A final modifier can also be added to indicate that the class variable will not change.

A static field may also be called a class variable.
Techopedia explains Static Field
A static field or class variable is often contrasted with a non-static field, which can also be called an instance variable. This kind of more specialized variable applies to only one instance of a given class. For example, if an instance of the class "dog" received an instance variable "red," it would indicate that a particular dog is red, whereas a similarly applied class variable or static field would indicate that all dogs are red.

A static field or class variable is useful in certain programming languages and code situations to assign a particular variable (representing a common characteristic) to all instances of a class, either as a fixed value, or one that could change in the future. The key to this type of identifier is that if the change happens, it will be applied equally to all instances of the class.

Static fields of a non-static class is shared across all the instances. So, changes done by one instance would reflect in others.
Example: Shared Static Fields
public class StopWatch
{
    public static int InstanceCounter = 0;
    // instance constructor
    public StopWatch()
    {
    }
}

class Program
{
    static void Main(string[] args)
    {
        StopWatch sw1 = new StopWatch();
        StopWatch sw2 = new StopWatch();
        Console.WriteLine(StopWatch.NoOfInstances); //2 
			
        StopWatch sw3 = new StopWatch();
        StopWatch sw4 = new StopWatch();
        Console.WriteLine(StopWatch.NoOfInstances);//4
    }
}
Try it
Static Methods
You can define one or more static methods in a non-static class. Static methods can be called without creating an object. You cannot call static methods using an object of the non-static class.
The static methods can only call other static methods and access static members. You cannot access non-static members of the class in the static methods.
Example: Static Method
class Program
{
    static int counter = 0;
    string name = "Demo Program";

    static void Main(string[] args)
    {
        counter++; // can access static fields
        Display("Hello World!"); // can call static methods

        name = "New Demo Program"; //Error: cannot access non-static members
        SetRootFolder("C:\MyProgram"); //Error: cannot call non-static method
    }

    static void Display(string text)
    {
        Console.WriteLine(text);
    }

    public void SetRootFolder(string path) {  }
}
Rules for Static Methods
1.	Static methods can be defined using the static keyword before a return type and after an access modifier.
2.	Static methods can be overloaded but cannot be overridden.
3.	Static methods can contain local static variables.
4.	Static methods cannot access or call non-static variables unless they are explicitly passed as parameters.

Static Constructors
A non-static class can contain a parameterless static constructor. It can be defined with the static keyword and without access modifiers like public, private, and protected.
The following example demonstrates the difference between static constructor and instance constructor. (Aşağıdaki örnek çok faydalı, -- static constructor nedir)
Example: Static Constructor vs Instance Constructor
public class StopWatch
{
    // static constructor
    static StopWatch()
    {
        Console.WriteLine("Static constructor called");
    }

    // instance constructor
    public StopWatch()
    {
        Console.WriteLine("Instance constructor called");
    }

    // static method
    public static void DisplayInfo()
    {
        Console.WriteLine("DisplayInfo called");
    }

    // instance method
    public void Start() { }

    // instance method
    public void Stop() {  }
}
Try it
Above, the non-static class StopWatch contains a static constructor and also a non-static constructor.
The static constructor is called only once whenever the static method is used or creating an instance for the first time. The following example shows that the static constructor gets called when the static method called for the first time. Calling the static method second time onwards won't call a static constructor.
Example: Static Constructor Execution
StopWatch.DisplayInfo(); // static constructor called here
StopWatch.DisplayInfo(); // none of the constructors called here
Output:
Static constructor called.
DisplayInfo called
DisplayInfo called
The following example shows that the static constructor gets called when you create an instance for the first time.
Example: Static Constructor Execution
StopWatch sw1 = new StopWatch(); // First static constructor and then instance constructor called 
StopWatch sw2 = new StopWatch();// only instance constructor called 
StopWatch.DisplayInfo();
Output:
Static constructor called
instance constructor called
instance constructor called
DisplayInfo called
Rules for Static Constructors
1.	The static constructor is defined using the static keyword and without using access modifiers public, private, or protected.
2.	A non-static class can contain one parameterless static constructor. Parameterized static constructors are not allowed.
3.	Static constructor will be executed only once in the lifetime. So, you cannot determine when it will get called in an application if a class is being used at multiple places.
4.	A static constructor can only access static members. It cannot contain or access instance members.
-
-

C# - Static Class, Methods, Constructors, Fields	      (GITHUB)  (test) 
Static nedir, static field nedir, static class nedir
Static field:
A static field is in programming languages is the declaration for a variable that will be held in common by all instances of a class. The static modifier determines the class variable as one that will be applied universally to all instances of a particular class. A final modifier can also be added to indicate that the class variable will not change.

A static field may also be called a class variable.
-
In C#, static means something which cannot be instantiated. You cannot create an object of a static class and cannot access static members using an object.
C# classes, variables, methods, properties, operators, events, and constructors can be defined as static using the static modifier keyword.
Static Class
Apply the static modifier before the class name and after the access modifier to make a class static. The following defines a static class with static fields and methods.
Example: C# Static Class
public static class Calculator
{
    private static int _resultStorage = 0;
    
    public static string Type = "Arithmetic";

    public static int Sum(int num1, int num2)
    {
        return num1 + num2;
    }

    public static void Store(int result)
    {
        _resultStorage = result;
    }
}
Above, the Calculator class is a static. All the members of it are also static.
You cannot create an object of the static class; therefore the members of the static class can be accessed directly using a class name like ClassName.MemberName, as shown below.
Example: Accessing Static Members
class Program
{
    static void Main(string[] args)
    {
        var result = Calculator.Sum(10, 25); // calling static method
        Calculator.Store(result); 

        var calcType = Calculator.Type; // accessing static variable
        Calculator.Type = "Scientific"; // assign value to static variable
    }
}
Try it

Rules for Static Class
1.	Static classes cannot be instantiated.
2.	All the members of a static class must be static; otherwise the compiler will give an error.
3.	A static class can contain static variables, static methods, static properties, static operators, static events, and static constructors.
4.	A static class cannot contain instance members and constructors.
5.	Indexers and destructors cannot be static
6.	var cannot be used to define static members. You must specify a type of member explicitly after the static keyword.
7.	Static classes are sealed class and therefore, cannot be inherited.
8.	A static class cannot inherit from other classes.
9.	Static class members can be accessed using ClassName.MemberName.
10.	A static class remains in memory for the lifetime of the application domain in which your program resides.
Static Members in Non-static Class
The normal class (non-static class) can contain one or more static methods, fields, properties, events and other non-static members.
It is more practical to define a non-static class with some static members, than to declare an entire class as static.
Static Fields
Static fields in a non-static class can be defined using the static keyword.
Static fields of a non-static class is shared across all the instances. So, changes done by one instance would reflect in others.
Example: Shared Static Fields
public class StopWatch
{
    public static int InstanceCounter = 0;
    // instance constructor
    public StopWatch()
    {
    }
}

class Program
{
    static void Main(string[] args)
    {
        StopWatch sw1 = new StopWatch();
        StopWatch sw2 = new StopWatch();
        Console.WriteLine(StopWatch.NoOfInstances); //2 
			
        StopWatch sw3 = new StopWatch();
        StopWatch sw4 = new StopWatch();
        Console.WriteLine(StopWatch.NoOfInstances);//4
    }
}
Try it

You can define one or more static methods in a non-static class. Static methods can be called without creating an object. You cannot call static methods using an object of the non-static class.
The static methods can only call other static methods and access static members. You cannot access non-static members of the class in the static methods.
Example: Static Method
class Program
{
    static int counter = 0;
    string name = "Demo Program";

    static void Main(string[] args)
    {
        counter++; // can access static fields
        Display("Hello World!"); // can call static methods

        name = "New Demo Program"; //Error: cannot access non-static members
        SetRootFolder("C:\MyProgram"); //Error: cannot call non-static method
    }

    static void Display(string text)
    {
        Console.WriteLine(text);
    }

    public void SetRootFolder(string path) {  }
}
Rules for Static Methods
1.	Static methods can be defined using the static keyword before a return type and after an access modifier.
2.	Static methods can be overloaded but cannot be overridden.
3.	Static methods can contain local static variables.
4.	Static methods cannot access or call non-static variables unless they are explicitly passed as parameters.
Static Constructors
A non-static class can contain a parameterless static constructor. It can be defined with the static keyword and without access modifiers like public, private, and protected.
The following example demonstrates the difference between static constructor and instance constructor. (Aşağıdaki örnek çok faydalı, -- static constructor nedir)
Example: Static Constructor vs Instance Constructor
public class StopWatch
{
    // static constructor
    static StopWatch()
    {
        Console.WriteLine("Static constructor called");
    }

    // instance constructor
    public StopWatch()
    {
        Console.WriteLine("Instance constructor called");
    }

    // static method
    public static void DisplayInfo()
    {
        Console.WriteLine("DisplayInfo called");
    }

    // instance method
    public void Start() { }

    // instance method
    public void Stop() {  }
}
Try it

Above, the non-static class StopWatch contains a static constructor and also a non-static constructor.
The static constructor is called only once whenever the static method is used or creating an instance for the first time. The following example shows that the static constructor gets called when the static method called for the first time. Calling the static method second time onwards won't call a static constructor.
Example: Static Constructor Execution
StopWatch.DisplayInfo(); // static constructor called here
StopWatch.DisplayInfo(); // none of the constructors called here
Output:
Static constructor called.
DisplayInfo called
DisplayInfo called
The following example shows that the static constructor gets called when you create an instance for the first time.
Example: Static Constructor Execution
StopWatch sw1 = new StopWatch(); // First static constructor and then instance constructor called 
StopWatch sw2 = new StopWatch();// only instance constructor called 
StopWatch.DisplayInfo();
Output:
Static constructor called
instance constructor called
instance constructor called
DisplayInfo called
Rules for Static Constructors
1.	The static constructor is defined using the static keyword and without using access modifiers public, private, or protected.
2.	A non-static class can contain one parameterless static constructor. Parameterized static constructors are not allowed.
3.	Static constructor will be executed only once in the lifetime. So, you cannot determine when it will get called in an application if a class is being used at multiple places.
4.	A static constructor can only access static members. It cannot contain or access instance members.
-
-

C# - Static Class, Methods, Constructors, Fields	      (GITHUB)  (test) 
Static nedir, static field nedir, static class nedir
Static field:
A static field is in programming languages is the declaration for a variable that will be held in common by all instances of a class. The static modifier determines the class variable as one that will be applied universally to all instances of a particular class. A final modifier can also be added to indicate that the class variable will not change.

A static field may also be called a class variable.
-
In C#, static means something which cannot be instantiated. You cannot create an object of a static class and cannot access static members using an object.
C# classes, variables, methods, properties, operators, events, and constructors can be defined as static using the static modifier keyword.
Static Class
Apply the static modifier before the class name and after the access modifier to make a class static. The following defines a static class with static fields and methods.
Example: C# Static Class
public static class Calculator
{
    private static int _resultStorage = 0;
    
    public static string Type = "Arithmetic";

    public static int Sum(int num1, int num2)
    {
        return num1 + num2;
    }

    public static void Store(int result)
    {
        _resultStorage = result;
    }
}
Above, the Calculator class is a static. All the members of it are also static.
You cannot create an object of the static class; therefore the members of the static class can be accessed directly using a class name like ClassName.MemberName, as shown below.
Example: Accessing Static Members
class Program
{
    static void Main(string[] args)
    {
        var result = Calculator.Sum(10, 25); // calling static method
        Calculator.Store(result); 

        var calcType = Calculator.Type; // accessing static variable
        Calculator.Type = "Scientific"; // assign value to static variable
    }
}
Try it

Rules for Static Class
1.	Static classes cannot be instantiated.
2.	All the members of a static class must be static; otherwise the compiler will give an error.
3.	A static class can contain static variables, static methods, static properties, static operators, static events, and static constructors.
4.	A static class cannot contain instance members and constructors.
5.	Indexers and destructors cannot be static
6.	var cannot be used to define static members. You must specify a type of member explicitly after the static keyword.
7.	Static classes are sealed class and therefore, cannot be inherited.
8.	A static class cannot inherit from other classes.
9.	Static class members can be accessed using ClassName.MemberName.
10.	A static class remains in memory for the lifetime of the application domain in which your program resides.
Static Members in Non-static Class
The normal class (non-static class) can contain one or more static methods, fields, properties, events and other non-static members.
It is more practical to define a non-static class with some static members, than to declare an entire class as static.
Static Fields
Static fields in a non-static class can be defined using the static keyword.
Static fields of a non-static class is shared across all the instances. So, changes done by one instance would reflect in others.
Example: Shared Static Fields
public class StopWatch
{
    public static int InstanceCounter = 0;
    // instance constructor
    public StopWatch()
    {
    }
}

class Program
{
    static void Main(string[] args)
    {
        StopWatch sw1 = new StopWatch();
        StopWatch sw2 = new StopWatch();
        Console.WriteLine(StopWatch.NoOfInstances); //2 
			
        StopWatch sw3 = new StopWatch();
        StopWatch sw4 = new StopWatch();
        Console.WriteLine(StopWatch.NoOfInstances);//4
    }
}
Try it

Static Methods
You can define one or more static methods in a non-static class. Static methods can be called without creating an object. You cannot call static methods using an object of the non-static class.
The static methods can only call other static methods and access static members. You cannot access non-static members of the class in the static methods.
Example: Static Method
class Program
{
    static int counter = 0;
    string name = "Demo Program";

    static void Main(string[] args)
    {
        counter++; // can access static fields
        Display("Hello World!"); // can call static methods

        name = "New Demo Program"; //Error: cannot access non-static members
        SetRootFolder("C:\MyProgram"); //Error: cannot call non-static method
    }

    static void Display(string text)
    {
        Console.WriteLine(text);
    }

    public void SetRootFolder(string path) {  }
}
Rules for Static Methods
1.	Static methods can be defined using the static keyword before a return type and after an access modifier.
2.	Static methods can be overloaded but cannot be overridden.
3.	Static methods can contain local static variables.
4.	Static methods cannot access or call non-static variables unless they are explicitly passed as parameters.
Static Constructors
A non-static class can contain a parameterless static constructor. It can be defined with the static keyword and without access modifiers like public, private, and protected.
The following example demonstrates the difference between static constructor and instance constructor. (Aşağıdaki örnek çok faydalı, -- static constructor nedir)
Example: Static Constructor vs Instance Constructor
public class StopWatch
{
    // static constructor
    static StopWatch()
    {
        Console.WriteLine("Static constructor called");
    }

    // instance constructor
    public StopWatch()
    {
        Console.WriteLine("Instance constructor called");
    }

    // static method
    public static void DisplayInfo()
    {
        Console.WriteLine("DisplayInfo called");
    }

    // instance method
    public void Start() { }

    // instance method
    public void Stop() {  }
}
Try it

Above, the non-static class StopWatch contains a static constructor and also a non-static constructor.
The static constructor is called only once whenever the static method is used or creating an instance for the first time. The following example shows that the static constructor gets called when the static method called for the first time. Calling the static method second time onwards won't call a static constructor.
Example: Static Constructor Execution
StopWatch.DisplayInfo(); // static constructor called here
StopWatch.DisplayInfo(); // none of the constructors called here
Output:
Static constructor called.
DisplayInfo called
DisplayInfo called
The following example shows that the static constructor gets called when you create an instance for the first time.
Example: Static Constructor Execution
StopWatch sw1 = new StopWatch(); // First static constructor and then instance constructor called 
StopWatch sw2 = new StopWatch();// only instance constructor called 
StopWatch.DisplayInfo();
Output:
Static constructor called
instance constructor called
instance constructor called
DisplayInfo called
Rules for Static Constructors
1.	The static constructor is defined using the static keyword and without using access modifiers public, private, or protected.
2.	A non-static class can contain one parameterless static constructor. Parameterized static constructors are not allowed.
3.	Static constructor will be executed only once in the lifetime. So, you cannot determine when it will get called in an application if a class is being used at multiple places.
4.	A static constructor can only access static members. It cannot contain or access instance members.
-
-
-
Static class		 (GITHUB)		(read)
Static class örnek, static class nedir, list oluşturma, list nedir, static nedir
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    public class Student
    {
        public int Id;
        public string Name;
    }
 
    //static class'ın member'ları da static olmalıdır
    public static class CreateStudents
    {
        //public string SampleProperty { get; set; } //hata verir, static olmalıdır
        public static string SampleProperty { get; set; }
 
        //public void Create() //hata verir, static olmalıdır
        public static List<Student> StudentsList { get; set; } = new List<Student>
        {
            new Student()
            {
                Id = 1,
                Name = "Ali"
            },
            new Student()
            {
                Id = 2,
                Name = "Ahmet"
            },
            new Student()
            {
                Id = 3,
                Name = "Veli"
            }
        };
    }
 
    static void Main()
    {
        var studentsQuery =
            from s in CreateStudents.StudentsList
            where s.Id > 1
            select s;
 
        foreach (var item in CreateStudents.StudentsList)
        {
            Console.WriteLine(item.Name);
        }
 
        Console.WriteLine("--");
 
        foreach (var item in studentsQuery)
        {
            Console.WriteLine(item.Id);
        }
    }
}

Static Class (GITHUB)
Static class nedir
A static class is a class which can not be instantiated. We do not need to create an object of a static class like we did in non-static classes. Members of static classes can be accessed directly using the class name followed by a (.) and class member name. Class Members can be methods, fields, properties, or events. A static class can contain only the static members while a non-static class can contain static members. Also, Static classes are by-default sealed so they cannot be inherited.

To declare a class and its members as static, 'static' keyword are used as shown below,
1.	using System;  
2.	  
3.	namespace Tutpoint  
4.	{  
5.	    // Static class  
6.	    static class TutLovers  
7.	    {  
8.	        // Static Variable  
9.	        public static int val_Static;  
10.	  
11.	        // Static Method  
12.	        public static void Addition_Static()  
13.	        {  
14.	            Console.Write("Static Method");  
15.	        }  
16.	  
17.	        // Static property  
18.	        public static int Addition_NonStatic  
19.	        {  
20.	            get; set;  
21.	        }  
22.	    }  
For more understanding see the example shown below,

The example shown below contains two non-static classes named "TutLovers" and "TutHaters". Here a class "TutLovers" contains static as well as non-static methods and variable. When we access them from class "TutHaters" then, For the static members, they will be accessed directly using class name followed by (.) and
For non-static members, we have created an object of that class.


1.	using System;  
2.	  
3.	namespace Tutpoint  
4.	{  
5.	    class TutLovers  
6.	    {  
7.	        public static int val_Static;  
8.	  
9.	        public int val_NonStatic;  
10.	  
11.	        public static void Addition_Static()  
12.	        {  
13.	            Console.Write("Static Method");  
14.	        }  
15.	  
16.	        public void Addition_NonStatic()  
17.	        {  
18.	            Console.Write("Non-Static Method");  
19.	        }  
20.	    }  
21.	  
22.	    //If the class is non-static  
23.	    class TutHaters  
24.	    {  
25.	        public void Haters()  
26.	        {  
27.	            //Object of TutLovers class is created  
28.	            TutLovers tutLovers = new TutLovers();  
29.	  
30.	            //Non-Static members can be called only from object  
31.	            tutLovers.Addition_NonStatic();  
32.	            tutLovers.val_NonStatic = 5;  
33.	  
34.	            //Static members can only be called using class_name followed by a (.)  
35.	            TutLovers.Addition_Static();  
36.	            TutLovers.val_Static = 5;  
37.	  
38.	            /* When we try to access static member from object then it will create an error  
39.	            Error as "Members 'TutLovers.Addition_Static()' can not be accessed with an instance referen            -ce; qualify it with a type name instead" */
40.	            tutLovers.Addition_Static();  
41.	  
42.	            /* When we try to access non-static member using class_name then it will create an error  
43.	            Error as "An object reference is required for the non-static field                                      , method or property 'TutLovers.Addition_NonStatic()'" */
44.	            TutLovers.Addition_NonStatic();  
45.	        }  
46.	    }  
47.	  
48.	}  
As shown above, when we try to access static member with an instance reference, it will create an error as "Members 'TutLovers.Addition_Static()' can not be accessed with an instance reference; qualify it with a type name instead" and when we try to access non-static member using class_name then it will create an error as "An object reference is required for the non-static field, method or property 'TutLovers.Addition_NonStatic()'".

Static Method nedir? (GITHUB)
Static method nedir

A static method in C# is a method that keeps only one copy of the method at the Type level, not the object level. That means, all instances of the class share the same copy of the method and its data. The last updated value of the method is shared among all objects of that Type. 

Static methods are called by using the class name, not the instance of the class. 
 
The Console class and its Read and Write methods are an example of static methods. The following code example calls Console.WriteLine and Console.ReadKey methods without creating an instance of the Console class. 
C# supports two types of class methods, static methods, and non static methods. Any normal method is a non static method. 
1.	class Program  
2.	{  
3.	    public static void withoutObj()  
4.	    {  
5.	        Console.WriteLine("Hello");  
6.	    }  
7.	     static void Main()  
8.	    {  
9.	        Program. withoutObj();  
10.	        Console.ReadKey();  
11.	    }  
12.	}  

Using Static Method
Usually we define a set of data members for a class and then every object of that class will have a separate copy of each of those data members. Let's have an example.
1.	class Program  
2.	  {  
3.	      public int myVar;  //a non-static field  
4.	        static void Main()  
5.	      {  
6.	          Program p1 = new Program();  //a object of class  
7.	          p1.myVar = 10;  
8.	          Console.WriteLine(p1.myVar);  
9.	          Console.ReadKey();  
10.	      }  
11.	  }  
In the above example, myVar is a non-static field so to use this field we first need to create the object of that class. On the other hand, static data is shared among all the objects of that class. That is, for all the objects of a class, there will be only one copy of static data. Let's have an example.
1.	class Program  
2.	 {  
3.	     public static int myVar;  //a static field  
4.	       static void Main()  
5.	     {  
6.	         //Program p1 = new Program();  //a object of class  
7.	         myVar = 10;  
8.	         Console.WriteLine(myVar);  
9.	         Console.ReadKey();  
10.	     }  
11.	 }  
In the above we don't have an object of the class to use that field since the field is static.
If you create your own class and you think only one copy of the data (method) is needed among all instances of the class, you can create your own static method.  Learn more here: Static Class  and Static Class Members In C#
Notable Points here are:
1.	A static method can be invoked directly from the class level
2.	A static method does not require any class object
3.	Any main() method is shared through the entire class scope so it always appears with static keyword.
C# language also has several other types of methods. Read more Types of Methods in C#.



 
The Console class is also an example of a static class. We use its static WriteLine() method to output to the screen, or the static ReadLine() method to get user input. 
The Convert class used to convert value types is also a static class.
-
-
-
-

Instance Method = Non Static Method (GITHUB)
Instance method nedir, instance method nedir, non static method nedir, non-static method nedir
Instance method bildiğin class'ın instance'ının sahip olduğu, bildiğimiz metodlardır. Static olmayan, bildiğimiz klasik metotlar.
Static Method	Non Static Method (Instance Method)
1. Static method is defined with the static keyword.	1. Non Static Method is defined without static keyword.
2. Static method is called by its class name	2. Non Static Method is called by making the object of a class.
3. We can’t use this keyword inside the Static Method	3. We can use thiskeyword inside Non Static Method
4. Static Method uses the memory of Class	4. Non Static Method uses a memory of an object

Instance method are methods which require an object of its class to be created before it can be called. To invoke a instance method, we have to create an Object of the class in within which it defined.
public void geek(String name)
{
 // code to be executed....
}
// Return type can be int, float String or user defined data type.
Memory allocation: These methods themselves are stored in Permanent Generation space of heap but the parameters (arguments passed to them) and their local variables and the value to be returned are allocated in stack. They can be called within the same class in which they reside or from the different classes defined either in the same package or other packages depend on the access type provided to the desired instance method.

Important Points:
•	Instance method(s) belong to the Object of the class not to the class i.e. they can be called after creating the Object of the class.
•	Every individual Object created from the class has its own copy of the instance method(s) of that class.
•	Instance methods are not stored on a per-instance basis, even with virtual methods. They’re stored in a single memory location, and they only “know” which object they belong to because the this pointer is passed when you call them.
•	They can be overridden since they are resolved using dynamic binding at run time. (dynamic binding'in runtime'da yapıldığını öğrenmiştik. metoda verilen argument'lerin zaten runtime'da değiştirilebildiğini biliyoruz.Yani buradan zaten bu sonuca kendimiz de varabiliriz: Bu bir Dynamic Binding olayıdır.


When to use static methods ??
•	When you have code that can be shared across all instances of the same class, put that portion of code into static method.
•	They are basically used to access static field(s) of the class.

 Instance method vs Static method
•	Instance method can access the instance methods and instance variables directly.
•	Instance method can access static variables and static methods directly.
•	Static methods can access the static variables and static methods directly.
•	Static methods can’t access instance methods and instance variables directly. They must use reference to object. And static method can’t use this keyword as there is no instance for ‘this’ to refer to.
References
•	https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html
•	Stackoverflow
This article is contributed by Nitsdheerendra. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Daha fazla:
Instance methods in a class can make use of any of the public or private static data that belongs to that class.  (They can also make use of static data from other classes, provided that it is accessible).
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
	public class Dog
{
    // Instance Properties
    public string Name { get; set; }
    public int Age { get; set; }
 
    // Static property
    public static Dog LastGuyThatBarked { get; protected set; }
 
    // Public static data
    public readonly static string TheDogMotto = "Man's Best Friend";
 
    // Private static data
    private static int TotalNumDogs = 0;
 
    public Dog(string name, int age)
    {
        Name = name;
        Age = age;
        TotalNumDogs++;
    }
 
    public void Bark()
    {
        Console.WriteLine("{0} says Woof", Name);
 
        // Access static property
        Dog.LastGuyThatBarked = this;
 
        // Access static data
        Console.WriteLine("There are {0} total dogs", Dog.TotalNumDogs);
        Console.WriteLine("Remember our motto: {0}", Dog.TheDogMotto);
    }
}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
	public class Dog
{
    // Instance Properties
    public string Name { get; set; }
    public int Age { get; set; }
 
    // Static property
    public static Dog LastGuyThatBarked { get; protected set; }
 
    // Public static data
    public readonly static string TheDogMotto = "Man's Best Friend";
 
    // Private static data
    private static int TotalNumDogs = 0;
 
    public Dog(string name, int age)
    {
        Name = name;
        Age = age;
        TotalNumDogs++;
    }
 
    public void Bark()
    {
        Console.WriteLine("{0} says Woof", Name);
 
        // Access static property
        Dog.LastGuyThatBarked = this;
 
        // Access static data
        Console.WriteLine("There are {0} total dogs", Dog.TotalNumDogs);
        Console.WriteLine("Remember our motto: {0}", Dog.TheDogMotto);
    }
}
#284 – Static Methods Can Call Instance Methods
MARCH 28, 2011 1 COMMENT
Static methods can call instance methods in a class–provided that they have access to a reference to an instance of the class.
In the example below, we have a static method of the Dog class that dumps out a bunch of information about every Dog instance in a collection of dogs passed to it.
1
2
3
4
5
6
7
8
9
10
11
12
13
14	public static void ListDogs(List<Dog> dogList, Cat cat)
{
    foreach (Dog d in dogList)
    {
        string likes = d.LikesCat(cat) ? "Yes" : "No";
 
        Console.WriteLine("{0}: {1} yrs old.  Motto is [{2}]. Likes {3}? {4}",
            d.Name,
            d.Age,
            d.Motto,
            cat.Name,
            likes);
    }
}
Note that the static Dog method can also call an instance method of the Cat class.
Here’s how we might call this method:
1
2
3
4
5
6
7
8
9	List<Dog> dogs = new List<Dog>();
 
dogs.Add(new Dog("Kirby", 14, "Chase balls"));
dogs.Add(new Dog("Jack", 17, "Lounge around house"));
dogs.Add(new Dog("Ruby", 1, "Stare out window"));
 
Cat morris = new Cat("Morris");
 
Dog.ListDogs(dogs, morris);
Output:
 
FILED UNDER METHODS TAGGED WITH C#, INSTANCE METHODS, METHODS, STATIC METHODS
#283 – Instance Methods Can Call Static Methods
MARCH 27, 2011 LEAVE A COMMENT
Instance methods in a class can access static data or call static methods.  The instance method accesses static data or methods in the same way that other code does–by using the class name to qualify the data or method name.
Here’s an example, where the Dog.Bark instance method makes use of the private static Dog.FormatTheCreed method:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15	// Static property -- one value for all dogs
public static string Creed { get; set; }
 
// Private static method to format our Dog creed
private static string FormatTheCreed()
{
    return string.Format("As dogs, we believe: {0}", Dog.Creed);
}
 
// Instance method, in which a Dog barks
public void Bark()
{
    // Dump out my name and the universal Dog creed.
    Console.WriteLine("{0}: 'Woof'!  (Creed: [{1}])", this.Name, Dog.FormatTheCreed());
}
Calling the Bark method:
1
2
3
4
5	// Set static property
Dog.Creed = "We serve man";
 
Dog kirby = new Dog("Kirby");
kirby.Bark();
 
#238 – Call a Method from Another Method
You can call an instance method of a class from another instance method within that class.  The second method called will execute upon the same instance of the class for which the first method was called.
In the example below, we can call the Dog.Growl method, or the Dog.BarkAndGrowl method which in turn calls Growl.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16	public class Dog
{
    public string Name;
    public int Age;
 
    public void BarkAndGrowl()
    {
        Console.WriteLine("Woof.  --{0}", Name);
        Growl();
    }
 
    public void Growl()
    {
        Console.WriteLine("Grrr.  --{0}", Name);
    }
}
Here’s an example of calling these methods on an instance of the Dog class.
1
2
3
4
5	Dog kirby = new Dog();
kirby.Name = "Kirby";
 
kirby.Growl();      // Grrr.
kirby.BarkAndGrowl();  // Woof.  Grrr.
-

Static 
[member nedir, static nedir, class member nedir, static field nedir, static fields nedir]

A static class is basically the same as a non-static class, but there is one difference: a static class cannot be instantiated. In other words, we cannot use the new keyword to create a variable of the class type. Because there is no instance variable, we access the members of a static class by using the class name itself.
 
-
MSDN Definition - A static class is basically the same as a non-static class, but there is one difference: a static class cannot be instantiated. In other words, we cannot use the new keyword to create a variable of the class type. Because there is no instance variable, we access the members of a static class by using the class name itself.
C# fields must be declared inside a class. However, if we declare a method or a field as static, we can call the method or access the field by using the name of the class. No instance is required. We can also use the static keyword when defining a field. With this feature, we can create a single field that is shared among all objects created from a single class. Non-static fields are local to each instance of an object.
When you define a static method or field, it does not have access to any instance fields defined for the class; it can use only fields that are marked as static. Furthermore, it can directly invoke only other methods in the class that are marked as static; nonstatic (instance) methods or fields must first create an object on which to call them. 

Look at the example given below,
1.	using System;  
2.	using System.Collections.Generic;  
3.	using System.Text;   
4.	namespace TestiClass  
5.	{  
6.	   class Program  
7.	   {  
8.	       int val = 20;  
9.	       static void Main(string[] args)  
10.	       {  
11.	           Program x = new Program();  
12.	           int newval = x.val;  
13.	           Console.WriteLine(newval);  
14.	           Console.ReadKey();  
15.	       }  
16.	   }  
17.	}  
In the above example, we have a non-static field named val. From the main method (static method), I'm trying to access that field and to do this I need to create the instance of the class inside the main method (static method) because the static method only accesses the static fields and val is not static here. So, to access this I have created an instance (named x) of Program class that has val field and then assigned the val to newval field inside static main method. This is really cumbersome to do. To fix the inconvenience, C# uses static fields. Let's take a look at the use of static here.
Look at the example given below,
1.	using System;  
2.	using System.Collections.Generic;  
3.	using System.Text;   
4.	namespace TestiClass  
5.	{  
6.	   class Program  
7.	   {  
8.	       static int val = 20;  
9.	       static void Main(string[] args)  
10.	       {  
11.	           Console.WriteLine(val);  
12.	           Console.ReadKey();  
13.	       }  
14.	   }  
15.	}  
Try to compare both examples, you will see the difference. Here we have not used any instance of class inside static main method. This is the use of static fields in our application. We will talk about static methods in the next post.
HAPPY CODING!!

It is also applicable to properties, event, and operators. To create a static member(class, variable, methods, constructor), precede its declaration with the keyword static. When a member is declared static, it can be accessed with the name of its class directly.
-
-
Static Variable nedir
Bu ilginç. Çünkü class içinde variable olmuyor diye biliyorum. Class içinde int i; yazdığımızda variable değil field oluşturmuş oluyoruz. Peki static variable ne?
Static Variables and Static Methods
Each object has its own set of member variables and all the member variables have a scope.

If we want a variable to have the same value throughout all instances of the object then we can declare it as a static variable in our program. To manipulate and use the values of static variables we can also define a function as static.

The keyword "static" means that only one instance of a given variable exists for a class. Static variables are used to define constants because their values can be retrieved by invoking the class without creating an instance of it.

(Static variable nedir)
Static variables can be initialized outside the member function or class definition. The following code is an example of a static variable, which shows the declaration and initialization of a static variable.
1.	using System;  
2.	namespace staticexample  
3.	{  
4.	    class Program  
5.	    {  
6.	        public static int i;  
7.	        public static void display()  
8.	        {  
9.	            i=10;  
10.	            Console.WriteLine(i);  
11.	        }  
12.	        public void demo()  
13.	        {  
14.	            int j=20;  
15.	            Console.WriteLine(j);  
16.	        }  
17.	  
18.	   
19.	        static void Main(string[] args)  
20.	        {  
21.	            Program obj = new Program();  
22.	            Program.display();  
23.	            obj.demo();  
24.	            Console.Read();  
25.	        }  
26.	    }  
27.	}
Here we have not used an instance of the class for the static method display(). However, for the nonstatic demo() method we need the instance of the class to call it. This is how to call static and non-static methods.
Note

Unlike other member variables, only one copy of the static variable exists in memory for all the objects of that class. Therefore, all objects share one copy of the static variable in memory.
-

Static Class
A static class is declared with the help of static keyword. A static class can only contain static data members, static methods, and a static constructor. It is not allowed to create objects of the static class. Static classes are sealed, means one cannot inherit a static class from another class.
-
-
The static method is defined with a static keyword as I have defined below. The static method uses class memory rather than an object. Static Method is called by class name. We can call a non-static function in static function by making an object of the class. We can’t use this keyword inside the static function.
-
Statik method içinde instance method çağırılmaz. Örnek:
using System;

class Program
{
    static void Main()
    {
        string name = "Mark";
        var date = DateTime.Now;

        // Composite formatting:
        Console.WriteLine("Hello, {0}! Today is {1}, it's {2:HH:mm} now.", name, date.DayOfWeek, date);
        // String interpolation:
        Console.WriteLine($"Hello, {name}! Today is {date.DayOfWeek}, it's {date:HH:mm} now.");
        // Both calls produce the same output that is similar to:
        // Hello, Mark! Today is Wednesday, it's 19:40 now.
    }

    class SampleClass
    {
        int instanceField;
        static int staticField;

        public void InstanceMethod()
        {
            Console.WriteLine(instanceField);
            Console.WriteLine(staticField); 
        }

        public static void StaticMethod()
        {
        }

        public static void StaticMethod2()
        {
            Console.WriteLine(instanceField); // Hata! Static metot, instance field'ı çağıramıyor! 
            Console.WriteLine(staticField); // Hata yok. Static method static field'ı çağırdı.

            //InstanceMethod(); // Hata! Statik metotta sadece statik metotlar çağırılabilir.
            StaticMethod(); // Hata yok.
        }
    }
}
-
-

MSDN’den Farklı bir anlatımla:
A class or struct may have instance fields or static fields or both. Instance fields are specific to an instance of a type. If you have a class T, with an instance field F, you can create two objects of type T, and modify the value of F in each object without affecting the value in the other object. By contrast, a static field belongs to the class itself, and is shared among all instances of that class. Changes made from instance A will be visibly immediately to instances B and C if they access the field.
-
Constant members are static by definition.

class MathClass
            {
                public const int ONE = 1;
            }
            static void Main(string[] args)
            {
                Console.Write(MathClass.ONE);
            }
            //Outputs 1

As you can see, we access the property ONE using the name of the class, just like a static member. This is because all const members are static by default.

Constructors can be declared static to initialize static members of the class.
The static constructor is automatically called once when we access a static member of the class.
For example:

class SomeClass 
        {
            public static int X { get; set; }
            public static int Y { get; set; }

            static SomeClass() // constructor
            {
                X = 10;
                Y = 20;
            }
        }

        static void Main()
        {
            Console.WriteLine(SomeClass.X);
            Console.WriteLine(SomeClass.Y);
            Console.ReadKey();
        }

The constructor will get called once when we try to access SomeClass.X or SomeClass.Y.
-
-
-
-
There are a number of useful static methods and properties available in Cy#: 
Örneğin: Math.PI  (PI bir Field’dir. Metod değildir. Çünkü bir metod, parametrelerine aldığı argümanlara göre istenilen işlemleri yaparak çeşitli sonuçlar dönderir. Lakin bildiğimiz üzere PI sayisi sabit bir değerdir (3.14) ve Math.PI komutunun da PI sayısını dönderdiğini biliyoruz. Bu durumda görüyoruz ki, burada çeşitli işlemler yapılmamakta, sürekli sabit bir değer dönderilmektedir. Alınan herhangi bir parametre yoktur, çeşitlilik yoktur: sonuç hep aynıdır. (Ve sonucun hep aynı olması, hiçbir zaman değiştirilemiyor olması da bize bu member’in bir constant olduğu ipucunu verir. Buradan da doğal olarak şu sonuç çıkar: Constant member’lar doğal olarak statik olmalıdır, çünkü değerleri değişmemektedir. Değerleri değişmiyorsa neden objelere ait olsun ki? Constant members are static by definition)
Math.PI’nin bir metod değil de bir field  olduğunu şuradan da anlayabiliriz ki: Parantez bulundurmamaktadır. Zira bir member’in parantez bulundurması demek, parametre ve dolayısıyla argüman bulundurması demektir. Bu da zaten member’in bir field olmadığını; aksine bir metod olduğunu gösterir.
(member: class’ın üyelerinden herhangi birisi ‘member’ olarak nitelendirilir. Yani property, field, metod gibi öğeler, bir class’ın member’leridir.)

            Math.PI       //Field   //the constant PI.
            Math.E        //Field   //represents the natural logarithmic base e.
            Math.Max();   //Method  //returns the larger of its two arguments.
            Math.Min();   //Method  //returns the smaller of its two arguments.
            Math.Abs();   //Method  //returns the absolute value of its argument.
            Math.Sin();   //Method  //returns the sine of the specified angle.
            Math.Cos();   //Method  //returns the cosine of the specified angle.
            Math.Pow();   //Method  //returns a specified number raised to the specified power.
            Math.Round(); //Method  //rounds the decimal number to its nearest integral value.
            Math.Sqrt();  //Method  //returns the square root of a specified number. 
[class ve method nedir, class ve metod nedir]
-
-
Static Fields/Properties vs. Instance Fields/Properties	(örnek) (örnek)
static fields nedir, instance fields nedir, Instance fields nedir, Instance properties nedir instance properties nedir, instance property nedir, Instance property nedir, static property nedir, static properties nedir, backing field nedir
Field'in bir diğer adı da Backing Field'dir!

 
Classes and structures can contain, among other types of members, fields and properties. In this post I’ll focus on field and property members and explain the difference between instance fields/properties and static fields/properties. Before reading further here’s a short video on the topic:

The Purpose of Fields and Properties

Fields are used to store object state data, and properties are used to set and query object state data. An instance field stores state data for individual objects, that is, every object of a particular type will have its very own copy of any and all instance fields defined for that class or structure type. A static field stores state data for all instances of the type. In other words, a static field’s value is shared by all instances of the type. Let’s take a look at an example.

using System;

public class Employee {
  //Instance Fields 
  private string _firstName; 
  private string _middleName; 

  //Instance Properties 
  public string FirstName {
    get {return _firstName;} 
    set {_firstName = value;} 
  } 

  public string MiddleName {
    get {return _middleName;}
    set {_middleName = value;}
  } 

  public string LastName {
    get;
    set;
  }

  //Static Properties 
  public static int Count {
    get; 
    private set; 
  } 

 //Constructors 
 public Employee(string firstName, string middleName, string lastName){
   _firstName = firstName; 
   _middleName = middleName; 
   LastName = lastName; 
   Employee.Count++; 
 } 

 public Employee():this("John", "J", "Doe"){}

 //Overridden Object Methods 
 public override string ToString(){
   return _firstName + " " + _middleName + " " + LastName; 
 } 
}

Referring to the Employee class – I’ve defined two private fields _firstName and _middleName. These explicit field definitions are used as backing fields (bildiğin field'in diğer adı) for the FirstName and MiddleName public properties, as you can clearly see from the code. If you use fields in this manner, there’s no need to explicitly declare them. Simply use Auto-Implemented properties as I’ve done with the LastName property. As their name implies, auto-Implemented properties automatically create the backing field behind the scenes. This reduces the amount of boilerplate code you need to write.  I’ve mixed the two styles in this example for demonstration purposes.
The Count property is a static, class-wide property declared with the help of the static keyword. I increment this value whenever an employee object is created. Note that you must access static properties via the class name.
Lastly, in this example I have overridden the Object.ToString() method.  To demonstrate this code I’ll need another class that implements a Main() method.
using System;

public class MainApp {
  public static void Main(){
   Employee e1 = new Employee();
   Employee e2 = new Employee("Rick", "W", "Miller");
   Console.WriteLine(e1); 
   Console.WriteLine(e2); 
   Console.WriteLine(Employee.Count); 
  }
}
Referring to the MainApp class – I create two instances of Employee testing both versions of the constructor. I then write their values to the console and then, with the help of the static Employee. Count property, I write the number of employee objects created. Figure 1 shows the results of running this program.
-
-
-
Soru: Project naming conventions: [Company].[ProjectName] vs [Company_ProjectName] [closed]
Ask Question

Most of the solutions I came across follow the following convention:
CompanyName.SolutionName.LayerName
So basically in a company named COMP and a Project Named StackOverflow, you would end up with a project that looks like this:
COMP.StackOverflow.Business
COMP.StackOverflow.Data
COMP.StackOverflow.Web
COMP.StackOverflow.Core

This allows you to easily manage the generated assembly, so if you need to create a common library to be used in your company. You would name it:
COMP.SomeFrameworkName;
That would easily seperate your company's (or Team's) Dlls from external Dlls and Nuget Packages.

Stack      (GITHUB)
Stack Nedir

        void f()
        {
            int x = 123; // <- located in stack
        }

        int x; // <- located in heap
        void f()
        {
            x = 123
        }



Videoyu izle: https://www.youtube.com/watch?v=HlzAtIHFRk0
 
Resmi incele.

Value type olanlar (örneğin int) ---> Stack içinde saklanır.
Pointer'lar da Stack içinde saklanır.
Ama objeler Heap içinde saklanır.

Yani neymiş, örneğin Report report = new Report(); deyince; buradaki report, (YANİ OBJE DEĞİL, POINTER!) -- STACK içinde tutuluyor. AMA report aracılığıyla üretilen yeni OBJE HEAP'TE TUTULUYOR. Güzel bilgi bu… 
Dikkat et… report dediğin şey bir pointer'dir, objenin kendisi değildir. Inıtialize yapıyorsan bu pointer gidip bir OBJE üretecektir. Ama kendisi, yani report, o yeni üretilen objeye işaret eden bir pointer'dir.

Report report2 = report; deyince görüldüğü üzere yeni bir obje üretmedik. Zaten initialization olmadığı belli… new Report(); deyip constructor çalıştırmadık veya bir property'sine bir değer atamadık. Yani yeni bir obje oluşmamış oldu. Yani aynı referansı tutuyor report ile…..

Stack
Stack nedir

Stack bir data tipidir; ama abstract bir data tipidir.

In computer science, a stack is an abstract data type that serves as a collection of elements, with two principal operations:
•	push, which adds an element to the collection, and
•	pop, which removes the most recently added element that was not yet removed.
 
Örnek:

Stack myStack = new Stack();
myStack.Push("Hello!!");
myStack.Push(null);
myStack.Push(1);
myStack.Push(2);


https://www.tutorialsteacher.com/csharp/csharp-stack

 
-
Stack: The build-in data types, such as int and double, are used to declare variables that are value types. Their value is stored in memory in a location called the stack:
 

Heap: Reference types are stored in a part of the memory called the heap. (Reference types are used for storing objects. For example, when you create an object of a class, it is stored as a reference type.)
 
As you can see, the p1 object of type Person on the stack stores the memory address of the heap where the actual object is stored.
-
Reference Type: Reference types are used for storing objects. For example, when you create an object of a class, it is stored as a reference type.
Reference types are stored in a part of the memory called the heap.
When you instantiate an object, the data for that object is stored on the heap, while its heap memory address is stored on the stack.
That is why it is called a reference type - it contains a reference (the memory address) to the actual object on the heap.
- 
Heap & Stack –Explanation , Together:  Reference types are used for storing objects. For example, when you create an object of a class, it is stored as a reference type.
Reference types are stored in a part of the memory called the heap.
When you instantiate an object, the data for that object is stored on the heap, while its heap memory address is stored on the stack.
That is why it is called a reference type - it contains a reference (the memory address) to the actual object on the heap.
As you can see, the p1 object of type Person on the stack stores the memory address of the heap where the actual object is stored.
-
Stack      (GITHUB)
Stack Nedir

        void f()
        {
            int x = 123; // <- located in stack
        }

        int x; // <- located in heap
        void f()
        {
            x = 123
        }



Videoyu izle: https://www.youtube.com/watch?v=HlzAtIHFRk0
 
Resmi incele.

Value type olanlar (örneğin int) ---> Stack içinde saklanır.
Pointer'lar da Stack içinde saklanır.
Ama objeler Heap içinde saklanır.

Yani neymiş, örneğin Report report = new Report(); deyince; buradaki report, (YANİ OBJE DEĞİL, POINTER!) -- STACK içinde tutuluyor. AMA report aracılığıyla üretilen yeni OBJE HEAP'TE TUTULUYOR. Güzel bilgi bu… 
Dikkat et… report dediğin şey bir pointer'dir, objenin kendisi değildir. Inıtialize yapıyorsan bu pointer gidip bir OBJE üretecektir. Ama kendisi, yani report, o yeni üretilen objeye işaret eden bir pointer'dir.

Report report2 = report; deyince görüldüğü üzere yeni bir obje üretmedik. Zaten initialization olmadığı belli… new Report(); deyip constructor çalıştırmadık veya bir property'sine bir değer atamadık. Yani yeni bir obje oluşmamış oldu. Yani aynı referansı tutuyor report ile…..

Stack
Stack nedir

Stack bir data tipidir; ama abstract bir data tipidir.

In computer science, a stack is an abstract data type that serves as a collection of elements, with two principal operations:
•	push, which adds an element to the collection, and
•	pop, which removes the most recently added element that was not yet removed.
 
Örnek:

Stack myStack = new Stack();
myStack.Push("Hello!!");
myStack.Push(null);
myStack.Push(1);
myStack.Push(2);


https://www.tutorialsteacher.com/csharp/csharp-stack

 
-
Stack: The build-in data types, such as int and double, are used to declare variables that are value types. Their value is stored in memory in a location called the stack:
 

Heap: Reference types are stored in a part of the memory called the heap. (Reference types are used for storing objects. For example, when you create an object of a class, it is stored as a reference type.)
 
As you can see, the p1 object of type Person on the stack stores the memory address of the heap where the actual object is stored.
-
-
Reference Type: Reference types are used for storing objects. For example, when you create an object of a class, it is stored as a reference type.
Reference types are stored in a part of the memory called the heap.
When you instantiate an object, the data for that object is stored on the heap, while its heap memory address is stored on the stack.
That is why it is called a reference type - it contains a reference (the memory address) to the actual object on the heap.
- 

-
Heap & Stack –Explanation , Together:  Reference types are used for storing objects. For example, when you create an object of a class, it is stored as a reference type.
Reference types are stored in a part of the memory called the heap.
When you instantiate an object, the data for that object is stored on the heap, while its heap memory address is stored on the stack.
That is why it is called a reference type - it contains a reference (the memory address) to the actual object on the heap.
As you can see, the p1 object of type Person on the stack stores the memory address of the heap where the actual object is stored.
-
-
Heap & Stack –Difference:  Stack is used for static memory allocation, which includes all your value types, like x (see the picture above).
Heap is used for dynamic memory allocation, which includes custom objects, that might need additional memory during the runtime of your program.
-
-
Stack vs. Heap: What's the difference?
 
The Stack is more or less responsible for keeping track of what's executing in our code (or what's been "called").  The Heap is more or less responsible for keeping track of our objects (our data, well... most of it - we'll get to that later.).
 
Think of the Stack as a series of boxes stacked one on top of the next.  We keep track of what's going on in our application by stacking another box on top every time we call a method (called a Frame).  We can only use what's in the top box on the stack.  When we're done with the top box (the method is done executing) we throw it away and proceed to use the stuff in the previous box on the top of the stack. The Heap is similar except that its purpose is to hold information (not keep track of execution most of the time) so anything in our Heap can be accessed at  any time.  With the Heap, there are no constraints as to what can be accessed like in the stack.  The Heap is like the heap of clean laundry on our bed that we have not taken the time to put away yet - we can grab what we need quickly.  The Stack is like the stack of shoe boxes in the closet where we have to take off the top one to get to the one underneath it. 
The picture above, while not really a true representation of what's happening in memory, helps us distinguish a Stack from a Heap.

The Stack is self-maintaining, meaning that it basically takes care of its own memory management.  When the top box is no longer used, it's thrown out.  The Heap, on the other hand, has to worry about Garbage collection (GC) - which deals with how to keep the Heap clean (no one wants dirty laundry laying around... it stinks!).
 
What goes on the Stack and Heap?
 
We have four main types of things we'll be putting in the Stack and Heap as our code is executing: Value Types, Reference Types, Pointers, and Instructions. 
 
Value Types
 
In C#, all the "things" declared with the following list of type declarations are Value types (because they are from System.ValueType):
•	bool
•	byte
•	char
•	decimal
•	double
•	enum
•	float
•	int
•	long
•	sbyte
•	short
•	struct
•	uint
•	ulong
•	ushort
Reference Types
 
All the "things" declared with the types in this list are Reference types (and inherit from System.Object... except, of course, for object which is the System.Object object):
•	class
•	interface
•	delegate
•	object
•	string

Pointers
 
The third type of "thing" to be put in our memory management scheme is a Reference to a Type. A Reference is often referred to as a Pointer.  We don't explicitly use Pointers, they are managed by the Common Language Runtime (CLR). A Pointer (or Reference) is different than a Reference Type in that when we say something is a Reference Type is means we access it through a Pointer.  A Pointer is a chunk of space in memory that points to another space in memory.  A Pointer takes up space just like any other thing that we're putting in the Stack and Heap and its value is either a memory address or null. 


public void Method1()
{
    // Line 1
    int i=4;

    // Line 2
    int y=2;

    //Line 3
    class1 cls1 = new class1();
}

-
-

[data types nedir, data type nedir, data tipi nedir, data tipleri nedir]
C# mainly categorized data types in two types: Value types and Reference types. 
Value types include simple types (such as int, float, bool, and char), enum types, struct types, and Nullable value types. 
Reference types include class types, interface types, delegate types, and array types. Learn about value types and reference types in detail in the next chapter.
 

-
- 
[heap nedir, stack nedir, reference types nedir, reference type nedir]
(stack: Stock kelimesinden akla getirilebilir. Stok; yani standart olan şeyler… Yani tipik data tiplerini tutar (int, string vb). Lakin heap böyle çalışmaz.)
(Yine aynı fikirden yola çıkarsak… Stack öyle farklı farklı öğeler için farklı miktarlarda hafıza ayırmaz… Neden? Çünkü adı üstünde: O bir stock… Stock olan aynıdır, sabittir… Lakin heap’te durum böyle değildir. Detaylar için siyah yazıyı okuyunuz)
(Yine aynı fikirden; eğer stock denen şey farklı farklı hafıza tiplerini barındıracak güçte değilse; demek ki objeleri de barındıracak kapasitede olamayacaktır… Çünkü objelerin gerektirdiği hafıza miktarları değişken olacaktır haliyle… 
Bu durumda, objeler nereye gönderilir?? Tabi ki heap’e… Stack’ta ise sadece; gönderilmiş olan bu objeye işaret eden adres tutulur.
Gördüğümüz gibi; stock denen şey sabit, durağan.... Heap ise tam tersi… Yani heap dediğimiz şey, dynamic memory allocation için kullanılır, gördüğümüz gibi… Stack ise static memory allocation için kullanılır.)
 

Reference types are used for storing objects. For example, when you create an object of a class, it is stored as a reference type.
Reference types are stored in a part of the memory called the heap. 
When you instantiate an object, the data for that object is stored on the heap, while its heap memory address is stored on the stack.
That is why it is called a reference type - it contains a reference (the memory address) to the actual object on the heap.
As you can see, the p1 object of type Person on the stack stores the memory address of the heap where the actual object is stored.

Stack is used for static memory allocation, which includes all your value types, like x.
Heap is used for dynamic memory allocation, which includes custom objects, that might need additional memory during the runtime of your program.
-
-
[heap nedir, stack nedir, reference types nedir, reference type nedir]
(stack: Stock kelimesinden akla getirilebilir. Stok; yani standart olan şeyler… Yani tipik data tiplerini tutar (int, string vb). Lakin heap böyle çalışmaz.)
(Yine aynı fikirden yola çıkarsak… Stack öyle farklı farklı öğeler için farklı miktarlarda hafıza ayırmaz… Neden? Çünkü adı üstünde: O bir stock… Stock olan aynıdır, sabittir… Lakin heap’te durum böyle değildir. Detaylar için siyah yazıyı okuyunuz)
(Yine aynı fikirden; eğer stock denen şey farklı farklı hafıza tiplerini barındıracak güçte değilse; demek ki objeleri de barındıracak kapasitede olamayacaktır… Çünkü objelerin gerektirdiği hafıza miktarları değişken olacaktır haliyle… 
Bu durumda, objeler nereye gönderilir?? Tabi ki heap’e… Stack’ta ise sadece; gönderilmiş olan bu objeye işaret eden adres tutulur.
Gördüğümüz gibi; stock denen şey sabit, durağan.... Heap ise tam tersi… Yani heap dediğimiz şey, dynamic memory allocation için kullanılır, gördüğümüz gibi… Stack ise static memory allocation için kullanılır.)
 

Reference types are used for storing objects. For example, when you create an object of a class, it is stored as a reference type.
Reference types are stored in a part of the memory called the heap. 
When you instantiate an object, the data for that object is stored on the heap, while its heap memory address is stored on the stack.
That is why it is called a reference type - it contains a reference (the memory address) to the actual object on the heap.
As you can see, the p1 object of type Person on the stack stores the memory address of the heap where the actual object is stored.

Stack is used for static memory allocation, which includes all your value types, like x.
Heap is used for dynamic memory allocation, which includes custom objects, that might need additional memory during the runtime of your program.
-
-
Reference Type, Value Type  	(GITHUB) (örnek)
Reference type nedir, Value type nedir,

-
-

The following data types are of reference type:
•	String
•	All arrays, even if their elements are value types
•	Class
•	Delegates

Reference types have null value by default, when they are not initialized.
There are two kinds of types in C#: reference types and value types. 
Variables of reference types store references to their data (objects), while variables of value types directly contain their data. With reference types, two variables can reference the same object; therefore, operations on one variable can affect the object referenced by the other variable. With value types, each variable has its own copy of the data, and it is not possible for operations on one variable to affect the other (except in the case of in, ref and out parameter variables; see in, ref and out parameter modifier).
The following keywords are used to declare reference types:
•	class
•	interface
•	delegate
C# also provides the following built-in reference types:
•	dynamic
•	object
•	string

new operator 

int myInt = new int(); // Invoked default constructor for int type.  
-
-
Reference Data Types : The Reference Data Types will contain a memory address of variable value because the reference types won’t store the variable value directly in memory. The built-in reference types are string, object.

Value Data Types : In C#, the Value Data Types will directly store the variable value in memory and it will also accept both signed and unsigned literals. The derived class for these data types are System.ValueType. Following are different Value Data Types in C# programming language:…
Value Type VALUE TUTAR. Adı üstünde… Başka da bişey tutmaz. Yani sadece Value alacak… 0,1,2,3 gibi…
Reference Type da reference tutar. Adı üstünde. Yani referansını tutar…
Initialize etmediğimiz bir int değeri olsun;
Int newInt;
Bu obje'nin bu haldeki değeri 0 olur.Null olmaz. Çünkü int'ler value type'dır ve value'den başka bir şey tutamaz. (Int, yukarıdaki haliyle null olamaz, bir int değeri null olabilmesi için int? şeklinde declare edilmelidir)
String asdf;
Bu ise Reference Type olduğu için null değere işaret eder. Yani değeri NULL olur. Çünkü String'ler Reference Type'dır. Bir değeri yoktur. Değeri olmayan bir verinin ADRESİNİ TUTAR. Adresini tuttuğu şeyin değeri yoktur şu anda (String asdf;). Bu yüzden bu string'in şu anki değeri NULL olur.
-
-
Reference Type örnek detaylı / Value Type Örnek Detaylı  (GITHUB)  (test)

[Reference Type nedir / Value Type nedir]

Aşağıdakilerden daha yeni olan örneğim:

using System;

namespace ConsoleAppErenOzten
{
    public class Program
    {
        public static void Main()
        {
            int int0;
            int0 = 0; // metot içinde bu int değeri değiştirildi. Ama buradaki değişken bundan etkilenmedi.

            string str0;
            str0 = "str0"; // metot içinde bu int değeri değiştirildi. Ama buradaki değişken bundan etkilenmedi.

            var sampleClass = new SampleClass();
            sampleClass.Number = 0; // metot içinde bu int değeri değiştirildi. Ve bu objenin property'leri bundan etkilendi!
            sampleClass.Text = "eskiText"; // metot içinde bu int değeri değiştirildi. Ve bu objenin property'leri bundan etkilendi!

            sampleClass.Change(int0, str0, sampleClass);
            Console.WriteLine(Convert.ToString(int0), str0, sampleClass.Number, Convert.ToString(sampleClass.Number));
        }

        public class SampleClass
        {
            public int Number { get; set; }
            public string Text { get; set; }

            public void Change(int int1, string str1, SampleClass sampleClass)
            {
                int1 = 1;
                str1 = "str1";
                sampleClass.Number = 1;
                sampleClass.Text = "yeniText";
            }
        }
    }
}
	
-
//String'ler value type gibi davranır! Referance Type olduğu halde…

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp1
{
    class Program
    {
        static void ChangeReferenceType(string str3)
        {
            str3 = "Text 3";
        }

        static void ChangeReferenceType(int int3)
        {
            int3 = 3;
        }

        static void ChangeReferenceType(Student student3)
        {
            student3.Name = "Student 3 Name";
        }

        static void ChangeReferenceType(Array array2)
        {
            array2 = null;
        }

        public class Student
        {
            public string Name { get; set; }
        }

        static void Main(string[] args)
        {
            string str1 = "Text 1";
            string str2 = str1;

            ChangeReferenceType(str1);

            Console.WriteLine(str1); //Text 1
            Console.WriteLine(str2); //Text 1
            //metot içindeki değişim durumu değiştirmedi. Çünkü değişkenlerin Ram lokasyonları farklı. 

            str1 = "Text 2";

            Console.WriteLine(str1); //Text 2
            Console.WriteLine(str2); //Text 1
            Console.WriteLine("---");
            //str1 = "Text 2" eşitliği; str2 nin değerini değiştirmedi. Çünkü yukarıda belirtildiği üzere; değişkenlerin Ram lokasyonları farklı.

            //string'in data type'ı --> REFERENCE TYPE'dır. VALUE TYPE DEĞİLDİR.
            //Tanım: Eğer bir data type; kendi VALUE'sini RAM'in özel bir lokasyonunda tutuyorsa o bir VALUE TYPE'dır. (Yani referans değil; value tutar RAM'de)
            //Value Type bir değişkeni bir metoda gönderirsek; değişkenin değerinin KOPYASI GÖNDERİLİR. Yani bu metod; bu değişkenin değerini değiştiremez, sadece kendi metodu içinde o yeni değeri kullanabilir; eski değeri yine eski değişkende kalır. DEĞİŞMEZ.

            //Örnekte görüldüğü üzere string -> Ram lokasyununa referans yapmadı.
            //Onun yerine değerini kopyaladı. Böylelikle kendi değeri değişmemiş oldu.
            //Sonuç: String, bir 'reference type' tan olan bir data type olmasına rağmen bir value type gibi davrandı (örneğin integer gibi)

            //String'ler value type gibi davranır!


            int int1 = 1;
            int int2 = int1; // int2’nin değeri asla int1 ile aynı lokasyona bakmaz Ram üzerinde. Bu satırda olan şey; int1’in değeri olan 1, int2 ye eşitlendi. Buradaki eşitliğin değişken bazlı olmadığına dikkat ediniz. Olan şeyin asla değişkenler ile ilişkisi yok, sadece sayısal olan 1 değeriyle ilişkisi var. Sayısal olan 1 değeri int1 sayesinde kopyalanmış oldu ve bu 1 değeri int2’ye verilmiş oldu.
            
            ChangeReferenceType(int1);

            Console.WriteLine(int1.ToString()); //1
            Console.WriteLine(int2.ToString()); //1

            int1 = 2;

            Console.WriteLine(int1.ToString()); //2
            Console.WriteLine(int2.ToString()); //1
            Console.WriteLine("---");

            //İnt1’in değerindeki değişim, int2 yi değiştirmedi.

            //İnteger: Ram lokasyonuna referans yapmadı. 
            //Kendi değerinini kopyaladı. Böylelikle kendi değeri değişmemiş oldu.
            //Sonuç: integer bir 'value type' olarak; beklendiği üzere RAM'de farklı lokasyonlara karşılık geliyor.



            Student student1 = new Student();
            student1.Name = "Student1 Name";

            Student student2 = student1;

            ChangeReferenceType(student1);

            Console.WriteLine(student1.Name); //Student 3 Name
            Console.WriteLine(student2.Name); //Student 3 Name
            Console.WriteLine("---");

            //Class: Data Type'ı REFERENCE TYPE'dır. 
            //Yani değeri değil ADRESİ gönderir. Bu durumda bir metoda bir değişken yollanırsa; değişkenin ADRESİ yollanır.
            //Yani iki değişken de RAM'de tek bir noktaya işaret ettiği için metoddaki işlem, değişkeni DEĞİŞTİRECEKTİR.



            string[] array1 = new string[3];
            array1[0] = "Data 1";
            array1[1] = "Data 2";
            array1[2] = "Data 3";

            Console.WriteLine(array1[0]); //Data 1
            Console.WriteLine(array1[1]); //Data 2
            Console.WriteLine(array1[2]); //Data 3

            //Array'lar da String'ler gibi çalıştığı için; doğal olarak onlar gibi davrandı.
            //Metod içindeki değişim asıl değişkeni değiştirmedi.

            ChangeReferenceType(array1);

            //integer: value type
            //string:  reference type
            //class:   reference type
            //array:   reference type



            string str10 = "String Ten";
            str10.ToUpper(); //str10'un bu noktadaki değeri = "STRING TEN"

            Console.WriteLine(str10); //String Ten

            //Görüldüğü üzere ToUpper metodunda oluşan değer bizim değişkenimiz üzerine kaydedilmedi. Neden?
            //Çünkü string = Reference Type olduğu halde bir Value Type'mış gibi davranır ve RAM üzerinde ADRESLEME değil KOPYALAMA yapar.
            //Yani toUpper metodu yeni bir string değişkeni yarattı (string'in yeni bir instance'ını oluşturdu ve bu instance'ı dönderdi: dolayısıyla RAM'da farklı bir lokasyonda bulunuyor) ve bunun değerini "STRING TEN" olarak belirledi.
            //Ama bu işlem bizim str10 değişkenimiz üzerinde bir değişime sebep olmadı. Çünkü onun RAM'deki lokasyonu farklı.

            //O halde; ToUpper metodundan çıkan sonucu kullanmak istiyorsak; yeni bir değişken oluşturup sonucu buna yazdırmamız gerekir:

            string str20 = str10.ToUpper();

            Console.WriteLine(str20); //STRING TEN

            //Sonuç: String sanıldığı gibi bir VALUE TYPE değildir. REFERENCE TYPE'dır ama VALUE TYPE gibi davranır.

            Console.ReadKey();
        }
    }
}

-
-
-
A data type is a value type if it holds a data value within its own memory space. It means variables of these data types directly contain their values.
All the value types derive from System.ValueType, which in-turn, derives from System.Object.

For example, consider integer variable int i = 100;
The system stores 100 in the memory space allocated for the variable 'i'. The following image illustrates how 100 is stored at some hypothetical location in the memory (0x239110) for 'i':
 


•	bool
•	byte
•	char
•	decimal
•	double
•	enum
•	float
•	int
•	long
•	sbyte
•	short
•	struct
•	uint
•	ulong
•	ushort


Passing by Value:

When you pass a value type variable from one method to another method, the system creates a separate copy of a variable in another method, so that if value got changed in the one method won't affect on the variable in another method.

Bir önceki başlığı düşünelim. Neydi? Value type; hafızada kendi noktasını oluşturuyordu. 
Passing by Value yapıyorsak: bu durumda yeni değişken de hafızada kendi noktasını oluşturur.
Yani örneğin bir integer i’nin başlangıçta 100 olan değerini; bu değişkeni başka bir metod içine yollayıp orada int x olarak bu değeri alıp 200 e eşitlersek;
i’in asıl değeri değişmez: 100 olarak kalır:

static void ChangeValue(int x)
{
    x =  200;

    Console.WriteLine(x);
}

static void Main(string[] args)
{
    int i = 100;

    Console.WriteLine(i);
    
    ChangeValue(i);
    
    Console.WriteLine(i);
}



Biraz anlam karmaşası oluyor.. :

Data type’I    Value Type olan bir data (örneğin integer):
Hafızada kendi lokasyonunu oluşturuyor ve buradaki değeri tutuyor. Adresi değil.

Ama Passing By Value işleminde kendi hafıza lokasyonunu gösteren bir adresi yollamıyor. Value’yi yolluyor (örneğin integer = 3 ise 3 değerini yolluyor. Kendi hafıza lokasyonuyla hiçbi ilgisi yok.).

Value type => adreslemeyle ilgisi yok diye aklımızda tutabiliriz. Kendi lokasyonunu tutuyor hafızada.
Ve passing by value işlemi yapılırken de aynı şekilde; adresleme falan yok. Yani VALUE varsa ADRES YOK. Kendi öz lokasyonu var.

Class’ın bir objesini pass yaptığımız zaman adresi tuttuğu için ikisini de değiştirdi.
Ama String için aynı şey olmadı wtf?

Class’ın passing işlemi için yazılan şu: (örneği için aşağıya in: reference type konusu)
 since Student is an object, when we send the Student object std1 to the ChangeReferenceType() method, what is actually sent is the memory address of std1. Thus, when the ChangeReferenceType() method changes StudentName, it is actually changing StudentName of std1, because std1 and std2 are both pointing to the same address in memory. Therefore, the output is Steve.

Reference Type
Unlike value types, a reference type doesn't store its value directly. Instead, it stores the address where the value is being stored. In other words, a reference type contains a pointer to another memory location that holds the data.
For example, consider following string variable:
string s = "Hello World!!";
The following image shows how the system allocates the memory for the above string variable.
 



The following data types are of reference type:
•	String
•	All arrays, even if their elements are value types
•	Class
•	Delegates

static void ChangeReferenceType(Student std2)
{
    std2.StudentName = "Steve";
}

static void Main(string[] args)
{
    Student std1 = new Student();
    std1.StudentName = "Bill";
    
    ChangeReferenceType(std1);

    Console.WriteLine(std1.StudentName);
}

Output:
Steve

In the above example, since Student is an object, when we send the Student object std1 to the ChangeReferenceType() method, what is actually sent is the memory address of std1. Thus, when the ChangeReferenceType() method changes StudentName, it is actually changing StudentName of std1, because std1 and std2 are both pointing to the same address in memory. Therefore, the output is Steve.

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace _1_EmptyConsoleApp
{
    class Program
    {
        public class Sample
        {
            public int ReturnInt()
            {
                return 5;
            }
        }

        static void Main()
        {
            Stack stack = new Stack();

            stack.Push("1 İhsan");
            Console.WriteLine("Peeking: " + stack.Peek());
                                        
            stack.Push("2 Apo");        
            Console.WriteLine("Peeking: " + stack.Peek());
                                        
            stack.Push("3 Muro");       
            Console.WriteLine("Peeking: " + stack.Peek());
                                        
            stack.Push("4 Ramo");       
            Console.WriteLine("Peeking: " + stack.Peek());
            
            stack.Push("5 Michael (son kişi)");
            Console.WriteLine("Popping: " + stack.Pop());
            Console.WriteLine("Peeking: " + stack.Peek());

            Console.WriteLine("Counting: " + stack.Count); // görüldüğü 
            // üzere () parantezleri yok. Yani Count
            // bir metot değil property'dir.

            Console.WriteLine(stack.Contains("1 İhsan"));
            Console.WriteLine(stack.Contains("1 İhsannnnnn"));

            var kopyalanmisStack = stack.Clone();

            // ÖNEMLİ, ŞUNA DİKKAT:
            // debug esnasında stack değişkeninin üzerine gelirsek:
            // görürüz ki: 
            // stack[0] = ilk eklediğimiz veri değil.
            // son eklediğimiz veri...

            stack.Clear(); // tüm verileri siler.
            Console.WriteLine("Counting: " + stack.Count); // şu an
            // 0 döner. Veri yok çünkü.

            var asd = stack.AsQueryable();
        }
    }

}

-
-
-
HTTPGet vs HTTPPost	(GITHUB) (örnek)
Httpget nedir httppost nedir
https://www.youtube.com/watch?v=Un2JTC7tFPI
The data sent to the server with POST is stored in the request body of the HTTP request.
Videoyu izle…
Get yapınca veriler url ye yazılır. Post ta ise form yollanır… Url ile yollanmaz veri. Message body içinde yollanır.
Get metotlara url'ye yazıp enter yaparak ulaşılır. O yüzden tehlikeli olabilir…
DB'deki değerleri hem Get hem Post ile değiştirebiliriz tabi ki. Ama dediğimiz gibi get ile bunu yapmak tehlikelidir.
HTTPPost method hides information from URL and does not bind data to URL. It is more secure than HttpGet method but it is slower than HttpGet. It is only useful when you are passing sensitive information to the server.
The GET Method
GET is used to request data from a specified resource. 
GET is one of the most common HTTP methods. 
Note that the query string (name/value pairs) is sent in the URL of a GET request: 
/test/demo_form.php?name1=value1&name2=value2
Some other notes on GET requests: 
GET requests can be cached
GET requests remain in the browser history
GET requests can be bookmarked
GET requests should never be used when dealing with sensitive data
GET requests have length restrictions
GET requests are only used to request data (not modify)

The POST Method
POST is used to send data to a server to create/update a resource. 
The data sent to the server with POST is stored in the request body of the HTTP request: 
POST /test/demo_form.php HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
(yukarıda request body'nin neye benzediğini görmüş olduk. Get request'lerde request body yoktur. Veri url'den gönderilir)
Some other notes on POST requests:
POST requests are never cached
POST requests do not remain in the browser history
POST requests cannot be bookmarked
POST requests have no restrictions on data length

GET methodu HTTP istekleri arasındaki varsayılan yöntemdir.  GET metodu ile yapılan istekler tarayıcının adres satırında görünür. Sadece belirli boyutta veri gönderileceği zaman kullanılır.
POST metodu ise URL’ de görünmesini istemediğimiz veriler olduğunda kullanılabilir. POST yönteminde gönderebileceğimiz verinin boyutu ile ilgili bir sınır yoktur. Ayrıca gönderdiğimiz parametrelerin adres satırında görünmemesi dolayısıyla GET yöntemine göre daha güvenlidir. HTML form gönderileceği zaman neredeyse her zaman POST yöntemi tercih edilir.
Örnek vermek gerekirse Kisilers tablomuzun olduğu bir proje üzerinde kişi bilgilerini düzenlemek isteyebiliriz. Bunun için genellikle iki Action oluştururuz. Bunlardan biri kişinin ID sini parametre olarak alan gelen ID ye göre kişinin bilgilerini Edit formunda açan Action iken diğeri POST olduğunda yani Kaydet butonuna tıklandığında kullanılacak Actiondur.

public ActionResult Edit(int? id)
{
if (id == null)
{  return new HttpStatusCodeResult(HttpStatusCode.BadRequest);  } 
Kisiler kisiler = db.Kisilers.Find(id);
if (kisiler == null) 
{
return HttpNotFound();
}
return View(kisiler);
} 
Yukarıdaki Action’ da querystring’imiz kisa iken aşağıdakinde Kisilers tablosundaki kolon sayısına göre uzunluğu değişecek bir querystring söz konusu. Ayrıca buradan dönen bilgilerinde adres çubuğunda görünmesini istemediğimiz için POST methodunu kullanırız.

Önemli:
Browsers can cache GET requests, generally on static data, like images or scripts. But you can also allow browsers to cache GET requests to controller actions as well, using [OutputCache] or other similar ways, so if caching is turned on for a GET controller action, it's possible that clicking on a link leading to /Home/Index doesn't actually run the Index method on the server, but rather allows the browser to serve up the page from its own cache.
With this line of thinking, you can safely turn on caching on GET actions in which the data you're serving up doesn't change (or doesn't change often), with the knowledge that your server action won't fire every time.
POSTs won't be cached by the browser, so any POST is guaranteed to make it to the server.
Güzel bir açıklama:
Ignore caching for a moment. Another way of thinking about this is that search engines will store HTTP GET links during their indexing/crawling process, therefore they will show up in search results.
Suppose if your /Home/Index is implemented as GET but it lets say deletes a row in your Database, every time this link shows up on a search engine and somebody clicks it, you will have a delete row, and soon you have a lot deleted rows.

Implicit	      (GITHUB)  (test) 
Implicit nedir, implicit nedir, explicit nedir
(Implicit: dolaylı yoldan, yani direkt olarak DEĞİL / suggested, not directly expressed.)
(explicit: stated clearly and in detail, leaving no room for confusion or doubt.)
Java üzerinden açıklamış, güzel: 
Explicit means done by the programmer. Implicit means done by the JVM or the tool , not the Programmer.
For Example: Java will provide us default constructor implicitly.Even if the programmer didn't write code for constructor, he can call default constructor.
Explicit is opposite to this , ie. programmer has to write.
-
-
-
class Program
{
    static void Main()
    {
        // Aşağıdaki kod hata üretir!
        //Implicitly-typed variables must be initialized.
        // Hata ne yapmamızı istiyor? Initialize etmemizi istiyor Implicitly-typed variable'ı. Yani -> var degisken = 5; gibi
        var degisken;
        degisken = "2";
    }
}



Implicitly typed variable: 
Variables declared using the var keyword are called implicitly typed variables.
Implicitly typed variables must be initialized with a value.
For example, the following program will cause an error: 
var num;
num = 42;
-
-
Instantiation	 	(GITHUB)  (test)
Instantiation nedir, instantiation nedir initialization nedir, , declaration nedir, declare nedir
This is when memory is allocated for an object. (variable değil!) This is what the new keyword is doing. A reference to the object that was created is returned from the new keyword.
Instantiation is used to create an object from a class (instantiate).
Syntax:
objectName = new className(parameters);
-
-
-
Instantiation vs Initialization	 	(GITHUB)  (test)
Instantiation nedir, instantiation nedir, initialization nedir, Initialization nedir

To initialize something is to set it to its initial value. To instantiate something is to create an instance of it.
-
Here I will explain difference between initialization and instantiation in c#, vb.net with example or instantiation vs initialization in asp.net or how to instantiate and initialize a class in asp.net using c#, vb.net with example. In c# or vb.net instantiation means declaring object for class and initialization means assigning values to variables or setting initial values.

(instance nedir)
(instance: an instance is a concrete occurrence of any object, existing usually during the runtime of a computer program. Formally, "instance" is synonymous with "object" as they are each a particular value (realization), and these may be called an instance object; "instance" emphasizes the distinct identity of the object. The creation of an instance is called instantiation.)
(instance’ın kelime anlamına baktığımızda zaten anlıyoruz ki; instance bir class’a aittir. Çünkü instance şeyin “örneği” demektir. C# veya OOP’de neyin bir “örneği” olur? Tabi ki class’ın…  
(instance kelime anlamı: an example or single occurrence of something. Örnek Cümle: "a serious instance of corruption")
(initialization şuradan akla getirilebilir -> Gene kelime anlamına bakalım: 
Anlam: of or at the beginning:
“My initial surprise was soon replaced by delight.”
Anlam: the first letter of a name, especially when used to represent the whole name:
“He wrote his initials, P.M.R., at the bottom of the page.”




1) Instantiation nedir, instantiation nedir initialization nedir, , declaration nedir, declare nedir



