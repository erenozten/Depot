2021 - REPETITION!
-
-
-
-
-
-
To make sure that database connections are properly closed and the resources they hold freed up, you have to dispose the context instance when you are done with it. That is why the scaffolded code provides a Dispose method at the end of the StudentController class in StudentController.cs, as shown in the following example: 
protected override void Dispose(bool disposing)
{
    db.Dispose();
    base.Dispose(disposing);
}

If you don't specify a connection string or the name of one explicitly, Entity Framework assumes that the connection string name is the same as the class name. The default connection string name in this example would then be SchoolContext, the same as what you're specifying explicitly.
The name of the connection string (which you'll add to the Web.config file later) is passed in to the constructor.
public SchoolContext() : base("SchoolContext")
{
}
-
-
-
-
-
-
BOŞ		(bosch)	 (bosch)
ne nedir
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Delete(int id)
{
    try
    {
        Student student = db.Students.Find(id);
        db.Students.Remove(student);
        db.SaveChanges();
    }
    catch (DataException/* dex */)
    {
        //Log the error (uncomment dex variable name and add a line here to write a log.
        return RedirectToAction("Delete", new { id = id, saveChangesError = true });
    }
    return RedirectToAction("Index");
}
This code retrieves the selected entity, then calls the Remove method to set the entity's status to Deleted. When SaveChanges is called, a SQL DELETE command is generated. You have also changed the action method name from DeleteConfirmed to Delete. The scaffolded code named the HttpPost Delete method DeleteConfirmed to give the HttpPost method a unique signature. (The CLR requires overloaded methods to have different method parameters.) Now that the signatures are unique, you can stick with the MVC convention and use the same name for the HttpPost and HttpGet delete methods.
If improving performance in a high-volume application is a priority, you could avoid an unnecessary SQL query to retrieve the row by replacing the lines of code that call the Find and Remove methods with the following code:
C#Copy
Student studentToDelete = new Student() { ID = id };
db.Entry(studentToDelete).State = EntityState.Deleted;
This code instantiates a Student entity using only the primary key value and then sets the entity state to Deleted. That's all that the Entity Framework needs in order to delete the entity.
-
-
-
A query string is the portion of a URL where data is passed to a web application and/or back-end database. The reason we need query strings is that the HTTP protocol is stateless by design. For a website to be anything more than a brochure, you need to maintain state (store data). 
There are a number of ways to do this: On most web servers, you can use something like session state server-side. On the client, you can store via cookies. Or in the URL, you can store data via a query string. 

On the world wide web, all URLs can be broken down into the protocol, the location of the file (or program) and the query string. The protocol you see in a browser is almost always HTTP; the location is the typical form of the hostname and filename (for example, www.techopedia.com/somefile.html), and the query string is whatever follows the question mark sign ("?").
For example, in the URL below, the bolded area is the query string that was generated when the term "database" was searched on the Techopedia website.
//www.techopedia.com
-
-
-
-
-
-
HTTPPost method hides information from URL and does not bind data to URL. It is more secure than HttpGet method but it is slower than HttpGet. It is only useful when you are passing sensitive information to the server.
-
-
-
-
-
-
A static class can contain only the static members while a non-static class can contain static members. Static classes are by-default sealed so they cannot be inherited.
-
-
-
-
-
-
MVC, server-side bir sistemdir. Server-side sistemlerde end-user sadece html-javascript i görebilir. Csharp koduna erişemez.
Mvc bir UI-centric bir sistem değil; Server side’dır. 
-
-
-
-
-
Önemli repository bilgi:
You could instantiate a new context in the repository, but then if you used multiple repositories in one controller, each would end up with a separate context. Later you'll use multiple repositories in the Course controller, and you'll see how a unit of work class can ensure that all repositories use the same context.
-
-
-
-
-
-
Kısayollar / Keyboard Shortcuts	(GITHUB) (asasas)
Kısayol nedir, shortcut nedir
-
f2 - değişkene yeni isim ver (sistemdeki hepsinin)
ctrl alt f9  - breakpoint’e götürüyo seni

Ctrl  backspace    kelimeyi siliyo tamamen sola doğru
Ctrl  delete kelimeyi olduğu gibi siliyor. Sağa doğru siliyor. // ctrl + backspace de sola  doğru siliyor

ctrl + shift + nokta -> aynı değişkenlerin tümünü aynı anda editleme imkanı sağlıyor. (bende çalışmıyo)

-
Chrome offers “F5” key and the “Ctrl+R” key combination are used to reload the currently open Web page. 
Chrome also offers the reload shortcut combinations of “Ctrl + F5” and “Ctrl + Shift + R” to reload the currently open page and override the locally cached version.
Having cursor in the address field and pressing ENTER will also do the same as CTRL + F5
-Home, end (numpad’dakiler) : satırın başına ve sonuna gider. (shift ile de kullanılır, yazıyı seçmek için...)

-Klavyenin üstündeki normal home end tuşları: sayfanın başına ve sonuna gider.

-Numpad’daki home end tuşları ctrl ile kullanıldığında, tıpkı klavyenin üstündeki home-end tuşları gibi çalışıyor. Yani klavyenin üstündeki home-end tuşlarını kullanmaya gerek yok gibi görünüyor.

-Ctrl – yön tuşları  kelimenin başına sonuna gidiyor atlayarak.

-Next Error (F2) (çalışmadı)

-Previous error (Shift + F2) ) (çalışmadı)

-Expand Selection (Ctrl + W)

-Ctrl + n  search everywhere (acayip bişey) / create new file

- alt + yukarı aşağı arrows  iki satırın yerini birbiri arasında değiştirme.

- shift + alt  veya sadece alt-> kare alan seçme (çoklu satır)

-
Don’t use anything in the cache when making the request. Forces the browser to re-download every JavaScript file, image, text file, etc.

Empty Cache and Hard Reload
Empty Cache and hard reload = Empty the cache and Force the browser do re-download every JavaScript file, image, text file, etc.
Chrome kısayol: 
Crtl+F5 or Shift+F5 -> re-download cached content (i.e. JavaScript files, images, etc…)
Normal Reload
F5 or Control + R = Reload the current page
“Ctrl+R” is the same thing as pressing f5. This will use the cache in every way possible. If the browser can avoid re-downloading JavaScript files, images, text files, etc. then it will.
Note: Having cursor in the address field and pressing ENTER will also do the same as CTRL + F5
Hard reload / Force Refresh
Control + Shift + R or Control + F5 or Shift + F5 = ignoring cached content
Obviously if the cache is empty then it will have to do a hard reload in order to load the required/support files again. This will again force the browser to re-download everything. However, if the page makes any after the fact downloads via JavaScript that weren’t part of page load, then these might still use the cache, which is where emptying the cache helps because it makes sure that even these won’t use cached files.

RESHARPER:

Ctrl + T

-

Step over code to skip functions
When you are on a line of code that is a function or method call, you can press F10(Debug > Step Over) instead of F11.


Advance the debugger out of the current function
Sometimes, you might want to continue your debugging session but advance the debugger all the way through the current function.
Press Shift + F11 (or Debug > Step Out).
This command resumes app execution (and advances the debugger) until the current function returns.
-
F10 vs F11
https://stackoverflow.com/questions/15584132/what-is-the-difference-between-f10-and-f11-keys-in-visual-studio/39843982
F10 ("step over") does not descend any further into the call stack. It moves to the next line of the current function.
F11 ("step into") drills down into the function being called.
void function1()
{
    function2();
    function3();
}
If you hit a breakpoint on function2(), F10 will advance to the line function3(). F11 will advance to the first line inside function2.
-

CHROME
CTRL + SHIFT + C --> konsolu açmadan (ters tıklayıp incele demeden) mause'un üstünde olduğu elementi seçiyor. Muhteşem.

RESHARPER
alt FL   SAVE

ALT WL    QUIT ALL

ctrl D	  copy paste

ctrl tab   açık dosyalar arası geçiş 
ismin adının üstüne gelip F2 -> ismi değiştirmek için (projenin tümünde her yerde değiştirmek için)

ctrl shift r  bir class'ı yeni bir folder'a taşı

ctrl W kopyalıyor bi üst element/metoda kadar. (geri almak için: ctrl shift W)

alt aşağı / yukarı   metodlar arası geçiş

ctrl B  class definition'una gitme (ctrl click ile aynı)


windows+ sağ yön tuşu (visual studio’yu ekranın sağına yapıştırıyor. Google chrome’u açıp sola bas, onu da sola yapıştır.

f3    search yapılan text'i ara (diğer satırlarda)

ctrl alt J     kelimeyi <tag> ile çevreleme

ctrl f12    sayfa içinde text ara

ctrl shift R   model'imizi farklı bir klasöre taşımak istiyorsak. (namespace'i de değiştiriyor, kolaylık sağlıyor)

windows + sağ sol yukarı yön tuşları: progrmı büyütme yana yatırma 

ctrl tab   sekmeler arası geçiş

ctrl r     kullanma. F5 ile aynı. Eğer tam refresh yapmak istiyorsan ctrl shift f5 yap.

alt enter (en alttaki seçenekten: sayfadaki aynı textlerin tümünü değiştirme)
-
ctrl f10 - cursor'ın olduğu yere kadar projeyi çalıştırır. Break point koymuşsun gibi.
-
-
HARD RELOAD – NORMAL RELOAD nedir
Normal reload
The same thing as pressing F5. This will use the cache but revalidate everything during page load, looking for "304 Not Modified" responses. If the browser can avoid re-downloading cached JavaScript files, images, text files, etc. then it will.
________________________________________
Hard reload
Don't use anything in the cache when making the request. (which is equal to SHIFT+F5 No need to open Developer console) Force the browser do re-download every JavaScript file, image, text file, etc.


Hard reload / Force Refresh
Control + Shift + R or Control + F5 or Shift + F5 = ignoring cached content
Obviously if the cache is empty then it will have to do a hard reload in order to load the required/support files again. This will again force the browser to re-download everything. However, if the page makes any after the fact downloads via JavaScript that weren’t part of page load, then these might still use the cache, which is where emptying the cache helps because it makes sure that even these won’t use cached files.
RESHARPER:

Ctrl + T

-

Step over code to skip functions
When you are on a line of code that is a function or method call, you can press F10(Debug > Step Over) instead of F11.


Advance the debugger out of the current function
Sometimes, you might want to continue your debugging session but advance the debugger all the way through the current function.
Press Shift + F11 (or Debug > Step Out).
This command resumes app execution (and advances the debugger) until the current function returns.
-
F10 vs F11
https://stackoverflow.com/questions/15584132/what-is-the-difference-between-f10-and-f11-keys-in-visual-studio/39843982
F10 ("step over") does not descend any further into the call stack. It moves to the next line of the current function.
F11 ("step into") drills down into the function being called.
void function1()
{
    function2();
    function3();
}
If you hit a breakpoint on function2(), F10 will advance to the line function3(). F11 will advance to the first line inside function2.
-

CHROME
CTRL + SHIFT + C --> konsolu açmadan (ters tıklayıp incele demeden) mause'un üstünde olduğu elementi seçiyor. Muhteşem.

RESHARPER
alt FL   SAVE

ALT WL    QUIT ALL

ctrl D	  copy paste

ctrl tab   açık dosyalar arası geçiş 
ismin adının üstüne gelip F2 -> ismi değiştirmek için (projenin tümünde her yerde değiştirmek için)

ctrl shift r  bir class'ı yeni bir folder'a taşı

ctrl W kopyalıyor bi üst element/metoda kadar. (geri almak için: ctrl shift W)

alt aşağı / yukarı   metodlar arası geçiş

ctrl B  class definition'una gitme (ctrl click ile aynı)


windows+ sağ yön tuşu (visual studio’yu ekranın sağına yapıştırıyor. Google chrome’u açıp sola bas, onu da sola yapıştır.

f3    search yapılan text'i ara (diğer satırlarda)

ctrl alt J     kelimeyi <tag> ile çevreleme

ctrl f12    sayfa içinde text ara

ctrl shift R   model'imizi farklı bir klasöre taşımak istiyorsak. (namespace'i de değiştiriyor, kolaylık sağlıyor)

windows + sağ sol yukarı yön tuşları: progrmı büyütme yana yatırma 

ctrl tab   sekmeler arası geçiş

ctrl r     kullanma. F5 ile aynı. Eğer tam refresh yapmak istiyorsan ctrl shift f5 yap.

alt enter (en alttaki seçenekten: sayfadaki aynı textlerin tümünü değiştirme)
-
ctrl f10 - cursor'ın olduğu yere kadar projeyi çalıştırır. Break point koymuşsun gibi.

-
-
-
-
-
Bildirim için aşağıdaki yapıyı kullandık.
 
Bildirim için inheritance da kullanılabilirdi. Ama mantıklı olmazdı. O yüzden yukarıdaki gibi yaptık. Aşağıdaki gibi YAPMADIK.
Mosh hamedani: Her halta inheritance uygulama. İnheritance şu durumlarda kullanılır: polimorfizm gerekiyorsa, ortada "behavior" varsa. Bunlar yoksa inheritance falan uygulama. Çünkü gereksiz olur. Boşuna complexity artırırsın. Kodun zorlaşır.
-
-
-
-
Integral to integral conversions
Integral conversions are implicit when the destination type can represent every possible
value of the source type. Otherwise, an explicit conversion is required. For
example:
int x = 12345; // int is a 32-bit integral
long y = x; // Implicit conversion to 64-bit integral
short z = (short)x; // Explicit conversion to 16-bit integral
A float can be implicitly converted to a double, since a double can represent every
possible value of a float. The reverse conversion must be explicit.
-
-
(okundu - github)
Remember, that an if can have zero or more else if's and they must come before the last else, which is optional.
Once an else if succeeds, none of the remaining else if's or else clause will be tested.
-
A do-while loop is similar to a while loop, except that a do-while loop is guaranteed to execute at least one time.
-
-
-
-
-

(okundu – github)
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Delete(int id)
{
    try
    {
        Student student = db.Students.Find(id);
        db.Students.Remove(student);
        db.SaveChanges();
    }
    catch (DataException/* dex */)
    {
        //Log the error (uncomment dex variable name and add a line here to write a log.
        return RedirectToAction("Delete", new { id = id, saveChangesError = true });
    }
    return RedirectToAction("Index");
}
This code retrieves the selected entity, then calls the Remove method to set the entity's status to Deleted. When SaveChanges is called, a SQL DELETE command is generated. You have also changed the action method name from DeleteConfirmed to Delete. The scaffolded code named the HttpPost Delete method DeleteConfirmed to give the HttpPost method a unique signature. (The CLR requires overloaded methods to have different method parameters.) Now that the signatures are unique, you can stick with the MVC convention and use the same name for the HttpPost and HttpGet delete methods.
If improving performance in a high-volume application is a priority, you could avoid an unnecessary SQL query to retrieve the row by replacing the lines of code that call the Find and Remove methods with the following code:
C#Copy
Student studentToDelete = new Student() { ID = id };
db.Entry(studentToDelete).State = EntityState.Deleted;
This code instantiates a Student entity using only the primary key value and then sets the entity state to Deleted. That's all that the Entity Framework needs in order to delete the entity.
-
-
-
Performance considerations
In general, a web page shouldn't be loading an arbitrary number of rows. A query should use paging or a limiting approach. For example, the preceding query could use Take to limit the rows returned:
C#Kopyala
public class IndexModel : PageModel
{
    private readonly SchoolContext _context;
    private readonly MvcOptions _mvcOptions;

    public IndexModel(SchoolContext context, IOptions<MvcOptions> mvcOptions)
    {
        _context = context;
        _mvcOptions = mvcOptions.Value;
    }

    public IList<Student> Student { get;set; }

    public async Task OnGetAsync()
    {
        Student = await _context.Students.Take(
            _mvcOptions.MaxModelBindingCollectionSize).ToListAsync();
    }
}
Enumerating a large table in a view could return a partially constructed HTTP 200 response if a database exception occurs part way through the enumeration.
MaxModelBindingCollectionSize defaults to 1024. The following code sets MaxModelBindingCollectionSize:
C#Kopyala
public void ConfigureServices(IServiceCollection services)
{
    int MyMaxModelBindingCollectionSize = 100;
    Int32.TryParse(Configuration["MyMaxModelBindingCollectionSize"],
                               out MyMaxModelBindingCollectionSize);
    
    services.Configure<MvcOptions>(options => 
           options.MaxModelBindingCollectionSize = MyMaxModelBindingCollectionSize);

    services.AddRazorPages();

    services.AddDbContext<SchoolContext>(options =>
          options.UseSqlServer(Configuration.GetConnectionString("SchoolContext")));

    services.AddDatabaseDeveloperPageExceptionFilter();
}

-
-
-
<span asp-validation-for="Venue" class="text-danger"></span>
property'ler için validation kullanmazsan, class tarafında; property'leri required olarak işaretlemen bir işe yaramaz. Örneğin class'ımız şuydu:
public class ConcertFormViewModel
   {
       // property'leri string olarak oluşturduğumuza dikkat:
 
       [Required]
       public string Venue { get; set; }
       
       [Required]
       public string Date { get; set; }
       
       [Required]
       public string Time { get; set; }
       
       [Required]
       public byte Genre { get; set; }
       
       public IEnumerable<Genre> Genres { get; set; } // db'deki tüm Genre'leri dropdownlist'e eklemek için kullanacağımız property
 
       public DateTime GetDateTime()
       {
           return DateTime.Parse(string.Format("{0} {1}", Date, Time));
       }
   }


Bu required attribute'lerini kullanmak client side validation'lar için yeterli değil. View'da; gereken işlem yapılmalı ki validasyon çalışsın.. Yani şunu yazmamız lazım her property için:
<span asp-validation-for="Venue" class="text-danger"></span>

Örnek olarak; venue'nin validasyon yapan html helper'ini silmiş olalım view'dan. Bu durumda client side validation, aşağıdaki resimdeki gibi olacaktır:
 
Görüldüğü üzere venue boş bırakıldığı halde "The venue field is required" gibi bir uyarı verilmedi.
Son
-
-
Abstract data type 	(GITHUB) (örnek)
Abstract data type nedir
Abstract Data type (ADT) is a type (or class) for objects whose behaviour is defined by a set of value and a set of operations.
The definition of ADT only mentions what operations are to be performed but not how these operations will be implemented. It does not specify how data will be organized in memory and what algorithms will be used for implementing the operations. It is called “abstract” because it gives an implementation-independent view. The process of providing only the essentials and hiding the details is known as abstraction.
 
The user of data type does not need to know how that data type is implemented, for example, we have been using Primitive values like int, float, char data types only with the knowledge that these data type can operate and be performed on without any idea of how they are implemented. So a user only needs to know what a data type can do, but not how it will be implemented. Think of ADT as a black box which hides the inner structure and design of the data type. Now we’ll define three ADTs namely List ADT, Stack ADT, Queue ADT.

1.	List ADT
•	The data is generally stored in key sequence in a list which has a head structure consisting of count, pointers and address of compare function needed to compare the data in the list.
 
The data node contains the pointer to a data structure and a self-referential pointer which points to the next node in the list.

//List ADT Type Definitions 
typedef struct node 
{ 
 void *DataPtr; 
 struct node *link; 
} Node; 
typedef struct
{ 
 int count; 
 Node *pos; 
 Node *head; 
 Node *rear; 
 int (*compare) (void *argument1, void *argument2) 
} LIST;  
•	The List ADT Functions is given below:
 
A list contains elements of the same type arranged in sequential order and following operations can be performed on the list.
•	get() – Return an element from the list at any given position.
•	insert() – Insert an element at any position of the list.
•	remove() – Remove the first occurrence of any element from a non-empty list.
•	removeAt() – Remove the element at a specified location from a non-empty list.
•	replace() – Replace an element at any position by another element.
•	size() – Return the number of elements in the list.
•	isEmpty() – Return true if the list is empty, otherwise return false.
•	isFull() – Return true if the list is full, otherwise return false.

2.	Stack ADT

•	In Stack ADT Implementation instead of data being stored in each node, the pointer to data is stored.
•	The program allocates memory for the data and address is passed to the stack ADT.
 
•	The head node and the data nodes are encapsulated in the ADT. The calling function can only see the pointer to the stack.
•	The stack head structure also contains a pointer to top and count of number of entries currently in stack.

A Stack contains elements of the same type arranged in sequential order. All operations take place at a single end that is top of the stack and following operations can be performed:
•	push() – Insert an element at one end of the stack called top.
•	pop() – Remove and return the element at the top of the stack, if it is not empty.
•	peek() – Return the element at the top of the stack without removing it, if the stack is not empty. (peak  yani tepe kelimesinden akla getirilebilir)
•	size() – Return the number of elements in the stack.
•	isEmpty() – Return true if the stack is empty, otherwise return false.
•	isFull() – Return true if the stack is full, otherwise return false.

// C# code to illustrate the 
// Stack.Peek Method 
using System; 
using System.Collections; 
  
class GFG { 
  
    // Driver code 
    public static void Main() 
    { 
  
        // Creating a Stack 
        Stack myStack = new Stack(); 
  
        // Inserting the elements into the Stack 
        myStack.Push("1st Element"); 
        myStack.Push("2nd Element"); 
        myStack.Push("3rd Element"); 
        myStack.Push("4th Element"); 
        myStack.Push("5th Element"); 
        myStack.Push("6th Element"); 
  
        // Displaying the count of elements 
        // contained in the Stack 
        Console.Write("Total number of elements"+ 
                         " in the Stack are : "); 
  
        Console.WriteLine(myStack.Count); 
  
        // Displaying the top element of Stack 
        // without removing it from the Stack 
        Console.WriteLine("Element at the top is : " 
                                  + myStack.Peek()); 
  
        // Displaying the top element of Stack 
        // without removing it from the Stack 
        Console.WriteLine("Element at the top is : " 
                                + myStack.Peek()); 
  
        // Displaying the count of elements 
        // contained in the Stack 
        Console.Write("Total number of elements "+ 
                           "in the Stack are : "); 
  
        Console.WriteLine(myStack.Count); 
    } 
-
-
-




3.	Queue ADT
•	The queue abstract data type (ADT) follows the basic design of the stack abstract data type.
 
•	Each node contains a void pointer to the data and the link pointer to the next element in the queue. The program’s responsibility is to allocate memory for storing the data.


//Queue ADT Type Definitions 
typedef struct node 
{ 
 void *DataPtr; 
 struct node *next; 
} QueueNode; 
typedef struct 
{ 
 QueueNode *front; 
 QueueNode *rear; 
 int count; 
} QUEUE; 

A Queue contains elements of the same type arranged in sequential order. Operations take place at both ends, insertion is done at the end and deletion is done at the front. Following operations can be performed:
•	enqueue() – Insert an element at the end of the queue.
•	dequeue() – Remove and return the first element of the queue, if the queue is not empty.
•	peek() – Return the element of the queue without removing it, if the queue is not empty.
•	size() – Return the number of elements in the queue.
•	isEmpty() – Return true if the queue is empty, otherwise return false.
•	isFull() – Return true if the queue is full, otherwise return false.
From these definitions, we can clearly see that the definitions do not specify how these ADTs will be represented and how the operations will be carried out. There can be different ways to implement an ADT, for example, the List ADT can be implemented using arrays, or singly linked list or doubly linked list. Similarly, stack ADT and Queue ADT can be implemented using arrays or linked lists.
Reference: https://en.wikipedia.org/wiki/Abstract_data_type
This article is contributed by Anuj Chauhan. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.
Don’t stop now and take your learning to the next level. Learn all the important concepts of Data Structures and Algorithms with the help of the most trusted course: DSA Self Paced. Become industry ready at a student-friendly price.
-
-
-
-
-
In Controllers\StudentController.cs, the action method for the Details view uses the Find method to retrieve a single Student entity. 
public ActionResult Details(int? id) 
{ 
if (id == null) 
{ 
return new HttpStatusCodeResult(HttpStatusCode.BadRequest); 
} 
Student student = db.Students.Find(id); 
if (student == null) 
{ 
return HttpNotFound(); 
} 
return View(student); 
}
-
-
-
-
Action Filter, Filter MSDN
Action filter nedir
Action filter dediğimiz aslında action metotların çalışma öncesi ve sonrasına hayat veren özel attribute sınıflarıdır.
Action filter executes before and after an action method executes. Action filter attributes can be applied to an individual action method or to a controller. When action filter applied to controller then it will be applied to all the action methods in that controller.
OutputCache is a built-in action filter attribute that can be apply to an action method for which we want to cache the output. For example, output of the following action method will be cached for 100 seconds.
Example: ActionFilter

[OutputCache(Duration=100)]
public ActionResult Index()
{
    return View();
}
-
-
Filters in ASP.NET Core allow code to be run before or after specific stages in the request processing pipeline.
Built-in filters handle tasks such as:
•	Authorization (preventing access to resources a user isn't authorized for).
•	Response caching (short-circuiting the request pipeline to return a cached response).
Custom filters can be created to handle cross-cutting concerns. Examples of cross-cutting concerns include error handling, caching, configuration, authorization, and logging. Filters avoid duplicating code. For example, an error handling exception filter could consolidate error handling.
This document applies to Razor Pages, API controllers, and controllers with views. Filters don't work directly with Razor components. A filter can only indirectly affect a component when:
•	The component is embedded in a page or view.
•	The page or controller/view uses the filter.
View or download sample (how to download).

How filters work
Filters run within the ASP.NET Core action invocation pipeline, sometimes referred to as the filter pipeline. The filter pipeline runs after ASP.NET Core selects the action to execute.
 
Filter types
Each filter type is executed at a different stage in the filter pipeline:
•	Authorization filters run first and are used to determine whether the user is authorized for the request. Authorization filters short-circuit the pipeline if the request is not authorized.
•	Resource filters:
o	Run after authorization.
o	OnResourceExecuting runs code before the rest of the filter pipeline. For example, OnResourceExecuting runs code before model binding.
o	OnResourceExecuted runs code after the rest of the pipeline has completed.
•	Action filters:
o	Run code immediately before and after an action method is called.
o	Can change the arguments passed into an action.
o	Can change the result returned from the action.
o	Are not supported in Razor Pages.
•	Exception filters apply global policies to unhandled exceptions that occur before the response body has been written to.
•	Result filters run code immediately before and after the execution of action results. They run only when the action method has executed successfully. They are useful for logic that must surround view or formatter execution.

The following diagram shows how filter types interact in the filter pipeline.
 
Implementation
Filters support both synchronous and asynchronous implementations through different interface definitions.
Synchronous filters run code before and after their pipeline stage. For example, OnActionExecuting is called before the action method is called. OnActionExecuted is called after the action method returns.
C#Copy
public class MySampleActionFilter : IActionFilter 
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        // Do something before the action executes.
        MyDebug.Write(MethodBase.GetCurrentMethod(), context.HttpContext.Request.Path);
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        // Do something after the action executes.
        MyDebug.Write(MethodBase.GetCurrentMethod(), context.HttpContext.Request.Path);
    }
}
In the preceding code, MyDebug is a utility function in the sample download.
Asynchronous filters define an On-Stage-ExecutionAsync method. For example, OnActionExecutionAsync:
C#Copy
public class SampleAsyncActionFilter : IAsyncActionFilter
{
    public async Task OnActionExecutionAsync(
        ActionExecutingContext context,
        ActionExecutionDelegate next)
    {
        // Do something before the action executes.

        // next() calls the action method.
        var resultContext = await next();
        // resultContext.Result is set.
        // Do something after the action executes.
    }
}
In the preceding code, the SampleAsyncActionFilter has an ActionExecutionDelegate (next) that executes the action method.

Multiple filter stages
Interfaces for multiple filter stages can be implemented in a single class. For example, the ActionFilterAttribute class implements:
•	Synchronous: IActionFilter and IResultFilter
•	Asynchronous: IAsyncActionFilter and IAsyncResultFilter
•	IOrderedFilter
Implement either the synchronous or the async version of a filter interface, not both. The runtime checks first to see if the filter implements the async interface, and if so, it calls that. If not, it calls the synchronous interface's method(s). If both asynchronous and synchronous interfaces are implemented in one class, only the async method is called. When using abstract classes like ActionFilterAttribute, override only the synchronous methods or the asynchronous methods for each filter type.
Built-in filter attributes
ASP.NET Core includes built-in attribute-based filters that can be subclassed and customized. For example, the following result filter adds a header to the response:
C#Copy
public class AddHeaderAttribute : ResultFilterAttribute
{
    private readonly string _name;
    private readonly string _value;

    public AddHeaderAttribute(string name, string value)
    {
        _name = name;
        _value = value;
    }

    public override void OnResultExecuting(ResultExecutingContext context)
    {
        context.HttpContext.Response.Headers.Add( _name, new string[] { _value });
        base.OnResultExecuting(context);
    }
}
Attributes allow filters to accept arguments, as shown in the preceding example. Apply the AddHeaderAttribute to a controller or action method and specify the name and value of the HTTP header:
C#Copy
[AddHeader("Author", "Rick Anderson")]
public class SampleController : Controller
{
    public IActionResult Index()
    {
        return Content("Examine the headers using the F12 developer tools.");
    }
Use a tool such as the browser developer tools to examine the headers. Under Response Headers, author: Rick Anderson is displayed.
The following code implements an ActionFilterAttribute that:
•	Reads the title and name from the configuration system. Unlike the previous sample, the following code doesn't require filter parameters to be added to the code.
•	Adds the title and name to the response header.
C#Copy
public class MyActionFilterAttribute : ActionFilterAttribute
{
    private readonly PositionOptions _settings;

    public MyActionFilterAttribute(IOptions<PositionOptions> options)
    {
        _settings = options.Value;
        Order = 1;
    }

    public override void OnResultExecuting(ResultExecutingContext context)
    {
        context.HttpContext.Response.Headers.Add(_settings.Title, 
                                                 new string[] { _settings.Name });
        base.OnResultExecuting(context);
    }
}
The configuration options are provided from the configuration system using the options pattern. For example, from the appsettings.json file:
JSONCopy
{
  "Position": {
    "Title": "Editor",
    "Name": "Joe Smith"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}
In the StartUp.ConfigureServices:
•	The PositionOptions class is added to the service container with the "Position" configuration area.
•	The MyActionFilterAttribute is added to the service container.
C#Copy
public void ConfigureServices(IServiceCollection services)
{
    services.Configure<PositionOptions>(
             Configuration.GetSection("Position"));
    services.AddScoped<MyActionFilterAttribute>();

    services.AddControllersWithViews();
}
The following code shows the PositionOptions class:
C#Copy
public class PositionOptions
{
    public string Title { get; set; }
    public string Name { get; set; }
}
The following code applies the MyActionFilterAttribute to the Index2 method:
C#Copy
[AddHeader("Author", "Rick Anderson")]
public class SampleController : Controller
{
    public IActionResult Index()
    {
        return Content("Examine the headers using the F12 developer tools.");
    }

    [ServiceFilter(typeof(MyActionFilterAttribute))]
    public IActionResult Index2()
    {
        return Content("Header values by configuration.");
    }

Under Response Headers, author: Rick Anderson, and Editor: Joe Smith is displayed when the Sample/Index2 endpoint is called.
The following code applies the MyActionFilterAttribute and the AddHeaderAttribute to the Razor Page:
C#Copy
[AddHeader("Author", "Rick Anderson")]
[ServiceFilter(typeof(MyActionFilterAttribute))]
public class IndexModel : PageModel
{
    public void OnGet()
    {
    }
}
Filters cannot be applied to Razor Page handler methods. They can be applied either to the Razor Page model or globally.
Several of the filter interfaces have corresponding attributes that can be used as base classes for custom implementations.
Filter attributes:
•	ActionFilterAttribute
•	ExceptionFilterAttribute
•	ResultFilterAttribute
•	FormatFilterAttribute
•	ServiceFilterAttribute
•	TypeFilterAttribute
Filter scopes and order 
Action filters
Action filters do not apply to Razor Pages. Razor Pages supports IPageFilter and IAsyncPageFilter . For more information, see Filter methods for Razor Pages.
Action filters:
•	Implement either the IActionFilter or IAsyncActionFilter interface.
•	Their execution surrounds the execution of action methods.
The following code shows a sample action filter:
C#Copy
public class MySampleActionFilter : IActionFilter 
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        // Do something before the action executes.
        MyDebug.Write(MethodBase.GetCurrentMethod(), context.HttpContext.Request.Path);
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        // Do something after the action executes.
        MyDebug.Write(MethodBase.GetCurrentMethod(), context.HttpContext.Request.Path);
    }
}
The ActionExecutingContext provides the following properties:
•	ActionArguments - enables reading the inputs to an action method.
•	Controller - enables manipulating the controller instance.
•	Result - setting Result short-circuits execution of the action method and subsequent action filters.
Throwing an exception in an action method:
•	Prevents running of subsequent filters.
•	Unlike setting Result, is treated as a failure instead of a successful result.
The ActionExecutedContext provides Controller and Result plus the following properties:
•	Canceled - True if the action execution was short-circuited by another filter.
•	Exception - Non-null if the action or a previously run action filter threw an exception. Setting this property to null:
o	Effectively handles the exception.
o	Result is executed as if it was returned from the action method.
For an IAsyncActionFilter, a call to the ActionExecutionDelegate:
•	Executes any subsequent action filters and the action method.
•	Returns ActionExecutedContext.
To short-circuit, assign Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext.Result to a result instance and don't call next (the ActionExecutionDelegate).

The framework provides an abstract ActionFilterAttribute that can be subclassed.
The OnActionExecuting action filter can be used to:
•	Validate model state.
•	Return an error if the state is invalid.
C#Copy
public class ValidateModelAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext 
                                           context)
    {
        if (!context.ModelState.IsValid)
        {
            context.Result = new BadRequestObjectResult(
                                                context.ModelState);
        }
    }
 Note
Controllers annotated with the [ApiController] attribute automatically validate model state and return a 400 response. For more information, see Automatic HTTP 400 responses.
The OnActionExecuted method runs after the action method:
•	And can see and manipulate the results of the action through the Result property.
•	Canceled is set to true if the action execution was short-circuited by another filter.
•	Exception is set to a non-null value if the action or a subsequent action filter threw an exception. Setting Exception to null:
o	Effectively handles an exception.
o	ActionExecutedContext.Result is executed as if it were returned normally from the action method.
C#Copy
public class ValidateModelAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext 
                                           context)
    {
        if (!context.ModelState.IsValid)
        {
            context.Result = new BadRequestObjectResult(
                                                context.ModelState);
        }
    }


    public override void OnActionExecuted(ActionExecutedContext 
                                          context)
    {
        var result = context.Result;
        // Do something with Result.
        if (context.Canceled == true)
        {
            // Action execution was short-circuited by another filter.
        }

        if(context.Exception != null)
        {
            // Exception thrown by action or action filter.
            // Set to null to handle the exception.
            context.Exception = null;
        }
        base.OnActionExecuted(context);
    }
}
-
-
-
-
-
Association, aggregation, and composition in OOP explained
How to use association, aggregation, and composition to define relationships between the objects in your application
•	 
 
•	 
 
•	 
 
•	 
 
•	 
 
•	 
 
The Unified Modeling Language (UML) is a de-facto standard for modeling object-oriented systems. In UML there are five different types of relationships: association, aggregation, composition, dependency, and inheritance. This article presents a discussion of the first three of these concepts, leaving the remaining ones to another blog post.
[ .Net roadmap: The new features you can expect in .Net Standard 2.1. | .Net Framework or .Net Core? Learn when to use which. | Keep up with hot topics in programming with InfoWorld’s App Dev Report newsletter. ]
Association in object oriented programming
Association is a semantically weak relationship (a semantic dependency) between otherwise unrelated objects. An association is a “using” relationship between two or more objects in which the objects have their own lifetime and there is no owner.
As an example, imagine the relationship between a doctor and a patient. A doctor can be associated with multiple patients. At the same time, one patient can visit multiple doctors for treatment or consultation. Each of these objects has its own life cycle and there is no “owner” or parent. The objects that are part of the association relationship can be created and destroyed independently.
In UML an association relationship is represented by a single arrow. An association relationship can be represented as one-to-one, one-to-many, or many-to-many (also known as cardinality). Essentially, an association relationship between two or more objects denotes a path of communication (also called a link) between them so that one object can send a message to another. The following code snippet illustrates how two classes, IDGBlogAccount and IDGBlogEntry, are associated with one another.
public class IDGBlogAccount
   {
       private IDGBlogEntry[] blogEntries;
       //Other members of the IDGBlogAccount class
   }
public class IDGBlogEntry
   {
       Int32 blogId;
       string caption;
       string text;
       //Other members of the IDGBlogEntry class
   }
-

Aggregation in object oriented programming
Aggregation is a specialized form of association between two or more objects in which each object has its own life cycle but there exists an ownership as well. Aggregation is a typical whole/part or parent/child relationship but it may or may not denote physical containment. An essential property of an aggregation relationship is that the whole or parent (i.e. the owner) can exist without the part or child and vice versa.  
As an example, an employee may belong to one or more departments in an organization. However, if an employee’s department is deleted, the employee object would not be destroyed but would live on. Note that the relationships between objects participating in an aggregation cannot be reciprocal—i.e., a department may “own” an employee, but the employee does not own the department. In the following code example, an aggregation relationship is evident between the IDGBlogAuthor and IDGBlogAccount classes.
public class IDGBlogAuthor
   {
       private Int32 authorId;
       private string firstName;
       private string lastName;
       //Other members of the IDGBlogAuthor class
   }
public class IDGBlogAccount
   {
       private IDGBlogEntry[] blogEntries;
       //Other members of the IDGBlogAccount class
   }
Aggregation is usually represented in UML using a line with a hollow diamond. Like association, aggregation can involve a one-to-one, one-to-many, or many-to-many relationship between the participating objects. In the case of a one-to-many or many-to-many relationship, we may say that it is a redundant relationship.
-
Composition in object oriented programming
Composition is a specialized form of aggregation. In composition, if the parent object is destroyed, then the child objects also cease to exist. Composition is actually a strong type of aggregation and is sometimes referred to as a “death” relationship. As an example, a house may be composed of one or more rooms. If the house is destroyed, then all of the rooms that are part of the house are also destroyed. The following code snippet illustrates a composition relationship between two classes, House and Room.
public class House
{
   private Room room;
   public House()
   {
       room = new Room();
   }
}
Like aggregation, composition is also a whole/part or parent/child relationship. However, in composition the life cycle of the part or child is controlled by the whole or parent that owns it. It should be noted that this control can either be direct or transitive. That is, the parent may be directly responsible for the creation or destruction of the child or the parent may use a child that has been already created. Similarly, a parent object might delegate the control to some other parent to destroy the child object. Composition is represented in UML using a line connecting the objects with a solid diamond at the end of the object that owns the other object.
I hope this discussion of association, aggregation, and composition relationships has helped you understand how these three concepts differ. Remember that aggregation and composition are both subsets of association. In both aggregation and composition, an object of one class can be the owner of an object of another class. And in both aggregation and composition, the child objects belong to a single parent object, i.e., they may have only one owner.
Finally, in an aggregation relationship, the life cycles of parent objects and child objects are independent. In a composition relationship, the death of a parent object also means the death of its children.
-
-
-
-
-
-
Assigning			      (GITHUB)  (test)
Assign nedir, assigning nedir
Assigning is simply the storing of one value to a variable.  x = 5 assigns the value 5 to the variable  x.
(assign kelime anlamı: allocate (a job or duty) / to give a particular job or piece of work to someone: “The case has been assigned to our most senior officer.”)
x = 5 assigns the value 5 to the variable  x. In some languages, assignment cannot be combined with declaration, but in C# it can be: int x = 5;
Note that the statement object myObject = new object(); combines all four of these.
new object() instantiates a new object object, returning a reference to it.
object myObject declares a new object reference.
= initializes the reference variable by assigning the value of the reference to it.
-
-
-
-
-
Authentication and authorization might sound similar, but they are distinct security processes in the world of identity and access management (IAM).
Authentication confirms that users are who they say they are. Authorization gives those users permission to access a resource.
What Is Authentication?
Authentication is the act of validating that users are whom they claim to be. This is the first step in any security process. 
Complete an authentication process through:
•	Passwords. Usernames and passwords are the most common authentication factors. If a user enters the correct data, the system assumes the identity is valid and grants access.
•	One-time pins. Grant access for only one session or transaction.
•	Authentication apps. Generate security codes via an outside party that grants access.
•	Biometrics. A user presents a fingerprint or eye scan to gain access to the system. 
In some instances, systems require the successful verification of more than one factor before granting access. This multi-factor authentication (MFA) requirement is often deployed to increase security beyond what passwords alone can provide.

What Is Authorization?
Authorization in a system security is the process of giving the user permission to access a specific resource or function. This term is often used interchangeably with access control or client privilege. 
Giving someone permission to download a particular file on a server or providing individual users with administrative access to an application are good examples of authentication. 
In secure environments, authorization must always follow authentication. Users should first prove that their identities are genuine before an organization’s administrators grant them access to the requested resources.
-
-
-
-
-


-
Instance ve obje arasındaki fark! Instance nedir, object nedir
-
-
The Instance and Object are from Object Oriented Programming.
For some programming languages like Java, C++, and Smalltalk, it is important to describe and understand code. In other languages that used in Structured Programming, this concept doesn't exist.
This is a view from Structural Programming. There's no real significant difference that should consume too much of your time. There might be some fancy language that some people might take up a lot of spaces to write about, but at the end of the day, as far as a coder, developer, programmer, architect, is concerned, an instance of a class and an object mean the same thing and can often be used interchangeably. I have never met anyone in my career that would be picky and spend a half-hour trying to point out the differences because there's really none. Time can be better spent on other development efforts.
UPDATE With regards to Swift, this is what Apple who invented Swift prefers :
An instance of a class is traditionally known as an object. However, Swift classes and structures are much closer in functionality than in other languages, and much of this chapter describes functionality that can apply to instances of either a class or a structure type. Because of this, the more general term instance is used.
-
SQL alıştırma siteleri:

https://sqlbolt.com/lesson/select_queries_with_constraints

https://www.hackerrank.com/challenges/revising-the-select-query/problem
-
-
-
Properties expose fields. Fields should (almost always) be kept private to a class and accessed via get and set properties. 
Properties provide a level of abstraction allowing you to change the fields while not affecting the external way they are accessed by the things that use your class.

public class MyClass
{

    // this is a field.  It is private to your class and stores the actual data.
    private string _myField;

    // this is a property. When accessed it uses the underlying field,
    // but only exposes the contract, which will not be affected by the underlying field
    public string MyProperty
    {
        get
        {
            return _myField;
        }
        set
        {
            _myField = value;
        }
    }

    // This is an AutoProperty (C# 3.0 and higher) - which is a shorthand syntax
    // used to generate a private field for you
    public int AnotherProperty{get;set;} 
}
-
Constant (GITHUB)
[constant nedir, constants nedir, const nedir]

MSDN:
You use the const keyword to declare a constant field or a constant local. Constant fields and locals aren't variables and may not be modified. Constants can be numbers, Boolean values, strings, or a null reference. Don’t create a constant to represent information that you expect to change at any time. For example, don’t use a constant field to store the price of a service, a product version number, or the brand name of a company. These values can change over time, and because compilers propagate constants, other code compiled with your libraries will have to be recompiled to see the changes. See also the readonly keyword. For example:
const int X = 0;
public const double GravitationalConstant = 6.673e-11;
private const string ProductName = "Visual C#";
-
-
-
-
-
-
Constant (GITHUB)
[constant nedir, constants nedir, const nedir]
MSDN:
You use the const keyword to declare a constant field or a constant local. Constant fields and locals aren't variables and may not be modified. Constants can be numbers, Boolean values, strings, or a null reference. Don’t create a constant to represent information that you expect to change at any time. For example, don’t use a constant field to store the price of a service, a product version number, or the brand name of a company. These values can change over time, and because compilers propagate constants, other code compiled with your libraries will have to be recompiled to see the changes. See also the readonly keyword. For example:
const int X = 0;
public const double GravitationalConstant = 6.673e-11;
private const string ProductName = "Visual C#";




